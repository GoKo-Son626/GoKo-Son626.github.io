{"posts":[{"title":"hexo-blog","text":"使用hexo和GitHub Pagtes部署一个自己的博客 1. 安装并初始化Hexo 安装 Hexo CLI 1npm install -g hexo-cli 初始化博客项目目录 123mkdir my-blog &amp;&amp; cd my-bloghexo initnpm install 本地预览 1hexo server 启动本地服务：在浏览器访问 http://localhost:4000 查看效果 2. 配置 GitHub Pages 部署 创建GitHub仓库 创建一个仓库，名字叫 你的GitHub用户名.github.io 比如你是 goko，就叫 goko.github.io 安装部署插件 1npm install hexo-deployer-git --save 修改 _config.yml（根目录下）添加部署配置： 12345deploy: type: git # repo建议使用SSH, SSH免密 repo: https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git branch: main # 或者 master，看你的默认分支 生成并部署博客 123hexo cleanhexo generatehexo deploy 3. 域名(.com)绑定 添加域名(在my-blog下) 123echo &quot;&lt;xxxx&gt;.com&quot; &gt; source/CNAME# 或者可以：echo &quot;www.&lt;xxxx&gt;.com&quot; &gt; source/CNAME# 只能添加一个，而且两个需要添加不同的域名解析（如下） 重新部署 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 设置 DNS 解析指向 GitHub Pages A. 使用裸域名（apex 域名）goku72.com 记录类型 主机记录 记录值 说明 A @ 185.199.108.153 GitHub Pages IP A @ 185.199.109.153 GitHub Pages IP A @ 185.199.110.153 GitHub Pages IP A @ 185.199.111.153 GitHub Pages IP example aliyun: 选择业务需求: 将网站域名解析到服务器IPv4地址 选择网站域名(主机记录): .com（对应设置“@”主机记录） 填写 IP（记录值）： 在输入框里粘贴以下四行（每一行一个 IP）： &gt; 185.199.109.153 &gt; 185.199.108.153 &gt; 185.199.110.153 &gt; 185.199.111.153 B. 使用 www.goku72.com 作为主域名 记录类型 主机记录 记录值 说明 CNAME www &lt;github用户名&gt;.github.io. 指向你的 GitHub 用户页仓库 example aliyun: 选择业务需求: 将网站域名解析到另外的目标域名 选择网站域名(主机记录): www..com（对应设置“www”主机记录） 填写 IP（记录值）：&lt;github用户名&gt;.github.io. (最有有一个符号”.”) 4. 设置主题 cd my-blog/themes git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git butterfly 修改_config.yml: theme: butterfly hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 更多主题：https://hexo.io/themes/ 注： 如果AB两个方式都添加了，只需要在 Hexo 项目的 source/CNAME 文件中写 www..com，GitHub Pages 就会自动把 goku72.com 重定向过去，无需额外设置！ 后续换域名只需要：阿里云重新解析 + 修改 source/CNAME + 重新部署 Hexo，就能完成域名迁移。 有些主题可能需要下载插件","link":"/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html"},{"title":"qspinlock","text":"qspinlock 是一种为现代多核系统设计的先进混合自旋锁。它巧妙地融合了两种经典锁的优点：既继承了票据锁（ticket lock）的公平性，又借鉴了 MCS 锁优异的可扩展性。 1. 传统spinlock： 多个等待的 CPU 核心中，谁先获得锁并无保证，存在公平性问题，同时缓存一致性开销大（如MESI），CPU核心越大，cache需求越厉害，缺乏可扩展性 2. Ticket spinlock1234567891011121314151617#define TICKET_NEXT 16typedef struct { union { u32 lock; struct __raw_tickets { /* little endian */ u16 owner; u16 next; } tickets; };} arch_spinlock_t;my_ticket = atomic_fetch_inc(&amp;lock-&gt;tickets.next);while (lock-&gt;tickets.owner != my_ticket) cpu_relax(); 解决了公平问题，防止某些 CPU 永远得不到锁，但所有核都轮询同一个owner变量，read cache line成热点，限制扩展性 3. MCS lock 本质上是一种基于链表结构的自旋锁，每个CPU有一个对应的节点(锁的副本)，基于各自不同的副本变量进行等待，锁本身是共享的，但队列节点是线程自己维护的，每个CPU只需要查询自己对应的本地cache line，仅在这个变量发生变化的时候，才需要读取内存和刷新这条cache line, 不像 classic/ticket对共享变量进行spin 123456789101112131415161718192021222324struct mcs_spinlock { struct mcs_spinlock *next; int locked; /* 1 if lock acquired */ int count; /* nesting count, see qspinlock.c */};static inlinevoid mcs_spin_lock(struct mcs_spinlock **lock, struct mcs_spinlock *node){ struct mcs_spinlock *prev; /* Init node */ node-&gt;locked = 0; node-&gt;next = NULL; prev = xchg(lock, node); if (likely(prev == NULL)) { return; } WRITE_ONCE(prev-&gt;next, node); /* Wait until the lock holder passes the lock down. */ arch_mcs_spin_lock_contended(&amp;node-&gt;locked);} 每个 CPU 线程创建的node 是独立的，每个线程都有自己的 node 实例。但是结构体中多了一个指针使结构体变大了，导致了“内存开销问题”：MCS 锁把竞争带来的 cache-line 抖动降低了，但牺牲了一些内存和部分结构管理的成本。 4. qspinlockinclude/asm-generic/qspinlock_types.h: 锁数据结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758typedef struct qspinlock { union { atomic_t val; /* * By using the whole 2nd least significant byte for the * pending bit, we can allow better optimization of the lock * acquisition for the pending bit holder. */#ifdef __LITTLE_ENDIAN struct { u8 locked; u8 pending; }; struct { u16 locked_pending; u16 tail; };#else struct { u16 tail; u16 locked_pending; }; struct { u8 reserved[2]; u8 pending; u8 locked; };#endif };} arch_spinlock_t;/* * Initializier */#define __ARCH_SPIN_LOCK_UNLOCKED { { .val = ATOMIC_INIT(0) } }/* * Bitfields in the atomic value: * * When NR_CPUS &lt; 16K * 0- 7: locked byte * 8: pending * 9-15: not used * 16-17: tail index * 18-31: tail cpu (+1) * * When NR_CPUS &gt; = 16K * 0- 7: locked byte * 8: pending * 9-10: tail index * 11-31: tail cpu (+1) */#define _Q_SET_MASK(type) (((1U &lt;&lt; _Q_ ## type ## _BITS) - 1)\\&lt;&lt; _Q_ ## type ## _OFFSET)#define _Q_LOCKED_OFFSET 0#define _Q_LOCKED_BITS 8#define _Q_LOCKED_MASK _Q_SET_MASK(LOCKED) When NR_CPUS &lt; 16K： locked：用来表示这个锁是否被人持有（0：无，1：有） pending：可以理解为最优先持锁位，即当unlock之后只有这个位的CPU最先持锁，也有1和0 tail：有idx+CPU构成，用来标识等待队列的最后一个节点。 tail_idx：就是index，它作为mcs_nodes数组的下标使用 tail_CPU：用来表示CPU的编号+1，+1因为规定tail为0的时候表示等待队列中没有成员 kernel/locking/mcs_spinlock.h 12345struct mcs_spinlock { struct mcs_spinlock *next; int locked; /* 1 if lock acquired */ int count; /* nesting count, see qspinlock.c */}; locked = 1:只是说锁传到了当前加节点，但是当前节点还需要主动申请锁(qspinlock -&gt; locked = 1)count：针对四种上下文用于追踪当前用了第几个 node（即 idx），最大为4,不够用时就fallback不排队直接自旋 kernel/locking/qspinlock.c: 123456789101112131415161718#define MAX_NODES 4struct qnode { struct mcs_spinlock mcs;#ifdef CONFIG_PARAVIRT_SPINLOCKS long reserved[2];#endif};/* * Per-CPU queue node structures; we can never have more than 4 nested * contexts: task, softirq, hardirq, nmi. * * Exactly fits one 64-byte cacheline on a 64-bit architecture. * * PV doubles the storage and uses the second cacheline for PV state. */static DEFINE_PER_CPU_ALIGNED(struct qnode, qnodes[MAX_NODES]); 一个 CPU 上可能嵌套多个锁, qnodes针对四种上下文情况下，例：进程上下文中发生中断后再次获取锁 PER_CPU的优点是快，可防止抢锁时再mallock或临时分配导致延迟，成本等问题 申请锁： 快速申请include/asm-generic/qspinlock.h 12345678910111213/** * queued_spin_lock - acquire a queued spinlock * @lock: Pointer to queued spinlock structure */static __always_inline void queued_spin_lock(struct qspinlock *lock){ int val = 0; if (likely(atomic_try_cmpxchg_acquire(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL))) return; queued_spin_lock_slowpath(lock, val);} 中速申请 快速申请失败，queue中为空时，设置锁的pending位 再次检测（检查中间是否有其它cpu进入） 一直循环检测locked位 当locked位为0时，清除pending位获得锁 慢速申请 申请 操作 快速申请 这个锁当前没有人持有，直接通过cmpxchg()设置locked域即可获取了锁 中速申请 锁已经被人持有，但是MCS链表没有其他人，有且仅有一个人在等待这个锁。设置pending域，表示是第一顺位继承者，自旋等待lock-&gt; locked清0，即锁持有者释放锁 慢速申请 进入到queue中自旋等待，若为队列头（队列中没有等待的cpu），说明它已排到最前，可以开始尝试获取锁；否则，它会自旋等待前一个节点释放锁，并通知它可以尝试获取锁了 end: 如果只有1个或2个CPU试图获取锁，那么只需要一个4字节的qspinlock就可以了，其所占内存的大小和ticket spinlock一样。当有3个以上的CPU试图获取锁，则需要(N-2)个MCS node qspinlock中加入”pending”位域的意义，如果是两个CPU试图获取锁，那么第二个CPU只需要简单地设置”pending”为1，而不用创建一个MCS node 试图加锁的CPU数目超过3个，使用ticket spinlock机制就会造成多个CPU的cache line刷新的问题，而qspinlock可以利用MCS node队列来解决这个问题 在多核争用严重场景下，qspinlock 让等待者在本地内存区域自旋，减少了锁的缓存抖动和对总线的竞争消耗 RISCV_QUEUED_SPINLOCKS 只应在平台(RISC-V)具有 Zabha 或 Ziccrse 时启用，不支持的情况不要选用 优先级反转问题，queue会保证了FIFO提高了公平性，但它无法感知任务的优先级，可能因为排在队列前方的低优先级任务未释放锁而发生等待，从而导致 优先级反转","link":"/post/qspinlock.html"},{"title":"RISC-V toolchain","text":"在 RISC-V 开发中, 交叉编译工具链允许我们在一个平台（如 x86 主机）上，为另一个平台（如RISC-V 开发板）生成可执行代码。 核心概念：工具链的“三元组” (Triplet)你经常会看到像 riscv64-unknown-linux-gnu- 这样的名称，这就是工具链的“三元组”，其标准格式为： 1&lt;arch&gt;-&lt;vendor&gt;-&lt;os&gt; &lt;arch&gt; (架构)：指定目标 CPU 架构，例如 riscv64 或 riscv32。 &lt;vendor&gt; (供应商)：通常是 unknown 或公司名。 &lt;os&gt; (操作系统/环境)：这是最关键的部分，它决定了工具链的目标环境和使用的 C 标准库 (libc)。最常见的两个是： elf: 面向裸机 (Bare-metal) 或嵌入式实时操作系统 (RTOS)。 linux-gnu: 面向完整的 GNU/Linux 操作系统。 两大主流工具链详解1. riscv64-unknown-elf用于裸机和嵌入式开发的标准工具链。 目标系统: 没有任何操作系统的环境（裸机），或者使用了轻量级实时操作系统（如 FreeRTOS, RT-Thread）的环境。 C 标准库 (Libc): 使用 Newlib。 Newlib 是一个轻量级的 C 库，专为嵌入式系统设计。它只提供最基础的 C 语言函数（如 strcpy, printf），并且不依赖任何操作系统的系统调用（Syscall）。如果需要文件操作或内存管理，需要实现底层的“桩函数”(stubs)。 应用场景: 编写 Bootloader（如 U-Boot）。 开发 RISC-V 的“特权二进制接口”固件（如 OpenSBI）。 为微控制器 (MCU) 编写固件。 开发简单的操作系统内核。 2. riscv64-linux-gnu用于在 RISC-V 平台上开发 Linux 应用的工具链。 目标系统: 运行完整 Linux 内核的系统。 C 标准库 (Libc): 使用 glibc (GNU C Library)。 glibc 是功能完备的标准 C 库，提供了丰富的 POSIX API 支持（如 fork, pthread, 文件系统操作等）。它深度依赖 Linux 内核提供的系统调用来完成工作。 典型应用场景: 编译一个标准的 C/C++ 应用程序（如 Nginx, Redis），让它运行在 RISC-V 架构的 Linux 发行版上（如 Ubuntu, Debian for RISC-V）。 开发 Linux 用户态驱动或服务程序。 Tip: riscv64-unknown-linux-gnu- 和 riscv64-linux-gnu- 在功能上是等价的，可以互换使用。unknown 字段在这里没有实际影响。 如何获取和安装工具链方式一：使用包管理器 (简单快捷)对于 linux-gnu 工具链，这是最简单的方法。以 Ubuntu/Debian 为例： 123# 安装 C 和 C++ 交叉编译器sudo apt updatesudo apt install gcc-riscv64-linux-gnu g++-riscv64-linux-gnu 优点: 安装简单，一键搞定。 缺点: 版本可能不是最新的，且通常不提供 elf 版本的工具链。 方式二：从源码编译 (推荐，灵活且最新)获取最新版本工具链（包括 elf 和 linux-gnu）的最佳方式。 克隆官方仓库--recursive 参数至关重要，它会同时下载 gcc, binutils 等所有子模块。 12git clone --recursive https://github.com/riscv-collab/riscv-gnu-toolchaincd riscv-gnu-toolchain 配置与编译需要指定安装路径 (--prefix) 和目标架构 (--with-arch, --with-abi)。 编译 elf 工具链 (用于裸机):1234567# 创建一个安装目录mkdir -p /opt/riscv-elf# 配置: 其中 `rv64gc` 指支持 64 位基础整数指令集（I）、乘除法（M）、原子（A）、浮点（F、D）、压缩（C）等扩展；# `lp64d` 表示 long 和 pointer 为 64 位，使用 double 精度浮点。./configure --prefix=/opt/riscv-elf --with-arch=rv64gc --with-abi=lp64d# 编译 (-j`nproc` 使用所有CPU核心加速)make -j$(nproc) 编译 linux-gnu 工具链 (用于Linux):123456# 创建一个安装目录mkdir -p /opt/riscv-linux# 配置./configure --prefix=/opt/riscv-linux# 编译: make linux 是一个便捷的快捷方式，它等同于为 configure 脚本提供了一套适用于编译 Linux 用户态程序的默认参数。make -j$(nproc) linux 注意：make linux 是编译 linux-gnu 工具链的快捷方式。 添加到环境变量为了方便使用，将工具链的 bin 目录添加到 PATH。编辑你的 ~/.bashrc 或 ~/.zshrc 文件： 123456# 添加这行到文件末尾 (根据你编译的类型选择)export PATH=&quot;/opt/riscv-elf/bin:$PATH&quot; # For elf toolchain# export PATH=&quot;/opt/riscv-linux/bin:$PATH&quot; # For linux toolchain# 使配置生效source ~/.bashrc 实际使用1234567// hello.c#include &lt;stdio.h&gt;int main() { printf(&quot;Hello, RISC-V World!\\n&quot;); return 0;} 使用 elf 工具链编译1234567# 编译riscv64-unknown-elf-gcc -o hello.elf hello.c# 查看文件类型file hello.elf# 输出会类似:# hello.elf: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped 这个 hello.elf 是一个静态链接的裸机程序。它不能直接在 x86 Linux 主机上运行，也不能在 RISC-V Linux 系统上直接运行，因为它缺少操作系统加载器所需的信息。它需要被烧录到裸机环境或通过模拟器（如 QEMU-system）加载执行。 这个 hello.elf 文件虽然是标准的 ELF 格式，但它与 Linux 可执行文件有本质区别： 不含 INTERP 段：它不指定动态链接器，因为它不依赖任何动态库。 静态链接: 它静态链接了轻量级的 newlib C 库，而非 glibc。 无系统调用: 其中的 printf 函数最终依赖开发者实现的底层 I/O 桩函数（如通过 UART 发送字符），而不是 Linux 的 write 系统调用。 不同的程序入口: 它的启动代码 (_start) 负责初始化 C 运行环境后调用 main，但 main 返回后程序通常会进入死循环，因为它没有“退出”到操作系统的概念。 使用 linux-gnu 工具链编译1234567# 编译riscv64-linux-gnu-gcc -o hello.linux hello.c# 查看文件类型file hello.linux# 输出会类似:# hello.linux: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, for GNU/Linux 4.15.0, not stripped 这个 hello.linux 是一个动态链接的 Linux 程序。它需要一个 RISC-V Linux 环境来运行，因为它依赖于该环境中的动态链接器 (ld-linux-riscv64-lp64d.so.1) 和 glibc 库。 总结：我该用哪个？ 特性 riscv64-unknown-elf riscv64-linux-gnu 目标平台 裸机 (Bare-metal)、RTOS GNU/Linux 系统 C 库 newlib (轻量级，无 OS 依赖) glibc (功能完备，依赖 Linux 内核) 核心用途 固件、Bootloader、RTOS 应用、简单操作系统内核 编译可在 RISC-V Linux 上运行的应用程序 选择场景 “为一块开发板从零开始写程序。” “在启动的 Linux 上面运行软件。”","link":"/post/riscv-toolchains.html"},{"title":"xxx","text":"前言介绍…. 正文","link":"/post/xxx.html"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"lock","slug":"lock","link":"/tags/lock/"},{"name":"risc-v","slug":"risc-v","link":"/tags/risc-v/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"kernel","slug":"kernel","link":"/categories/kernel/"},{"name":"risc-v","slug":"risc-v","link":"/categories/risc-v/"},{"name":"hexo","slug":"blog/hexo","link":"/categories/blog/hexo/"},{"name":"qspinlock","slug":"kernel/qspinlock","link":"/categories/kernel/qspinlock/"},{"name":"Toolchain","slug":"risc-v/Toolchain","link":"/categories/risc-v/Toolchain/"}],"pages":[{"title":"","text":"Troy's Blog >>> 欢迎交换友链~ 请通过邮件联系我。","link":"/friend/index.html"}]}
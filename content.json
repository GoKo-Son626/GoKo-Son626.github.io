{"posts":[{"title":"Trace-do-chenxiaosong-1","text":"ftraceä½¿ç”¨ ä½ç½® ä½œç”¨ ä½ åœ¨ RISCâ€‘V trace ä»»åŠ¡ä¸­ä¸»è¦ç”¨é€” current_tracer è¯»/å†™å½“å‰æ¿€æ´»çš„ tracer (nop/function_graph/irqsoffâ€¦) åˆ‡æ¢ tracerï¼Œå¸¸ç”¨ function_graphã€nop tracing_on å…¨å±€å¼€å…³ï¼ˆ0/1ï¼‰ ä¸€é”®æš‚åœ/ç»§ç»­æ”¶é›† trace, trace_pipe è¾“å‡ºç¼“å†²åŒºâ€¢ traceï¼šé™æ€å¿«ç…§â€¢ trace_pipeï¼šæµå¼å®æ—¶è¯»å– æ¶ˆè´¹è·Ÿè¸ªç»“æœï¼š `cat trace less&lt;br&gt; cat trace_pipe &gt; out.log` available_tracers æ”¯æŒçš„ tracer åˆ—è¡¨ é€‰å‹æ—¶æŸ¥çœ‹ç¡¬ä»¶æ˜¯å¦æ”¯æŒ function_graph ç­‰ events/ æ‰€æœ‰ tracepoint ç›®å½•æ ‘æ¯ä¸ªäº‹ä»¶éƒ½æœ‰ enableã€format â€¢ å¯/åœç‰¹å®š tracepointâ€¢ æŸ¥çœ‹å­—æ®µå¸ƒå±€ï¼Œå†™ eBPF/bpftrace æ—¶è¦è¯» format set_event æ‰¹é‡å¼€å¯äº‹ä»¶ï¼Œå†™ subsys:event æ¯”å¾ªç¯ echo æ›´å¿« set_ftrace_filter, set_ftrace_notrace é€‰æ‹©è·Ÿè¸ª/æ’é™¤å“ªäº›å‡½æ•° function/function_graph æ¨¡å¼ä¸‹åšç™½/é»‘åå• available_filter_functions å¯è¢«åŠ¨/é™æ€è·Ÿè¸ªçš„å…¨éƒ¨ç¬¦å· æœå‡½æ•°åœ°å€åšåŠ¨æ€ FTRACE æ‰“æ¡© kprobe_events, uprobe_events åŠ¨æ€æ’æ¡©æè¿°æ–‡ä»¶ å‘å†…æ ¸æ³¨å†Œ/æ³¨é”€ kprobeã€uprobe synthetic_events åˆ›å»ºç”¨æˆ·è‡ªå®šä¹‰äº‹ä»¶ å¤æ‚åœºæ™¯ç”¨æ¥æŠŠå¤šäº‹ä»¶å…³è”èšåˆ instances/ æ”¯æŒåˆ›å»ºå¤šå®ä¾‹ buffer éœ€è¦éš”ç¦»å¤šç»„ trace æ—¶ä½¿ç”¨ trace_clock é€‰æ‹©æ—¶é—´æˆ³æ¥æºï¼ˆlocal, global, monoï¼‰ è·Ÿå¤šæ ¸/è·¨ç³»ç»Ÿæ¯”è¾ƒæ—¶é—´æˆ³æ—¶åˆ‡æ¢ options/, trace_options å„ç±»ç»†ç²’åº¦é€‰é¡¹ï¼ˆæ‰“å° pidã€latency â€¦ï¼‰ å¼€å¯ funcgraph-proc, sym-offset ç­‰æé«˜å¯è¯»æ€§ buffer_size_kb, buffer_total_size_kb æ¯â€‘CPU æˆ–å…¨å±€ ringâ€‘buffer å¤§å° é•¿æ—¶é—´é‡‡æ ·å‰è°ƒå¤§é¿å…ä¸¢åŒ… per_cpu/, cpumask æ¯ CPU çš„ buffer/å¼€å…³ è·Ÿè¸ªç‰¹å®šæ ¸æˆ–æŸ¥çœ‹å±€éƒ¨ stats osnoise/, hwlat_detector/ ä¸“ç”¨å»¶è¿Ÿåˆ†æ tracer è‹¥æ’æŸ¥ IRQ/Jitter å¯ç”¨ dynamic_events ç»¼åˆè§†å›¾ï¼ˆkprobe/uprobe/synth ç­‰ï¼‰ å¿«é€Ÿåˆ—å‡ºç°æœ‰åŠ¨æ€äº‹ä»¶","link":"/post/Trace-do-chenxiaosong-1.html"},{"title":"Trace-structure","text":"å¿«é€Ÿæ„å»º Trace å­ç³»ç»Ÿâ€œè®¤çŸ¥â€ 1 Using the TRACE_EVENT() macroï¼ˆpart 1ï¼‰1234567891011121314151617181920212223242526272829303132â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ ğŸŒ ç”¨æˆ·ç©ºé—´å·¥å…·å±‚ â”‚â”‚ strace* trace-cmd perf bpftrace bpftool kernelshark â€¦ â”‚â”‚ Â· strace ä»…é  ptraceï¼Œä¸å…¥å†…æ ¸ Trace ä½“ç³» â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ è°ƒç”¨ / å½•åˆ¶ / åŠ è½½â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ ğŸ§© ç»Ÿä¸€ Trace æ§åˆ¶æ¥å£ (tracefs) â”‚â”‚ /sys/kernel/debug/tracing/* (ftrace debugfs) â”‚â”‚ tracefs APIs (kernel/trace/*.c) â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ è¯»å†™æ§åˆ¶æ–‡ä»¶æˆ– ioctlâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ ğŸ— å†…æ ¸ Trace åŸºç¡€æ¡†æ¶ (TRACE SUBSYS) â”‚â”‚ â€¢ ftrace core â€”â€” function/function_graph/irqsoff/â€¦ â”‚â”‚ â€¢ trace events â€”â€” äº‹ä»¶æ³¨å†Œè¡¨ã€filtersã€ringâ€‘buffer â”‚â”‚ â€¢ hook dispatch â€”â€” æŠŠæ•°æ®å†™ ring buffer æˆ–è°ƒç”¨ eBPF â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ è°ƒç”¨ / é™„ç€â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ ğŸ”§ ä½å±‚æ’æ¡©é’©å­ / Instrumentation ç‚¹ â”‚â”‚ â”œâ”€ tracepoints (ç”± TRACE_EVENT / DEFINE_EVENT ç”Ÿæˆ) â”‚â”‚ â”œâ”€ kprobes (åŠ¨æ€æ’å†…æ ¸æŒ‡ä»¤) â”‚â”‚ â”œâ”€ uprobes (åŠ¨æ€æ’ç”¨æˆ·è¿›ç¨‹æŒ‡ä»¤) â”‚â”‚ â””â”€ fentry/fexit (BPF_FENTRY, æ¯” kprobe æ›´è½»é‡çš„ BPF é’©å­) â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ attachâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ âš™ï¸ eBPF æ‰§è¡Œå±‚ (BPF VM) â”‚â”‚ â€¢ BPF ç¨‹åºå¯æŒ‚ tracepoints / kprobe / fentry / perf events â”‚â”‚ â€¢ è¿è¡Œåå¯æŠŠæ•°æ®å†™ perfâ€‘ringâ€‘buffer / maps â†’ ç”¨æˆ·ç©ºé—´ â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ å…³é”®è¯´æ˜ å±‚ è¯´æ˜ ç”¨æˆ·ç©ºé—´å·¥å…·å±‚ è´Ÿè´£â€œæ§åˆ¶/é‡‡é›†/è§£æâ€ã€‚trace-cmd, perf, bpftrace éƒ½ç»ç”± tracefs æˆ– perf_event ç³»ç»Ÿè°ƒç”¨ä¸å†…æ ¸äº¤äº’ã€‚strace ä»…åŸºäº ptrace()ï¼Œå¹¶ä¸ä¾èµ–å†…æ ¸ Trace æ¡†æ¶ã€‚ tracefs æ§åˆ¶æ¥å£ /sys/kernel/debug/tracing æš´éœ²ä¸€å †æ–‡ä»¶ï¼Œå¦‚ current_tracer, events/*/enable, ä»»ä½•å·¥å…·éƒ½å¯ä»¥ç›´æ¥ echo æˆ– ioctlï¼›trace-cmd å°±æ˜¯æ‰¹é‡æ“ä½œè¿™äº›æ–‡ä»¶ã€‚ å†…æ ¸ Trace åŸºç¡€æ¡†æ¶ æŠŠ ftraceï¼ˆå‡½æ•°çº§ï¼‰ä¸ trace eventsï¼ˆäº‹ä»¶çº§ï¼‰ç»Ÿä¸€ï¼›å†³å®šå¦‚ä½•å†™ ring bufferã€å¦‚ä½•åšè¿‡æ»¤ï¼›åŒå±‚è¿˜åŒ…æ‹¬ irqsoffã€preemptoffã€wakeup ç­‰ç‰¹å®š tracerã€‚ ä½å±‚æ’æ¡©é’©å­ çœŸæ­£â€œè¢«å†…æ ¸ä»£ç è°ƒç”¨æˆ–æ‰“è¡¥ä¸â€çš„åœ°æ–¹ï¼šâ€¢ tracepoints = é™æ€å® TRACE_EVENT() ç”Ÿæˆçš„å‡½æ•°ï¼›â€¢ kprobe/uprobe = è¿è¡Œæ—¶åœ¨æŒ‡ä»¤å¤´æ’å…¥ int3 ç­‰é™·é˜±ï¼›â€¢ fentry/fexit = BPF ç›´æ¥åœ¨å‡½æ•° prologue/epilogue é™„é’©ï¼›è¿™äº›é’©å­æŠŠé‡‡æ ·æ•°æ®äº¤ç»™ä¸Šä¸€å±‚æ¡†æ¶å¤„ç†ã€‚ eBPF æ‰§è¡Œå±‚ å±äºå†…æ ¸ï¼Œæ˜¯ä¸€ç§è¿è¡Œåœ¨å†…æ ¸é‡Œçš„â€œè™šæ‹Ÿæœºâ€ã€‚å®ƒä¸æ˜¯è¿›ç¨‹ï¼Œè€Œæ˜¯å†…æ ¸ä¸­çš„ç¨‹åºè¿è¡Œç¯å¢ƒï¼Œæ”¯æŒåŠ è½½ã€è¿è¡Œå°ç¨‹åºï¼ˆå­—èŠ‚ç ï¼‰ã€‚è¿™äº›å°ç¨‹åºç”±ç”¨æˆ·æ€å·¥å…·ç¼–è¯‘/åŠ è½½ï¼Œæ¯”å¦‚ï¼šbpftrace -e â€˜tracepoint:syscalls:sys_enter_open { printf(â€œopen called\\nâ€); }â€™ bpftool prog load prog.o /sys/fs/bpf/â€¦ è¿™äº›ç¨‹åºè¢«â€œåŠ è½½åˆ°å†…æ ¸å†…å­˜ä¸­ï¼Œå¹¶ç»‘å®šåˆ°æŸä¸ª hook ç‚¹ï¼ˆæ¯”å¦‚ tracepointï¼‰ä¸Šâ€ã€‚ä½†å¯åŠ è½½/å¸è½½å­—èŠ‚ç ï¼›å¯ä»¥æŒ‚åˆ° tracepoint/kprobe ç­‰ï¼›æ‰§è¡Œé€»è¾‘åæŠŠç»“æœå†™ ring buffer æˆ– BPF mapsï¼Œç”¨æˆ·ç©ºé—´å·¥å…·å†è¯»ã€‚ eBPF ç¨‹åºæ˜¯ç”¨æˆ·ç©ºé—´ç¼–è¯‘ â†’ ç³»ç»Ÿè°ƒç”¨ä¼ ç»™å†…æ ¸ â†’ verifier éªŒè¯ â†’ æŒ‚åˆ°é’©å­ç‚¹ â†’ è¿è¡Œ â†’ å¯ä»¥å¸è½½ å·¥å…·( trace-cmd / perf / bpftrace ) â†’ æ“ä½œ tracefs æ¥å£ â†’ é©±åŠ¨ ftrace + trace events æ¡†æ¶ â†’ ä¾æ‰˜ tracepoint / kprobe / fentry ç­‰é’©å­æ”¶æ•° â†’ (å¯é€‰) äº¤ç»™ eBPF åšå®æ—¶å¤„ç† â†’ æ•°æ®è½åˆ° ring buffer â†’ å·¥å…·è§£ææ˜¾ç¤º é’©å­å‡½æ•°æ˜¯ä¸€ç§æœºåˆ¶ï¼šæä¾›â€œæŒ‚é’©â€ä½ç½®ï¼Œå›è°ƒå‡½æ•°æ˜¯ä¸€ä¸ªå‡½æ•°ï¼ˆä½ å†™çš„ï¼‰ï¼Œå‡½æ•°æŒ‚åˆ°é’©å­ä¸Šåé’©å­è¢«è§¦å‘å¯ä»¥è°ƒç”¨å‡½æ•°é’©å­å‡½æ•°ï¼šâ€œé’©å­å‡½æ•°â€æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ç§ ç‰¹å®šç”¨é€”çš„å›è°ƒå‡½æ•°ã€‚æˆ‘ä»¬åœ¨å†…æ ¸é‡Œç”¨â€œé’©å­â€è¿™ä¸ªè¯ï¼Œæ„æ€æ˜¯ï¼šâ€œæˆ‘åœ¨è¿™é‡Œç•™äº†ä¸€ä¸ªé’©å­ï¼ˆhook pointï¼‰ï¼Œä½ å¯ä»¥æŒ‚ä¸Šè‡ªå·±çš„å‡½æ•°ï¼Œå½“æŸä¸ªè¡Œä¸ºå‘ç”Ÿæ—¶ï¼Œè¿™ä¸ªå‡½æ•°å°±ä¼šè¢«è°ƒç”¨ã€‚â€å›è°ƒå‡½æ•°ï¼šå›è°ƒå‡½æ•°å°±æ˜¯ä½ æå‰å®šä¹‰å¥½çš„å‡½æ•°æŒ‡é’ˆï¼Œç„¶ååœ¨æŸä¸ªæ—¶æœºç”±åˆ«äººï¼ˆç³»ç»Ÿã€åº“ã€æ¡†æ¶ï¼‰è°ƒç”¨å®ƒã€‚ä½ æŠŠ my_callback æ³¨å†Œè¿›å»ï¼›å½“â€œäº‹ä»¶â€è§¦å‘æ—¶ï¼Œç³»ç»Ÿè°ƒç”¨ä½ çš„my_callbackã€‚ex: 123456789101112void my_callback(int value) { printf(&quot;callback called with value = %d\\n&quot;, value);}void trigger_event(void (*cb)(int)) { cb(42); // åœ¨â€œäº‹ä»¶â€å‘ç”Ÿæ—¶ï¼Œè°ƒç”¨ä½ çš„å›è°ƒå‡½æ•°}int main() { trigger_event(my_callback); // æ³¨å†Œå›è°ƒ return 0;} trace marker æ˜¯ä¸€ç§æ—©æœŸçš„å†…æ ¸è·Ÿè¸ªæ‰‹æ®µï¼šç›´æ¥æŠŠ printf(â€œsome event happened: %dâ€, value); è¿™æ ·çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²å†™è¿›äº†å†…æ ¸ä»£ç é‡Œï¼Œéå¸¸åƒæ˜¯â€œè°ƒè¯•ä¿¡æ¯â€ã€‚ä½†è¿™åšæ³•æ±¡æŸ“äº†ä»£ç ï¼Œçœ‹èµ·æ¥åƒæ˜¯ debug æ²¡åˆ å¹²å‡€ã€‚ åæ¥ Mathieu Desnoyers è®¾è®¡äº† tracepointsï¼Œåšæ³•æ˜¯ï¼š åœ¨å†…æ ¸çš„æŸäº›é€»è¾‘ç‚¹æ”¾ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œæ¯”å¦‚ trace_my_event(foo, bar); è¿™ä¸ªå‡½æ•°ä¸ä¼šç›´æ¥æ‰“å°ä»»ä½•ä¿¡æ¯ï¼Œè€Œæ˜¯ä¼šå»æŸ¥æœ‰æ²¡æœ‰äººæ³¨å†Œäº†å›è°ƒå‡½æ•°ï¼ˆä¹Ÿå°±æ˜¯æŒ‚é’©å­ï¼‰ï¼› å¦‚æœæœ‰äººæ³¨å†Œäº†ï¼Œå°±è°ƒç”¨æ³¨å†Œè€…çš„å›è°ƒå‡½æ•°ï¼ŒæŠŠå‚æ•° foo, bar ä¼ è¿›å»ã€‚å°±åƒæˆ‘ä¸Šé¢ä¸¾çš„ trigger_event(cb) çš„ä¾‹å­ã€‚è¿™æ ·åšæœ‰ä¸¤ä¸ªå¥½å¤„ï¼š å†…æ ¸ä»£ç æœ¬èº« ä¸å†å…³å¿ƒè°ƒè¯•æˆ–è·Ÿè¸ªé€»è¾‘ï¼Œåªç•™äº†ä¸ªé’©å­ç‚¹ï¼› å›è°ƒå‡½æ•°å¯ä»¥æ¥æ”¶ç±»å‹æ˜ç¡®çš„ç»“æ„ä½“æŒ‡é’ˆï¼Œæ•ˆç‡æ›´é«˜ï¼Œä¸éœ€è¦å»è§£ææ ¼å¼åŒ–å­—ç¬¦ä¸²äº†ã€‚ ä½†æ˜¯é—®é¢˜æ˜¯ï¼šä½ æ¯æ¬¡æƒ³ä½¿ç”¨ tracepointï¼Œå°±è¦å†™ä¸€å † callback å‡½æ•°ï¼Œé‡å¤åˆç¹çã€‚ ä¸ºäº†è§£å†³â€œå†™å›è°ƒå¤ªéº»çƒ¦â€çš„é—®é¢˜ï¼šTRACE_EVENT() å®è¯ç”Ÿï¼šè¿™ä¸ªå®å¸®ä½ è‡ªåŠ¨ç”Ÿæˆï¼š - tracepoint çš„å®šä¹‰ï¼› - å¯¹åº”çš„ callback å‡½æ•°ï¼ˆé’©å­å‡½æ•°ï¼‰ï¼› - æ•°æ®æ ¼å¼åŒ–çš„é€»è¾‘ã€‚ä½ åªéœ€è¦å†™ä¸€ä¸ªå®æè¿°ï¼Œæ¯”å¦‚ï¼š 12345678910111213TRACE_EVENT(my_event, TP_PROTO(int a, int b), TP_ARGS(a, b), TP_STRUCT__entry( __field(int, a) __field(int, b) ), TP_fast_assign( __entry-&gt;a = a; __entry-&gt;b = b; ), TP_printk(&quot;a=%d b=%d&quot;, __entry-&gt;a, __entry-&gt;b)); ç„¶åä¸€åˆ‡éƒ½è‡ªåŠ¨ç”Ÿæˆï¼ŒFtraceã€perfã€LTTngã€SystemTap éƒ½èƒ½ç”¨è¿™å¥—ç³»ç»Ÿæ¥è¿›è¡Œè·Ÿè¸ªã€‚TRACE_EVENT()å®çš„å‰–æè‡ªåŠ¨åŒ–è·Ÿè¸ªç‚¹æœ‰å„ç§å¿…é¡»æ»¡è¶³çš„è¦æ±‚ï¼š å®ƒå¿…é¡»åˆ›å»ºä¸€ä¸ªå¯ä»¥æ”¾ç½®åœ¨å†…æ ¸ä»£ç ä¸­çš„è·Ÿè¸ªç‚¹ã€‚ å®ƒå¿…é¡»åˆ›å»ºä¸€ä¸ªå¯ä»¥æŒ‚æ¥åˆ°è¯¥è·Ÿè¸ªç‚¹çš„å›è°ƒå‡½æ•°ã€‚ å›è°ƒå‡½æ•°å¿…é¡»èƒ½å¤Ÿä»¥æœ€å¿«çš„æ–¹å¼å°†ä¼ é€’ç»™å®ƒçš„æ•°æ®è®°å½•åˆ°è·Ÿè¸ªå™¨ç¯å½¢ç¼“å†²åŒºä¸­ã€‚ å®ƒå¿…é¡»åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œå¯ä»¥è§£æè®°å½•åˆ°ç¯å½¢ç¼“å†²åŒºçš„æ•°æ®å¹¶å°†å…¶è½¬æ¢ä¸ºè·Ÿè¸ªå™¨å¯ä»¥æ˜¾ç¤ºç»™ç”¨æˆ·çš„äººç±»å¯è¯»çš„æ ¼å¼ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼ŒTRACE_EVENT()å®è¢«åˆ†è§£ä¸ºå…­ä¸ªéƒ¨åˆ†ï¼Œå®ƒä»¬ä¸å®çš„å‚æ•°ç›¸å¯¹åº”ï¼šTRACE_EVENTï¼ˆåç§°ã€åè®®ã€å‚æ•°ã€ç»“æ„ã€åˆ†é…ã€æ‰“å°ï¼‰ nameâ€”â€”è¦åˆ›å»ºçš„è·Ÿè¸ªç‚¹çš„åç§°ã€‚ åŸå‹- è·Ÿè¸ªç‚¹å›è°ƒçš„åŸå‹ args - ä¸åŸå‹åŒ¹é…çš„å‚æ•°ã€‚ struct - è·Ÿè¸ªå™¨å¯ä»¥ä½¿ç”¨ï¼ˆä½†ä¸æ˜¯å¿…é¡»ï¼‰æ¥å­˜å‚¨ä¼ é€’åˆ°è·Ÿè¸ªç‚¹çš„æ•°æ®çš„ç»“æ„ã€‚ åˆ†é…â€”â€”ä»¥ç±»ä¼¼ C çš„æ–¹å¼å°†æ•°æ®åˆ†é…ç»™ç»“æ„ã€‚ print - ä»¥äººç±»å¯è¯»çš„ ASCII æ ¼å¼è¾“å‡ºç»“æ„çš„æ–¹å¼ã€‚ Tracepoint åç§° ç”¨é€”ç®€ä»‹ sched_switch æ ¸å¿ƒ tracepointï¼Œä»»åŠ¡åˆ‡æ¢æ—¶è§¦å‘ sched_wakeup æœ‰ä»»åŠ¡è¢«å”¤é†’ï¼ˆé€šå¸¸è¿›å…¥å¯è¿è¡Œé˜Ÿåˆ—ï¼‰æ—¶è§¦å‘ sched_wakeup_new æ–°åˆ›å»ºä»»åŠ¡å”¤é†’æ—¶è§¦å‘ï¼ˆåŒºåˆ«äºå·²æœ‰ä»»åŠ¡ï¼‰ sched_migrate_task ä»»åŠ¡åœ¨ CPU ä¹‹é—´è¿ç§»æ—¶è§¦å‘ sched_kthread_stop / _ret å†…æ ¸çº¿ç¨‹åœæ­¢ç›¸å…³ sched_kthread_work_* å†…æ ¸çº¿ç¨‹ workqueue è°ƒåº¦è¿‡ç¨‹ sched_process_fork åˆ›å»ºå­è¿›ç¨‹æ—¶è§¦å‘ sched_process_exec exec è°ƒç”¨æ›¿æ¢ç¨‹åºæ˜ åƒæ—¶è§¦å‘ sched_process_exit ä»»åŠ¡é€€å‡ºæ—¶è§¦å‘ æ ¸å¿ƒtracepoint: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * Tracepoint for task switches, performed by the scheduler: */TRACE_EVENT(sched_switch, TP_PROTO(bool preempt, struct task_struct *prev, struct task_struct *next, unsigned int prev_state), TP_ARGS(preempt, prev, next, prev_state), TP_STRUCT__entry( __array( char, prev_comm, TASK_COMM_LEN ) __field( pid_t, prev_pid ) __field( int, prev_prio ) __field( long, prev_state ) __array( char, next_comm, TASK_COMM_LEN ) __field( pid_t, next_pid ) __field( int, next_prio ) ), TP_fast_assign( memcpy(__entry-&gt;prev_comm, prev-&gt;comm, TASK_COMM_LEN); __entry-&gt;prev_pid = prev-&gt;pid; __entry-&gt;prev_prio = prev-&gt;prio; __entry-&gt;prev_state = __trace_sched_switch_state(preempt, prev_state, prev); memcpy(__entry-&gt;next_comm, next-&gt;comm, TASK_COMM_LEN); __entry-&gt;next_pid = next-&gt;pid; __entry-&gt;next_prio = next-&gt;prio; /* XXX SCHED_DEADLINE */ ), TP_printk(&quot;prev_comm=%s prev_pid=%d prev_prio=%d prev_state=%s%s ==&gt; next_comm=%s next_pid=%d next_prio=%d&quot;, __entry-&gt;prev_comm, __entry-&gt;prev_pid, __entry-&gt;prev_prio, (__entry-&gt;prev_state &amp; (TASK_REPORT_MAX - 1)) ? __print_flags(__entry-&gt;prev_state &amp; (TASK_REPORT_MAX - 1), &quot;|&quot;, { TASK_INTERRUPTIBLE, &quot;S&quot; }, { TASK_UNINTERRUPTIBLE, &quot;D&quot; }, { __TASK_STOPPED, &quot;T&quot; }, { __TASK_TRACED, &quot;t&quot; }, { EXIT_DEAD, &quot;X&quot; }, { EXIT_ZOMBIE, &quot;Z&quot; }, { TASK_PARKED, &quot;P&quot; }, { TASK_DEAD, &quot;I&quot; }) : &quot;R&quot;, __entry-&gt;prev_state &amp; TASK_REPORT_MAX ? &quot;+&quot; : &quot;&quot;, __entry-&gt;next_comm, __entry-&gt;next_pid, __entry-&gt;next_prio)); é™¤ç¬¬ä¸€ä¸ªå‚æ•°å¤–ï¼Œæ‰€æœ‰å‚æ•°éƒ½å°è£…åœ¨å¦ä¸€ä¸ªå®ä¸­ï¼ˆTP_PROTOã€TP_ARGSã€TP_STRUCT__entryã€ TP_fast_assignå’ŒTP_printk ï¼‰ã€‚è¿™äº›å®åœ¨å¤„ç†è¿‡ç¨‹ä¸­æä¾›äº†æ›´å¤šæ§åˆ¶ï¼Œå¹¶ä¸”å…è®¸åœ¨TRACE_EVENT()å®ä¸­ä½¿ç”¨é€—å·ã€‚ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯åç§°:ç¬¬äºŒä¸ªå‚æ•°æ˜¯åŸå‹: å®ƒæ—¢æ˜¯æ·»åŠ åˆ°å†…æ ¸ä»£ç çš„ tracepoint çš„åŸå‹ï¼Œä¹Ÿæ˜¯å›è°ƒå‡½æ•°çš„åŸå‹ã€‚tracepoint è°ƒç”¨å›è°ƒå‡½æ•°ï¼Œå°±åƒå›è°ƒå‡½æ•°åœ¨ tracepoint çš„ä½ç½®è¢«è°ƒç”¨ä¸€æ ·ã€‚ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯åŸå‹ä½¿ç”¨çš„å‚æ•°:è¿™çœ‹èµ·æ¥å¯èƒ½æœ‰ç‚¹å¥‡æ€ªï¼Œä½†è¿™ä¸ä»…æ˜¯TRACE_EVENT() å®æ‰€å¿…éœ€çš„ï¼Œä¹Ÿæ˜¯åº•å±‚ tracepoint åŸºç¡€æ¶æ„æ‰€å¿…éœ€çš„ã€‚tracepoint ä»£ç åœ¨æ¿€æ´»æ—¶ä¼šè°ƒç”¨å›è°ƒå‡½æ•°ï¼ˆä¸€ä¸ª tracepoint å¯èƒ½è¢«åˆ†é…å¤šä¸ªå›è°ƒå‡½æ•°ï¼‰ã€‚åˆ›å»º tracepoint çš„å®å¿…é¡»èƒ½å¤Ÿè®¿é—®åŸå‹å’Œå‚æ•°ã€‚ä¸‹é¢å±•ç¤ºäº† tracepoint å®å®ç°æ­¤ç›®çš„æ‰€éœ€çš„æ­¥éª¤ï¼š 123456#define TRACE_POINT(name, proto, args) \\void trace_##name(proto) \\{ \\ if (trace_##name##_active) \\ callback(args); \\} ç¬¬å››ä¸ªå‚æ•°æ˜¯ç»“æ„: è¿™ä¸ªç»“æ„ å†³å®šäº†æ¯æ¬¡ tracepoint è¢«è§¦å‘æ—¶è¦è®°å½•ä»€ä¹ˆå†…å®¹åˆ° trace bufferï¼ˆè·Ÿè¸ªç¼“å†²åŒºï¼‰ä¸­ã€‚å®šä¹‰ trace buffer ç»“æ„ä½“å­—æ®µ; å°±æ˜¯å‘Šè¯‰å†…æ ¸ ring buffer è¦æœ‰å“ªå‡ ä¸ªå­—æ®µã€æ¯ä¸ªå­—æ®µå å¤šå¤§ç¬¬äº”ä¸ªå‚æ•°æ˜¯ä»»åŠ¡: TP_fast_assign() çš„ä¸»è¦ä½œç”¨å°±æ˜¯å°†äº‹ä»¶é‡‡æ ·æ—¶çš„æ•°æ®ï¼Œå†™å…¥åˆ° tracepoint å¯¹åº”çš„ç¯å½¢ç¼“å†²åŒºä¸­ï¼Œå…¶å¡«å……çš„å¯¹è±¡å°±æ˜¯ TP_STRUCT__entry ä¸­å®šä¹‰çš„ç»“æ„ä½“å­—æ®µã€‚ __entry æ˜¯æŒ‡å‘ TP_STRUCT__entry ä¸­å®šä¹‰ç»“æ„çš„æŒ‡é’ˆç¬¬å…­ä¸ªå‚æ•°æ˜¯æ‰“å°: å®šä¹‰ ftrace / trace-cmd / perf ç­‰å·¥å…·åœ¨è¾“å‡º trace äº‹ä»¶æ—¶çš„æ ¼å¼å­—ç¬¦ä¸²ï¼Œç›¸å½“äº printf æ ¼å¼ã€‚ eBPFï¼ˆExtended Berkeley Packet Filterï¼‰ æ˜¯ Linux å†…æ ¸ä¸­çš„ä¸€ä¸ªå¼ºå¤§æœºåˆ¶ï¼Œå®ƒå…è®¸ä½ åœ¨å†…æ ¸ç©ºé—´ä¸­å®‰å…¨ã€å—æ§åœ°è¿è¡Œå°ç¨‹åºï¼Œå®ç°è¯¸å¦‚ï¼š æ€§èƒ½åˆ†æï¼ˆæ¯”å¦‚æ›¿ä»£ perf å·¥å…·ï¼‰ ç³»ç»Ÿè°ƒç”¨è·Ÿè¸ªï¼ˆæ¯”å¦‚æ›¿ä»£ straceï¼‰ ç½‘ç»œåŒ…è¿‡æ»¤/ç›‘æ§ï¼ˆæ›¿ä»£ iptables, tcpdump ç­‰ï¼‰ å®‰å…¨ç›‘æ§ã€æ²™ç®± å®ƒæœ€ç‰›çš„åœ°æ–¹åœ¨äºï¼šæ— éœ€æ”¹å†…æ ¸ä»£ç ã€æ— éœ€åŠ è½½å†…æ ¸æ¨¡å—ï¼Œå°±å¯ä»¥â€œåœ¨å†…æ ¸é‡Œè¿è¡Œä»£ç â€ã€‚ eBPF ç¨‹åºï¼š æ˜¯å†™åœ¨ç”¨æˆ·ç©ºé—´çš„ç¨‹åºï¼ˆç”¨ C å†™ï¼Œæˆ–è€…ç”¨æ›´é«˜çº§è¯­è¨€ç”Ÿæˆï¼‰ ç¼–è¯‘æˆ eBPF å­—èŠ‚ç ï¼ˆåƒæ±‡ç¼–ä¸€æ ·ï¼‰ åŠ è½½åˆ°å†…æ ¸ä¸­ åœ¨æŸäº›é’©å­ç‚¹ï¼ˆæ¯”å¦‚ tracepointã€kprobeã€syscallï¼‰è¿è¡Œ eBPF å¯ä»¥æŒ‚è½½åˆ° tracepoint ä¸Šï¼š ç›‘å¬è°ƒåº¦å™¨è¡Œä¸ºï¼ˆæ¯”å¦‚å“ªä¸ªè¿›ç¨‹åˆ‡äº†è°ï¼‰ æ‹¿åˆ° sched_switch æä¾›çš„å„ç§æ•°æ®å­—æ®µï¼ˆprev_pid, next_pid, prev_state, â€¦ï¼‰ å†æŠŠè¿™äº›ä¿¡æ¯ç»Ÿè®¡ã€ä¸ŠæŠ¥ã€è¿‡æ»¤ã€å¯è§†åŒ– åœ¨ TP_STRUCT__entry(â€¦) ä¸­å®šä¹‰äº† tracepoint äº§ç”Ÿçš„æ•°æ®ç»“æ„ï¼š 123456789struct { char prev_comm[TASK_COMM_LEN]; pid_t prev_pid; int prev_prio; long prev_state; char next_comm[TASK_COMM_LEN]; pid_t next_pid; int next_prio;}; è¿™äº›å°±æ˜¯ eBPF ç¨‹åºâ€œèƒ½çœ‹åˆ°ã€èƒ½è¯»å–â€çš„å­—æ®µã€‚å› ä¸ºï¼š å†…æ ¸ä¼šæŠŠè¿™äº›å­—æ®µä»¥ç»“æ„ä½“å½¢å¼å†™å…¥ ring bufferï¼ˆè·Ÿè¸ªç¼“å†²åŒºï¼‰ eBPF ç¨‹åºé™„åŠ ä¸Šå»ä¹‹åï¼Œä¼šè¢«ä¼ ä¸€ä¸ª ctxï¼ˆä¸Šä¸‹æ–‡æŒ‡é’ˆï¼‰ ç¨‹åºé€šè¿‡è¯»å– ctx ä¸­çš„å­—æ®µæ¥åšåˆ†æå¤„ç† strace æ˜¯ çº¯ç”¨æˆ·æ€çš„å·¥å…·ï¼Œå®ƒåŸºäº Linux æä¾›çš„ ptrace() ç³»ç»Ÿè°ƒç”¨ï¼Œé€šè¿‡ â€œæˆªè·è¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨å…¥å£å’Œè¿”å›â€ å®ç°åŠŸèƒ½ã€‚å®ƒå¹¶ä¸çŸ¥é“ tracepoint çš„å­˜åœ¨ï¼Œä¹Ÿä¸ä½¿ç”¨å®ƒã€‚ ä»€ä¹ˆå«â€œåŠ¨æ€æ³¨å…¥ eBPF æ‰€éœ€å­—æ®µå¸ƒå±€â€ï¼Ÿæ„æ€å°±æ˜¯ï¼š ä½ ä¸éœ€è¦åœ¨å†™å†…æ ¸ä»£ç æ—¶å°±æŠŠ eBPF å†™è¿›å» å†…æ ¸åªéœ€è¦åœ¨ tracepoint é‡Œç”¨ TRACE_EVENT æ­£ç¡®å®šä¹‰äº†å­—æ®µå¸ƒå±€ eBPF ç¨‹åºåœ¨è¿è¡Œæ—¶ attach åˆ°è¯¥ tracepointï¼Œå°±èƒ½åŠ¨æ€è¯»å–è¿™äº›å­—æ®µ è¿™å°±æ˜¯â€œåŠ¨æ€æ³¨å…¥â€ï¼š ä¸æ”¹å†…æ ¸ ä¸é‡å¯ç³»ç»Ÿ eBPF ç¨‹åºè¿è¡Œæ—¶ attach æŒ‰ tracepoint ç»™å‡ºçš„å­—æ®µå¸ƒå±€è®¿é—®æ•°æ® å†…å®¹ æ„ä¹‰ TRACE_EVENT() å®šä¹‰ä¸€ä¸ª tracepoint çš„ç»“æ„ä½“æ ¼å¼ã€æ‰“å°æ ¼å¼ /sys/kernel/debug/tracing/events/*/format æè¿° tracepoint çš„å­—æ®µç»“æ„å’Œ printf æ ¼å¼ï¼Œä¾›å·¥å…·è§£æä½¿ç”¨ define_trace.h æŠŠ TRACE_EVENT å®å±•å¼€ä¸ºå‡½æ•°å®šä¹‰ï¼Œå¿…é¡»æ”¾åœ¨ #endif å¤–é¢ã€‚ CREATE_TRACE_POINTS å‘Šè¯‰ç¼–è¯‘å™¨åœ¨è¿™ä¸ª C æ–‡ä»¶ä¸­ç”Ÿæˆå‡½æ•°å®šä¹‰ï¼Œåªèƒ½æœ‰ä¸€ä¸ªæ–‡ä»¶è¿™æ ·å†™ tracepoint çš„ä½¿ç”¨ åªéœ€è°ƒç”¨ trace_xxx() å‡½æ•°å°±èƒ½åœ¨å†…æ ¸ä¸­è®°å½•äº‹ä»¶","link":"/post/Trace-use-1.html"},{"title":"Trace-use-2","text":"å¿«é€Ÿæ„å»º Trace å­ç³»ç»Ÿâ€œè®¤çŸ¥â€ 2 Using the TRACE_EVENT() macroï¼ˆpart 1ï¼‰ åœ¨ç¬¬ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬è§£é‡Šäº†åœ¨æ ¸å¿ƒå†…æ ¸ä¸­åˆ›å»ºè·Ÿè¸ªç‚¹çš„è¿‡ç¨‹ã€‚æœ¬æ–‡å°†ç»§ç»­ä»‹ç»ä½¿ç”¨ DECLARE_EVENT_CLASS()å®æ¥é™ä½è·Ÿè¸ªç‚¹å ç”¨ç©ºé—´çš„æŠ€å·§ã€‚æ­¤å¤–ï¼Œæœ¬æ–‡è¿˜ä»‹ç»äº†ç”¨äºæ„å»ºTP_STRUCT__entryå­—æ®µçš„å®ï¼Œå¹¶ è§£é‡Šäº† TP_printkè¾…åŠ©å‡½æ•°ã€‚ å¦‚æœä¸¤ä¸ªäº‹ä»¶å…·æœ‰ç›¸åŒçš„TP_PROTOã€TP_ARGSå’ŒTP_STRUCT__entry ï¼Œå°±åº”è¯¥æœ‰ä¸€ç§æ–¹æ³•è®©è¿™äº›äº‹ä»¶å…±äº«å®ƒä»¬ä½¿ç”¨çš„å‡½æ•°ã€‚è¿™å°±æ˜¯æ–°å®DECLARE_EVENT_CLASS()ï¼ˆæœ€åˆç§°ä¸ºTRACE_EVENT_TEMPLATE()ï¼‰å’ŒDEFINE_EVENT()çš„åŠ¨æœºã€‚ å†…æ ¸é‡Œå¾ˆå¤šè·Ÿè¸ªäº‹ä»¶ï¼ˆTRACE_EVENT()ï¼‰ç»“æ„å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œåªæ˜¯åå­—ä¸åŒè€Œå·²ã€‚ä¾‹å¦‚ï¼šsched_wakeupå’Œsched_wakeup_newã€‚DECLARE_EVENT_CLASS()ï¼ˆå£°æ˜ä¸€ä¸ªæ¨¡æ¿ï¼‰ï¼šå®ƒå®šä¹‰ä¸€å¥—â€œé€šç”¨æ¨¡æ¿â€â€”â€”å‚æ•°ã€ç»“æ„ä½“å¸ƒå±€ã€èµ‹å€¼é€»è¾‘ã€æ‰“å°æ ¼å¼éƒ½å†™å¥½ï¼Œä¾›å¤šä¸ªäº‹ä»¶å…±äº«ã€‚ ä¾‹å¦‚ï¼šDECLARE_EVENT_CLASS(sched_wakeup_template, â€¦)å¯å®šä¹‰ï¼š 1234567DEFINE_EVENT(sched_wakeup_template, sched_wakeup, TP_PROTO(struct task_struct *p), TP_ARGS(__perf_task(p)));DEFINE_EVENT(sched_wakeup_template, sched_wakeup_new, TP_PROTO(struct task_struct *p), TP_ARGS(__perf_task(p))); é¢„å¤„ç†å™¨preprocessorï¼šæ˜¯ C ç¼–è¯‘å™¨åœ¨çœŸæ­£ç¼–è¯‘ä»£ç å‰ï¼Œå…ˆå¹²çš„ä¸€äº›â€œæ–‡æœ¬æ›¿æ¢â€æ´»ï¼šå®ç³»ç»Ÿï¼Œå°±æ˜¯æŒ‡ä½ ç”¨ #define å†™çš„é‚£äº›â€œæ¨¡æ¿è§„åˆ™â€ï¼šDECLARE_EVENT_CLASS(sched_wakeup_template, TP_PROTO(struct task_struct *p), TP_ARGS(p), â€¦); DEFINE_EVENT(sched_wakeup_template, sched_wakeup, TP_PROTO(struct task_struct *p), // â† è¿™é‡Œ TP_ARGS(p)); // â† è¿™é‡ŒæŒ‡å‘çš„ä¸¤è¡Œï¼Œé¢„å¤„ç†å®å°±ä¼šé‡å¤å†™ï¼Œä¼ å…¥å‚æ•° TP_STRUCT__entryå®ç¬¬ä¸€ç¯‡æ–‡ç« æåˆ°äº†__fieldå’Œ__arrayå®ï¼Œå®ƒä»¬ç”¨äºåˆ›å»ºå­˜å‚¨åœ¨ç¯å½¢ç¼“å†²åŒºä¸­çš„äº‹ä»¶çš„ç»“æ„æ ¼å¼ã€‚__ field(type, item)å£°æ˜äº†ç»“æ„ä½“ä¸­ä¸€ä¸ªåä¸ºitemçš„å­—æ®µï¼Œå…¶ç±»å‹ä¸º type ï¼ˆ å³type item;ï¼‰ã€‚__ array(type, item, len)å£°æ˜äº†ä¸€ä¸ªåä¸ºitemçš„é™æ€æ•°ç»„ï¼Œ å…¶å…ƒç´ ä¸ªæ•°ä¸º len ï¼ˆå³type item[len];ï¼‰ã€‚è¿™ä¸¤ä¸ªå®æœ€ä¸ºå¸¸è§ï¼Œä½†è¿˜æœ‰å…¶ä»–å®å…è®¸å°†äº‹ä»¶å­˜å‚¨åˆ°ç¯å½¢ç¼“å†²åŒºä¸­ï¼Œå®ç°æ›´å¤æ‚çš„æ“ä½œã€‚ 123456789101112131415161718// æ™®é€šå­—æ®µ__field(type, name)__field_ext(type, name, filter_type)// åŠ¨æ€æ•°æ®å­—æ®µ__string(name, src) // å¯å˜é•¿å­—ç¬¦ä¸²__dynamic_array(type, name, len) // ä»»æ„åŠ¨æ€æ•°ç»„// æ•°æ®èµ‹å€¼__assign_str(name, src)memcpy(__get_dynamic_array(name), src, len)// æ‰“å°è¾“å‡º__get_str(name)__get_dynamic_array(name)__print_flags(val, delim, {mask, name}...) // ä½æ©ç æ‰“å°__print_symbolic(val, {value, name}...) // æšä¸¾å€¼æ‰“å° 1234567891011121314151617â—† å¯ç”¨ / å…³é—­ echo 1 &gt; events/&lt;sub&gt;/&lt;event&gt;/enable # å¼€å¯å•ä¸ª echo 0 &gt; events/enable # å…³é—­æ‰€æœ‰ echo e1 e2 e3 &gt; set_event # æ‰¹é‡å¼€å¯ e1,e2,e3â—† è·Ÿè¸ªè¾“å‡º cat trace # ç›´æ¥è¯» trace-cmd record / report # æ›´çµæ´»ã€æ”¯æŒä¿å­˜æ–‡ä»¶ perf record -e &lt;sub&gt;:&lt;event&gt; # perf ä¹Ÿèƒ½æ”¶â—† äº‹ä»¶å¤´æ–‡ä»¶å…³é”®å® __field(type, name) # å›ºå®šå­—æ®µ __string(name, src) / __assign_str ... # åŠ¨æ€å­—ç¬¦ä¸² __dynamic_array(type, name, len) # ä»»æ„å¯å˜æ•°ç»„ __get_str(name) / __get_dynamic_array(name)# è®¿é—®å¯å˜æ•°æ® __print_flags(val, delim, {mask,&quot;name&quot;},â€¦) # ä½æ©ç å‹å¥½æ‰“å° __print_symbolic(val, {value,&quot;name&quot;},â€¦) # æšä¸¾å€¼æ‰“å°","link":"/post/Trace-use-2.html"},{"title":"qspinlock","text":"qspinlock is a hybrid spinlock combining the fairness of ticket locks with the scalability of MCS locks: it uses only 4 bytes under low contention, falls back to an MCS queue under heavy load, and optimizes the second contender with a pending bit. It improves fairness and scalability but should not be enabled on RISC-V platforms lacking Ziccrse or Zabha. 1. ä¼ ç»Ÿspinlockï¼š å¤šä¸ªç­‰å¾…çš„ CPU æ ¸å¿ƒä¸­ï¼Œè°å…ˆè·å¾—é”å¹¶æ— ä¿è¯ï¼Œå­˜åœ¨å…¬å¹³æ€§é—®é¢˜ï¼ŒåŒæ—¶ç¼“å­˜ä¸€è‡´æ€§å¼€é”€å¤§ï¼ˆå¦‚MESIï¼‰ï¼ŒCPUæ ¸å¿ƒè¶Šå¤§ï¼Œcacheéœ€æ±‚è¶Šå‰å®³ï¼Œç¼ºä¹å¯æ‰©å±•æ€§ 2. Ticket spinlock1234567891011121314151617#define TICKET_NEXT 16typedef struct { union { u32 lock; struct __raw_tickets { /* little endian */ u16 owner; u16 next; } tickets; };} arch_spinlock_t;my_ticket = atomic_fetch_inc(&amp;lock-&gt;tickets.next); while (lock-&gt;tickets.owner != my_ticket) cpu_relax(); è§£å†³äº†å…¬å¹³é—®é¢˜ï¼Œé˜²æ­¢æŸäº› CPU æ°¸è¿œå¾—ä¸åˆ°é”ï¼Œä½†æ‰€æœ‰æ ¸éƒ½è½®è¯¢åŒä¸€ä¸ªownerå˜é‡ï¼Œread cache lineæˆçƒ­ç‚¹ï¼Œé™åˆ¶æ‰©å±•æ€§ 3. MCS lock æœ¬è´¨ä¸Šæ˜¯ä¸€ç§åŸºäºé“¾è¡¨ç»“æ„çš„è‡ªæ—‹é”ï¼Œæ¯ä¸ªCPUæœ‰ä¸€ä¸ªå¯¹åº”çš„èŠ‚ç‚¹(é”çš„å‰¯æœ¬)ï¼ŒåŸºäºå„è‡ªä¸åŒçš„å‰¯æœ¬å˜é‡è¿›è¡Œç­‰å¾…ï¼Œé”æœ¬èº«æ˜¯å…±äº«çš„ï¼Œä½†é˜Ÿåˆ—èŠ‚ç‚¹æ˜¯çº¿ç¨‹è‡ªå·±ç»´æŠ¤çš„ï¼Œæ¯ä¸ªCPUåªéœ€è¦æŸ¥è¯¢è‡ªå·±å¯¹åº”çš„æœ¬åœ°cache lineï¼Œä»…åœ¨è¿™ä¸ªå˜é‡å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œæ‰éœ€è¦è¯»å–å†…å­˜å’Œåˆ·æ–°è¿™æ¡cache line, ä¸åƒ classic/ticketå¯¹å…±äº«å˜é‡è¿›è¡Œspin 123456789101112131415161718192021222324struct mcs_spinlock { struct mcs_spinlock *next; int locked; /* 1 if lock acquired */ int count; /* nesting count, see qspinlock.c */};static inlinevoid mcs_spin_lock(struct mcs_spinlock **lock, struct mcs_spinlock *node){ struct mcs_spinlock *prev; /* Init node */ node-&gt;locked = 0; node-&gt;next = NULL; prev = xchg(lock, node); if (likely(prev == NULL)) { return; } WRITE_ONCE(prev-&gt;next, node); /* Wait until the lock holder passes the lock down. */ arch_mcs_spin_lock_contended(&amp;node-&gt;locked);} æ¯ä¸ª CPU çº¿ç¨‹åˆ›å»ºçš„node æ˜¯ç‹¬ç«‹çš„ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„ node å®ä¾‹ã€‚ä½†æ˜¯ç»“æ„ä½“ä¸­å¤šäº†ä¸€ä¸ªæŒ‡é’ˆä½¿ç»“æ„ä½“å˜å¤§äº†ï¼Œå¯¼è‡´äº†â€œå†…å­˜å¼€é”€é—®é¢˜â€ï¼šMCS é”æŠŠç«äº‰å¸¦æ¥çš„ cache-line æŠ–åŠ¨é™ä½äº†ï¼Œä½†ç‰ºç‰²äº†ä¸€äº›å†…å­˜å’Œéƒ¨åˆ†ç»“æ„ç®¡ç†çš„æˆæœ¬ã€‚ 4. qspinlockinclude/asm-generic/qspinlock_types.h: é”æ•°æ®ç»“æ„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758typedef struct qspinlock { union { atomic_t val; /* * By using the whole 2nd least significant byte for the * pending bit, we can allow better optimization of the lock * acquisition for the pending bit holder. */#ifdef __LITTLE_ENDIAN struct { u8 locked; u8 pending; }; struct { u16 locked_pending; u16 tail; };#else struct { u16 tail; u16 locked_pending; }; struct { u8 reserved[2]; u8 pending; u8 locked; };#endif };} arch_spinlock_t;/* * Initializier */#define __ARCH_SPIN_LOCK_UNLOCKED { { .val = ATOMIC_INIT(0) } }/* * Bitfields in the atomic value: * * When NR_CPUS &lt; 16K * 0- 7: locked byte * 8: pending * 9-15: not used * 16-17: tail index * 18-31: tail cpu (+1) * * When NR_CPUS &gt; = 16K * 0- 7: locked byte * 8: pending * 9-10: tail index * 11-31: tail cpu (+1) */#define _Q_SET_MASK(type) (((1U &lt;&lt; _Q_ ## type ## _BITS) - 1)\\ &lt;&lt; _Q_ ## type ## _OFFSET)#define _Q_LOCKED_OFFSET 0#define _Q_LOCKED_BITS 8#define _Q_LOCKED_MASK _Q_SET_MASK(LOCKED) When NR_CPUS &lt; 16Kï¼š lockedï¼šç”¨æ¥è¡¨ç¤ºè¿™ä¸ªé”æ˜¯å¦è¢«äººæŒæœ‰ï¼ˆ0ï¼šæ— ï¼Œ1ï¼šæœ‰ï¼‰ pendingï¼šå¯ä»¥ç†è§£ä¸ºæœ€ä¼˜å…ˆæŒé”ä½ï¼Œå³å½“unlockä¹‹ååªæœ‰è¿™ä¸ªä½çš„CPUæœ€å…ˆæŒé”ï¼Œä¹Ÿæœ‰1å’Œ0 tailï¼šæœ‰idx+CPUæ„æˆï¼Œç”¨æ¥æ ‡è¯†ç­‰å¾…é˜Ÿåˆ—çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚ tail_idxï¼šå°±æ˜¯indexï¼Œå®ƒä½œä¸ºmcs_nodesæ•°ç»„çš„ä¸‹æ ‡ä½¿ç”¨ tail_CPUï¼šç”¨æ¥è¡¨ç¤ºCPUçš„ç¼–å·+1ï¼Œ+1å› ä¸ºè§„å®štailä¸º0çš„æ—¶å€™è¡¨ç¤ºç­‰å¾…é˜Ÿåˆ—ä¸­æ²¡æœ‰æˆå‘˜ kernel/locking/mcs_spinlock.h 12345struct mcs_spinlock { struct mcs_spinlock *next; int locked; /* 1 if lock acquired */ int count; /* nesting count, see qspinlock.c */}; locked = 1:åªæ˜¯è¯´é”ä¼ åˆ°äº†å½“å‰åŠ èŠ‚ç‚¹ï¼Œä½†æ˜¯å½“å‰èŠ‚ç‚¹è¿˜éœ€è¦ä¸»åŠ¨ç”³è¯·é”(qspinlock -&gt; locked = 1)countï¼šé’ˆå¯¹å››ç§ä¸Šä¸‹æ–‡ç”¨äºè¿½è¸ªå½“å‰ç”¨äº†ç¬¬å‡ ä¸ª nodeï¼ˆå³ idxï¼‰ï¼Œæœ€å¤§ä¸º4,ä¸å¤Ÿç”¨æ—¶å°±fallbackä¸æ’é˜Ÿç›´æ¥è‡ªæ—‹ kernel/locking/qspinlock.c: 123456789101112131415161718#define MAX_NODES 4struct qnode { struct mcs_spinlock mcs;#ifdef CONFIG_PARAVIRT_SPINLOCKS long reserved[2];#endif};/* * Per-CPU queue node structures; we can never have more than 4 nested * contexts: task, softirq, hardirq, nmi. * * Exactly fits one 64-byte cacheline on a 64-bit architecture. * * PV doubles the storage and uses the second cacheline for PV state. */static DEFINE_PER_CPU_ALIGNED(struct qnode, qnodes[MAX_NODES]); ä¸€ä¸ª CPU ä¸Šå¯èƒ½åµŒå¥—å¤šä¸ªé”, qnodesé’ˆå¯¹å››ç§ä¸Šä¸‹æ–‡æƒ…å†µä¸‹ï¼Œä¾‹ï¼šè¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­å‘ç”Ÿä¸­æ–­åå†æ¬¡è·å–é” PER_CPUçš„ä¼˜ç‚¹æ˜¯å¿«ï¼Œå¯é˜²æ­¢æŠ¢é”æ—¶å†mallockæˆ–ä¸´æ—¶åˆ†é…å¯¼è‡´å»¶è¿Ÿï¼Œæˆæœ¬ç­‰é—®é¢˜ ç”³è¯·é”ï¼š å¿«é€Ÿç”³è¯·include/asm-generic/qspinlock.h 12345678910111213/** * queued_spin_lock - acquire a queued spinlock * @lock: Pointer to queued spinlock structure */static __always_inline void queued_spin_lock(struct qspinlock *lock){ int val = 0; if (likely(atomic_try_cmpxchg_acquire(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL))) return; queued_spin_lock_slowpath(lock, val);} ä¸­é€Ÿç”³è¯· å¿«é€Ÿç”³è¯·å¤±è´¥ï¼Œqueueä¸­ä¸ºç©ºæ—¶ï¼Œè®¾ç½®é”çš„pendingä½ å†æ¬¡æ£€æµ‹ï¼ˆæ£€æŸ¥ä¸­é—´æ˜¯å¦æœ‰å…¶å®ƒcpuè¿›å…¥ï¼‰ ä¸€ç›´å¾ªç¯æ£€æµ‹lockedä½ å½“lockedä½ä¸º0æ—¶ï¼Œæ¸…é™¤pendingä½è·å¾—é” æ…¢é€Ÿç”³è¯· ç”³è¯· æ“ä½œ å¿«é€Ÿç”³è¯· è¿™ä¸ªé”å½“å‰æ²¡æœ‰äººæŒæœ‰ï¼Œç›´æ¥é€šè¿‡cmpxchg()è®¾ç½®lockedåŸŸå³å¯è·å–äº†é” ä¸­é€Ÿç”³è¯· é”å·²ç»è¢«äººæŒæœ‰ï¼Œä½†æ˜¯MCSé“¾è¡¨æ²¡æœ‰å…¶ä»–äººï¼Œæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªäººåœ¨ç­‰å¾…è¿™ä¸ªé”ã€‚è®¾ç½®pendingåŸŸï¼Œè¡¨ç¤ºæ˜¯ç¬¬ä¸€é¡ºä½ç»§æ‰¿è€…ï¼Œè‡ªæ—‹ç­‰å¾…lock-&gt; lockedæ¸…0ï¼Œå³é”æŒæœ‰è€…é‡Šæ”¾é” æ…¢é€Ÿç”³è¯· è¿›å…¥åˆ°queueä¸­è‡ªæ—‹ç­‰å¾…ï¼Œè‹¥ä¸ºé˜Ÿåˆ—å¤´ï¼ˆé˜Ÿåˆ—ä¸­æ²¡æœ‰ç­‰å¾…çš„cpuï¼‰ï¼Œè¯´æ˜å®ƒå·²æ’åˆ°æœ€å‰ï¼Œå¯ä»¥å¼€å§‹å°è¯•è·å–é”ï¼›å¦åˆ™ï¼Œå®ƒä¼šè‡ªæ—‹ç­‰å¾…å‰ä¸€ä¸ªèŠ‚ç‚¹é‡Šæ”¾é”ï¼Œå¹¶é€šçŸ¥å®ƒå¯ä»¥å°è¯•è·å–é”äº† end: å¦‚æœåªæœ‰1ä¸ªæˆ–2ä¸ªCPUè¯•å›¾è·å–é”ï¼Œé‚£ä¹ˆåªéœ€è¦ä¸€ä¸ª4å­—èŠ‚çš„qspinlockå°±å¯ä»¥äº†ï¼Œå…¶æ‰€å å†…å­˜çš„å¤§å°å’Œticket spinlockä¸€æ ·ã€‚å½“æœ‰3ä¸ªä»¥ä¸Šçš„CPUè¯•å›¾è·å–é”ï¼Œåˆ™éœ€è¦(N-2)ä¸ªMCS node qspinlockä¸­åŠ å…¥â€pendingâ€ä½åŸŸçš„æ„ä¹‰ï¼Œå¦‚æœæ˜¯ä¸¤ä¸ªCPUè¯•å›¾è·å–é”ï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªCPUåªéœ€è¦ç®€å•åœ°è®¾ç½®â€pendingâ€ä¸º1ï¼Œè€Œä¸ç”¨åˆ›å»ºä¸€ä¸ªMCS node è¯•å›¾åŠ é”çš„CPUæ•°ç›®è¶…è¿‡3ä¸ªï¼Œä½¿ç”¨ticket spinlockæœºåˆ¶å°±ä¼šé€ æˆå¤šä¸ªCPUçš„cache lineåˆ·æ–°çš„é—®é¢˜ï¼Œè€Œqspinlockå¯ä»¥åˆ©ç”¨MCS nodeé˜Ÿåˆ—æ¥è§£å†³è¿™ä¸ªé—®é¢˜ åœ¨å¤šæ ¸äº‰ç”¨ä¸¥é‡åœºæ™¯ä¸‹ï¼Œqspinlock è®©ç­‰å¾…è€…åœ¨æœ¬åœ°å†…å­˜åŒºåŸŸè‡ªæ—‹ï¼Œå‡å°‘äº†é”çš„ç¼“å­˜æŠ–åŠ¨å’Œå¯¹æ€»çº¿çš„ç«äº‰æ¶ˆè€— RISCV_QUEUED_SPINLOCKS åªåº”åœ¨å¹³å°å…·æœ‰ Zabha æˆ– Ziccrse æ—¶å¯ç”¨ï¼Œä¸æ”¯æŒçš„æƒ…å†µä¸è¦é€‰ç”¨ ä¼˜å…ˆçº§åè½¬é—®é¢˜ï¼Œqueueä¼šä¿è¯äº†FIFOæé«˜äº†å…¬å¹³æ€§ï¼Œä½†å®ƒæ— æ³•æ„ŸçŸ¥ä»»åŠ¡çš„ä¼˜å…ˆçº§ï¼Œå¯èƒ½å› ä¸ºæ’åœ¨é˜Ÿåˆ—å‰æ–¹çš„ä½ä¼˜å…ˆçº§ä»»åŠ¡æœªé‡Šæ”¾é”è€Œå‘ç”Ÿç­‰å¾…ï¼Œä»è€Œå¯¼è‡´ ä¼˜å…ˆçº§åè½¬","link":"/post/qspinlock.html"},{"title":"hexoåšå®¢æ­å»º","text":"ä½¿ç”¨hexoå’ŒGitHub Pagteséƒ¨ç½²ä¸€ä¸ªè‡ªå·±çš„åšå®¢ 1. å®‰è£…å¹¶åˆå§‹åŒ–Hexo å®‰è£… Hexo CLI 1npm install -g hexo-cli åˆå§‹åŒ–åšå®¢é¡¹ç›®ç›®å½• 123mkdir my-blog &amp;&amp; cd my-bloghexo initnpm install æœ¬åœ°é¢„è§ˆ 1hexo server å¯åŠ¨æœ¬åœ°æœåŠ¡ï¼šåœ¨æµè§ˆå™¨è®¿é—® http://localhost:4000 æŸ¥çœ‹æ•ˆæœ 2. é…ç½® GitHub Pages éƒ¨ç½² åˆ›å»ºGitHubä»“åº“ åˆ›å»ºä¸€ä¸ªä»“åº“ï¼Œåå­—å« ä½ çš„GitHubç”¨æˆ·å.github.io æ¯”å¦‚ä½ æ˜¯ gokoï¼Œå°±å« goko.github.io å®‰è£…éƒ¨ç½²æ’ä»¶ 1npm install hexo-deployer-git --save ä¿®æ”¹ _config.ymlï¼ˆæ ¹ç›®å½•ä¸‹ï¼‰æ·»åŠ éƒ¨ç½²é…ç½®ï¼š 12345deploy: type: git # repoå»ºè®®ä½¿ç”¨SSH, SSHå…å¯† repo: https://github.com/ä½ çš„GitHubç”¨æˆ·å/ä½ çš„GitHubç”¨æˆ·å.github.io.git branch: main # æˆ–è€… masterï¼Œçœ‹ä½ çš„é»˜è®¤åˆ†æ”¯ ç”Ÿæˆå¹¶éƒ¨ç½²åšå®¢ 123hexo cleanhexo generatehexo deploy 3. åŸŸå(.com)ç»‘å®š æ·»åŠ åŸŸå(åœ¨my-blogä¸‹) 123echo &quot;&lt;xxxx&gt;.com&quot; &gt; source/CNAME# æˆ–è€…å¯ä»¥ï¼šecho &quot;www.&lt;xxxx&gt;.com&quot; &gt; source/CNAME# åªèƒ½æ·»åŠ ä¸€ä¸ªï¼Œè€Œä¸”ä¸¤ä¸ªéœ€è¦æ·»åŠ ä¸åŒçš„åŸŸåè§£æï¼ˆå¦‚ä¸‹ï¼‰ é‡æ–°éƒ¨ç½² 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d è®¾ç½® DNS è§£ææŒ‡å‘ GitHub Pages A. ä½¿ç”¨è£¸åŸŸåï¼ˆapex åŸŸåï¼‰goku72.com è®°å½•ç±»å‹ ä¸»æœºè®°å½• è®°å½•å€¼ è¯´æ˜ A @ 185.199.108.153 GitHub Pages IP A @ 185.199.109.153 GitHub Pages IP A @ 185.199.110.153 GitHub Pages IP A @ 185.199.111.153 GitHub Pages IP example aliyun: é€‰æ‹©ä¸šåŠ¡éœ€æ±‚: å°†ç½‘ç«™åŸŸåè§£æåˆ°æœåŠ¡å™¨IPv4åœ°å€ é€‰æ‹©ç½‘ç«™åŸŸå(ä¸»æœºè®°å½•): .comï¼ˆå¯¹åº”è®¾ç½®â€œ@â€ä¸»æœºè®°å½•ï¼‰ å¡«å†™ IPï¼ˆè®°å½•å€¼ï¼‰ï¼š åœ¨è¾“å…¥æ¡†é‡Œç²˜è´´ä»¥ä¸‹å››è¡Œï¼ˆæ¯ä¸€è¡Œä¸€ä¸ª IPï¼‰ï¼š &gt; 185.199.109.153 &gt; 185.199.108.153 &gt; 185.199.110.153 &gt; 185.199.111.153 B. ä½¿ç”¨ www.goku72.com ä½œä¸ºä¸»åŸŸå è®°å½•ç±»å‹ ä¸»æœºè®°å½• è®°å½•å€¼ è¯´æ˜ CNAME www &lt;githubç”¨æˆ·å&gt;.github.io. æŒ‡å‘ä½ çš„ GitHub ç”¨æˆ·é¡µä»“åº“ example aliyun: é€‰æ‹©ä¸šåŠ¡éœ€æ±‚: å°†ç½‘ç«™åŸŸåè§£æåˆ°å¦å¤–çš„ç›®æ ‡åŸŸå é€‰æ‹©ç½‘ç«™åŸŸå(ä¸»æœºè®°å½•): www..comï¼ˆå¯¹åº”è®¾ç½®â€œwwwâ€ä¸»æœºè®°å½•ï¼‰ å¡«å†™ IPï¼ˆè®°å½•å€¼ï¼‰ï¼š&lt;githubç”¨æˆ·å&gt;.github.io. (æœ€æœ‰æœ‰ä¸€ä¸ªç¬¦å·â€.â€) 4. è®¾ç½®ä¸»é¢˜ cd my-blog/themes git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git butterfly ä¿®æ”¹_config.yml: theme: butterfly hexo clean &amp;&amp; hexo g &amp;&amp; hexo d æ›´å¤šä¸»é¢˜ï¼šhttps://hexo.io/themes/ æ³¨ï¼š å¦‚æœABä¸¤ä¸ªæ–¹å¼éƒ½æ·»åŠ äº†ï¼Œåªéœ€è¦åœ¨ Hexo é¡¹ç›®çš„ source/CNAME æ–‡ä»¶ä¸­å†™ www..comï¼ŒGitHub Pages å°±ä¼šè‡ªåŠ¨æŠŠ goku72.com é‡å®šå‘è¿‡å»ï¼Œæ— éœ€é¢å¤–è®¾ç½®ï¼ åç»­æ¢åŸŸååªéœ€è¦ï¼šé˜¿é‡Œäº‘é‡æ–°è§£æ + ä¿®æ”¹ source/CNAME + é‡æ–°éƒ¨ç½² Hexoï¼Œå°±èƒ½å®ŒæˆåŸŸåè¿ç§»ã€‚ æœ‰äº›ä¸»é¢˜å¯èƒ½éœ€è¦ä¸‹è½½æ’ä»¶","link":"/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html"},{"title":"riscv-toolchains","text":"riscv-toolchainä»‹ç» GNU å·¥å…·é“¾çš„ä¸‰å…ƒç»„ï¼ˆtripletï¼‰ï¼Œæ ¼å¼æ˜¯ï¼š 1&lt;ç›®æ ‡æ¶æ„&gt;-&lt;ä¾›åº”å•†&gt;-&lt;ç›®æ ‡ç³»ç»Ÿ&gt; riscv64-unknown-elf-ï¼š é€‚ç”¨äº riscv64 æ¶æ„ã€é¢å‘åµŒå…¥å¼/è£¸æœºå¹³å°ï¼ˆä½¿ç”¨ newlib æ ‡å‡†åº“ï¼‰çš„å·¥å…·é“¾ã€‚ å¯ä» riscv-collab/riscv-gnu-toolchain æ„å»ºã€‚ ä¸æ¨èé€šè¿‡åŒ…ç®¡ç†å·¥å…·å®‰è£…æ­¤ç¼–è¯‘é“¾ã€‚å‘è¡Œç‰ˆè½¯ä»¶æºä¸­çš„æ­¤å·¥å…·é“¾å¸¸å¸¸ç¼ºå°‘å…³é”®çš„ newlib æ ‡å‡†åº“ã€‚riscv64-unknown-linux-gnu-ï¼š é€‚ç”¨äº riscv64 æ¶æ„ã€é¢å‘ linux-gnu å¹³å°ï¼ˆä½¿ç”¨ glibc æ ‡å‡†åº“ï¼‰çš„å·¥å…·é“¾ï¼Œå¯ä»¥ä¸riscv64-linux-gnu- ç›¸äº’æ›¿æ¢ã€‚å¯ä» riscv-collab/riscv-gnu-toolchain æ„å»ºã€‚riscv64-linux-gnu-ï¼š é€‚ç”¨äº riscv64 æ¶æ„ã€é¢å‘ linux-gnu å¹³å°ï¼ˆä½¿ç”¨ glibc æ ‡å‡†åº“ï¼‰çš„å·¥å…·é“¾ã€‚ å¯é€šè¿‡åŒ…ç®¡ç†å·¥å…·ï¼ˆå¦‚ Ubuntu çš„ aptï¼‰å®‰è£…ã€‚å—é™äºå‘è¡Œç‰ˆè½¯ä»¶æºé™åˆ¶ï¼Œå…¶ç¼–è¯‘å™¨ç‰ˆæœ¬å¯èƒ½è¾ƒè€ã€‚","link":"/post/riscv-toolchains.html"},{"title":"xv6-riscv-ch1","text":"This chapter-1 introduces the basic Unix process, file, and I/O abstractions that applications use to interact with the OS. ch1: Operating system interfaces As Figure 1.1 shows, xv6 takes the traditional form of a kernel, a special program that providesservices to running programs. Each running program, called a process, has memory containinginstructions, data, and a stack. The instructions implement the programâ€™s computation. The dataare the variables on which the computation acts. The stack organizes the programâ€™s procedure calls.A given computer typically has many processes but only a single kernel. When a user program invokes a sys-tem call, the hardware raises the privilege level and starts executing a pre-arranged function in thekernel.The collection of system calls that a kernel provides is the interface that user programs see. Thexv6 kernel provides a subset of the services and system calls that Unix kernels traditionally offer.Figure 1.2 lists all of xv6â€™s system calls. The shell is an ordinary program that reads commands from the user and executes them. Thefact that the shell is a user program, and not part of the kernel, illustrates the power of the systemcall interface: there is nothing special about the shell. It also means that the shell is easy to replace;as a result, modern Unix systems have a variety of shells to choose from, each with its own userinterface and scripting features. The xv6 shell is a simple implementation of the essence of theUnix Bourne shell. Its implementation can be found at (user/sh.c:1).The xv6 shell uses the exec calls of blew to run programs on behalf of users. The main structure ofthe shell is simple; see main (user/sh.c:146). The main loop reads a line of input from the user withgetcmd. Then it calls fork, which creates a copy of the shell process. The parent calls wait,while the child runs the command. For example, if the user had typed â€œecho helloâ€ to the shell,runcmd would have been called with â€œecho helloâ€ as the argument. runcmd (user/sh.c:55) runsthe actual command. For â€œecho helloâ€, it would call exec (user/sh.c:79). If exec succeeds thenthe child will execute instructions from echo instead of runcmd. At some point echo will callexit, which will cause the parent to return from wait in main (user/sh.c:146). 1.1 Processes and memory An xv6 process consists of user-space memory (instructions, data, and stack) and per-process stateprivate to the kernel. Xv6 time-shares processes: it transparently switches the available CPUsamong the set of processes waiting to execute. When a process is not executing, xv6 saves theprocessâ€™s CPU registers, restoring them when it next runs the process. The kernel associates aprocess identifier, or PID, with each process. the following program fragment written in the C programming lan-guage 1234567891011int pid = fork();if(pid &gt; 0){printf(&quot;parent: child=%d\\n&quot;, pid);pid = wait((int *) 0);printf(&quot;child %d is done\\n&quot;, pid);} else if(pid == 0){printf(&quot;child: exiting\\n&quot;);exit(0);} else {printf(&quot;fork error\\n&quot;);} In the example, the output linesparent: child=1234child: exitingmight come out in either order (or even intermixed), depending on whether the parent or child getsto its printf call first. After the child exits, the parentâ€™s wait returns, causing the parent to printparent: child 1234 is doneAlthough the child has the same memory contents as the parent initially, the parent and child areexecuting with separate memory and separate registers: changing a variable in one does not affectthe other. For example, when the return value of wait is stored into pid in the parent process, itdoesnâ€™t change the variable pid in the child. The value of pid in the child will still be zero. The exec system call replaces the calling processâ€™s memory with a new memory image loadedfrom a file stored in the file system. The file must have a particular format, which specifies whichpart of the file holds instructions, which part is data, at which instruction to start, etc. Xv6 uses theELF format, which Chapter 3 discusses in more detail. Usually the file is the result of compilinga programâ€™s source code. When exec succeeds, it does not return to the calling program; instead,the instructions loaded from the file start executing at the entry point declared in the ELF header.exec takes two arguments: the name of the file containing the executable and an array of stringarguments. For example 123456char *argv[3];argv[0] = &quot;echo&quot;;argv[1] = &quot;hello&quot;;argv[2] = 0;exec(&quot;/bin/echo&quot;, argv);printf(&quot;exec error\\n&quot;); This fragment replaces the calling program with an instance of the program /bin/echo runningwith the argument list echo hello. Most programs ignore the first element of the argument array,which is conventionally the name of the program. why fork and exec are not combined in a single callwe will see later thatthe shell exploits the separation in its implementation of I/O redirection.Xv6 allocates most user-space memory implicitly: fork allocates the memory required for thechildâ€™s copy of the parentâ€™s memory, and exec allocates enough memory to hold the executablefile. A process that needs more memory at run-time (perhaps for malloc) can call sbrk(n) togrow its data memory by n zero bytes; sbrk returns the location of the new memory. 1.2 I/O and File descriptors A file descriptor is a small integer representing a kernel-managed object that a process may readfrom or write to. A process may obtain a file descriptor by opening a file, directory, or device,or by creating a pipe, or by duplicating an existing descriptor. For simplicity weâ€™ll often referto the object a file descriptor refers to as a â€œfileâ€; the file descriptor interface abstracts away thedifferences between files, pipes, and devices, making them all look like streams of bytes. Weâ€™llrefer to input and output as I/O. Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so thatevery process has a private space of file descriptors starting at zero. By convention, a process readsfrom file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), andwrites error messages to file descriptor 2 (standard error). As we will see, the shell exploits theconvention to implement I/O redirection and pipelines. The shell ensures that it always has threefile descriptors open (user/sh.c:152), which are by default file descriptors for the console. The following program fragment (which forms the essence of the program cat) copies datafrom its standard input to its standard output. If an error occurs, it writes a message to the standarderror. 123456789101112131415char buf[512];int n;for(;;){n = read(0, buf, sizeof buf);if(n == 0)break;if(n &lt; 0){fprintf(2, &quot;read error\\n&quot;);exit(1);}if(write(1, buf, n) != n){fprintf(2, &quot;write error\\n&quot;);exit(1);}} The important thing to note in the code fragment is that cat doesnâ€™t know whether it is readingfrom a file, console, or a pipe. Similarly cat doesnâ€™t know whether it is printing to a console, afile, or whatever. The use of file descriptors and the convention that file descriptor 0 is input andfile descriptor 1 is output allows a simple implementation of cat. The close system call releases a file descriptor, making it free for reuse by a future open,pipe, or dup system call (see below). A newly allocated file descriptor is always the lowest-numbered unused descriptor of the current process. File descriptors and fork interact to make I/O redirection easy to implement. 12345678char *argv[2];argv[0] = &quot;cat&quot;;argv[1] = 0;if(fork() == 0) {close(0);open(&quot;input.txt&quot;, O_RDONLY);exec(&quot;cat&quot;, argv);} After the child closes file descriptor 0, open is guaranteed to use that file descriptor for the newlyopened input.txt: 0 will be the smallest available file descriptor. cat then executes with filedescriptor 0 (standard input) referring to input.txt. The parent processâ€™s file descriptors are notchanged by this sequence Two file descriptors share an offset if they were derived from the same original file descriptorby a sequence of fork and dup calls. Otherwise file descriptors do not share offsets, even if theyresulted from open calls for the same file. dup allows shells to implement commands like this: ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1. The 2&gt;&amp;1 tells the shell to give the command a file descriptor 2 that is a duplicate of descriptor 1. Both the name of the existing file and the error message for the non-existing file will show up in the file tmp1. The xv6 shell doesnâ€™t support I/O redirection for the error file descriptor, but now you know how to implement it. 1.3 Pipes A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for readingand one for writing. Writing data to one end of the pipe makes that data available for reading fromthe other end of the pipe. Pipes provide a way for processes to communicate. The following example code runs the program wc with standard input connected to the readend of a pipe. 12345678910111213141516int p[2];char *argv[2];argv[0] = &quot;wc&quot;;argv[1] = 0;pipe(p);if(fork() == 0) {close(0);dup(p[0]);close(p[0]);close(p[1]);exec(&quot;/bin/wc&quot;, argv);} else {close(p[0]);write(p[1], &quot;hello world\\n&quot;, 12);close(p[1]);} 12345678910 pipe [p[1]] -------&gt; [p[0]] (write) (read)parent: write(p[1], ...)child: dup(p[0]) -&gt; fd 0 exec(&quot;wc&quot;) -&gt; wc reads from stdin (=read of pipe) The fact that read blocks until it is impossible for new data to arriveis one reason that itâ€™s important for the child to close the write end of the pipe before executingwc above: if one of wc â€™s file descriptors referred to the write end of the pipe and not close, wc would never seeend-of-file. The xv6 shell implements pipelines such as grep fork sh.c | wc -l in a manner similarto the above code (user/sh.c:101). The child process creates a pipe to connect the left end of thepipeline with the right end. Then it calls fork and runcmd for the left end of the pipeline andfork and runcmd for the right end, and waits for both to finish. The right end of the pipelinemay be a command that itself includes a pipe (e.g., a | b | c), which itself forks two new childprocesses (one for b and one for c). Thus, the shell may create a tree of processes. The leaves16of this tree are commands and the interior nodes are processes that wait until the left and rightchildren complete. 12345 sh / \\a sh / \\ b c echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyzPipes have at least three advantages over temporary files in this situation. First, pipes automatically clean themselves up; with the file redirection, a shell would have to be careful to remove /tmp/xyz when done. Second, pipes can pass arbitrarily long streams of data, while file redirection requires enough free space on disk to store all the data. Third, pipes allow for parallel execution of pipeline stages, while the file approach requires the first program to finish before the second starts. 1.4 File system The xv6 file system provides data files, which contain uninterpreted byte arrays, and directories,which contain named references to data files and other directories. There are system calls to create new files and directories: mkdir creates a new directory, openwith the O_CREATE flag creates a new data file, and mknod creates a new device file. This exampleillustrates all three: 1234mkdir(&quot;/dir&quot;);fd = open(&quot;/dir/file&quot;, O_CREATE|O_WRONLY);close(fd);mknod(&quot;/console&quot;, 1, 1); mknod creates a special file that refers to a device. Associated with a device file are the major andminor device numbers (the two arguments to mknod), which uniquely identify a kernel device.When a process later opens a device file, the kernel diverts read and write system calls to thekernel device implementation instead of passing them to the file system. A fileâ€™s name is distinct from the file itself; the same underlying file, called an inode, can havemultiple names, called links. Each link consists of an entry in a directory; the entry contains a filename and a reference to an inode. An inode holds metadata about a file, including its type (file ordirectory or device), its length, the location of the fileâ€™s content on disk, and the number of links toa file. The fstat system call retrieves information from the inode that a file descriptor refers to. Itfills in a struct stat, defined in stat.h (kernel/stat.h) as: 1234567891011#define T_DIR 1// Directory#define T_FILE 2// File#define T_DEVICE 3// Devicestruct stat { int dev; // File systemâ€™s disk device uint ino; // Inode number short type; // Type of file short nlink; // Number of links to file uint64 size; // Size of file in bytes}; The link system call creates another file system name referring to the same inode as an exist-ing file. This fragment creates a new file named both a and b. 12open(&quot;a&quot;, O_CREATE|O_WRONLY);link(&quot;a&quot;, &quot;b&quot;); Reading from or writing to a is the same as reading from or writing to b. Each inode is identifiedby a unique inode number. After the code sequence above, it is possible to determine that a and brefer to the same underlying contents by inspecting the result of fstat: both will return the sameinode number (ino), and the nlink count will be set to 2.The unlink system call removes a name from the file The unlink system call removes a name from the file system. The fileâ€™s inode and the diskspace holding its content are only freed when the fileâ€™s link count is zero and no file descriptorsrefer to it. Thus adding 1unlink(&quot;a&quot;); to the last code sequence leaves the inode and file content accessible as b. Furthermore, 12fd = open(&quot;/tmp/xyz&quot;, O_CREATE|O_RDWR);unlink(&quot;/tmp/xyz&quot;); is an idiomatic way to create a temporary inode with no name that will be cleaned up when theprocess closes fd or exits. Unix provides file utilities callable from the shell as user-level programs, for example mkdir,ln, and rm. This design allows anyone to extend the command-line interface by adding new user-level programs. In hindsight this plan seems obvious, but other systems designed at the time ofUnix often built such commands into the shell (and built the shell into the kernel).One exception is cd, which is built into the shell (user/sh.c:161). cd must change the currentworking directory of the shell itself. If cd were run as a regular command, then the shell would18fork a child process, the child process would run cd, and cd would change the child â€™s workingdirectory. The parentâ€™s (i.e., the shellâ€™s) working directory would not change. 1.5 Real world the shell was the first so-called â€œscripting language.â€ The Unix system call interface persists today insystems like BSD, Linux, and macOS. The Unix system call interface has been standardized through the Portable Operating SystemInterface (POSIX) standard. Xv6 is not POSIX compliant: it is missing many system calls (in-cluding basic ones such as lseek), and many of the system calls it does provide differ from thestandard. Our main goals for xv6 are simplicity and clarity while providing a simple UNIX-likesystem-call interface. Several people have extended xv6 with a few more system calls and a sim-ple C library in order to run basic Unix programs. Modern kernels, however, provide many moresystem calls, and many more kinds of kernel services, than xv6. For example, they support net-working, windowing systems, user-level threads, drivers for many devices, and so on. Modernkernels evolve continuously and rapidly, and offer many features beyond POSIX. Xv6 does not provide a notion of users or of protecting one user from another; in Unix terms,all xv6 processes run as root. commentsï¼š Linux tries to adhere to POSIX (glibc provides most of the POSIX interfaces), but has its own extensions (e.g., epoll). Programmers who write POSIX interfaces can compile and run them on macOS, BSD, and Linux (as long as they donâ€™t use platform-specific extensions). Think of the xv6 system call interface as a â€œsubset implementation of POSIX.â€ POSIXæ–‡æ¡£","link":"/post/xv6-riscv-ch1.html"},{"title":"IIC","text":"EEPROM(IIC) ROM(Read Only Memory): åˆ¶é€ å’Œå‡çº§ä¸ä¾¿ PROM(Programmable ROM): ä½†æ˜¯åªèƒ½å†™å…¥ä¸€æ¬¡ï¼Œåç»­æ— æ³•ä¿®æ”¹ EPROM(Erasable Programmable ROM): ç´«å¤–çº¿é€è¿‡ç»ç’ƒçª—å£ç…§å°„å†…éƒ¨èŠ¯ç‰‡å°±å¯ä»¥æ“¦é™¤å…¶å†…éƒ¨çš„æ•°æ® EEPROM: å¸¦ç”µå¯æ“¦é™¤å¯ç¼–ç¨‹åªè¯»å­˜å‚¨å™¨ï¼Œä»¥ç”µå­ä¿¡å·æ¥ä¿®æ”¹å…¶å†…å®¹ï¼Œå®ƒå±äºåŒç”µå‹èŠ¯ç‰‡ã€‚å€ŸåŠ©äºEEPROMèŠ¯ç‰‡çš„åŒç”µå‹ç‰¹æ€§ï¼Œå¯ä»¥ä½¿BIOSå…·æœ‰è‰¯å¥½çš„é˜²æ¯’åŠŸèƒ½ï¼Œåœ¨å‡çº§æ—¶ï¼ŒæŠŠè·³çº¿å¼€å…³æ‰“è‡³â€œonâ€çš„ä½ç½®ï¼Œå³ç»™èŠ¯ç‰‡åŠ ä¸Šç›¸åº”çš„ç¼–ç¨‹ç”µå‹ï¼Œå°±å¯ä»¥æ–¹ä¾¿åœ°å‡çº§ï¼›å¹³æ—¶ä½¿ç”¨æ—¶ï¼Œåˆ™æŠŠè·³çº¿å¼€å…³æ‰“è‡³â€œoffâ€çš„ä½ç½®ï¼Œé˜²æ­¢CIHç±»çš„ç—…æ¯’å¯¹BIOSèŠ¯ç‰‡çš„éæ³•ä¿®æ”¹ã€‚ è¯»å–IICè®¾å¤‡ï¼š æ§åˆ¶å™¨ è®¾å¤‡åœ°å€ï¼šæ ¹æ®èŠ¯ç‰‡æ‰‹å†Œå’Œæ¨¡å—åŸç†å›¾æŸ¥è¯¢æŸ¥æ‰¾IICè®¾å¤‡ï¼ši2cdetect -y 0/1/2â€¦ Platform æ€»çº¿ (Platform Bus): ç‰¹ç‚¹: è¿™æ˜¯ä¸€ç§è™šæ‹Ÿæ€»çº¿ï¼Œç”¨äºè¿æ¥é‚£äº›æ²¡æœ‰ç¡¬ä»¶æ€»çº¿ï¼ˆå¦‚PCIã€USBç­‰ï¼‰ä½†åˆéœ€è¦ä¸CPUç›´æ¥é€šä¿¡çš„è®¾å¤‡ã€‚è¿™äº›è®¾å¤‡é€šå¸¸æ˜¯SoCï¼ˆSystem on Chipï¼‰å†…éƒ¨çš„å„ç§æ§åˆ¶å™¨ï¼Œä¾‹å¦‚GPIOæ§åˆ¶å™¨ã€UARTã€SPIã€I2Cæ§åˆ¶å™¨æœ¬èº«ç­‰ç­‰ã€‚ ä½œç”¨: å®ƒæä¾›äº†ä¸€ç§ç»Ÿä¸€çš„æœºåˆ¶æ¥ç®¡ç†å’ŒæŠ½è±¡è¿™äº›ç‰‡ä¸Šè®¾å¤‡ï¼Œä½¿å¾—é©±åŠ¨å¼€å‘è€…ä¸éœ€è¦å…³å¿ƒå…·ä½“çš„ç¡¬ä»¶åœ°å€å’Œä¸­æ–­å·ï¼Œè€Œæ˜¯é€šè¿‡ Platform æ€»çº¿æä¾›çš„æ¥å£æ¥æ³¨å†Œå’Œæ“ä½œè®¾å¤‡ã€‚ åŸç†: Platform è®¾å¤‡å’Œ Platform é©±åŠ¨é€šè¿‡ platform_device å’Œ platform_driver ç»“æ„ä½“è¿›è¡Œæè¿°ã€‚å½“è®¾å¤‡å’Œé©±åŠ¨çš„åç§°åŒ¹é…æ—¶ï¼Œå†…æ ¸å°±ä¼šå°†å®ƒä»¬å…³è”èµ·æ¥ã€‚ åŒ¹é…è¿‡ç¨‹: é€šå¸¸æ˜¯åŸºäº name å­—æ®µçš„å­—ç¬¦ä¸²åŒ¹é…ã€‚platform_device ä¸­çš„ name å­—æ®µä¸ platform_driver ä¸­ driver.name å­—æ®µè¿›è¡Œæ¯”è¾ƒã€‚å¦‚æœåŒ¹é…æˆåŠŸï¼Œå°±ä¼šè°ƒç”¨é©±åŠ¨çš„ probe å‡½æ•°ã€‚ I2C æ€»çº¿ (I2C Bus): ç‰¹ç‚¹: I2C æ˜¯ä¸€ç§ä¸²è¡Œé€šä¿¡åè®®ï¼Œç”¨äºè¿æ¥ä½é€Ÿå¤–è®¾ï¼Œå¦‚ä¼ æ„Ÿå™¨ã€EEPROMã€å®æ—¶æ—¶é’Ÿ (RTC) ç­‰ã€‚åœ¨ Linux ä¸­ï¼ŒI2C æ€»çº¿ç®¡ç†ç€I2Cæ§åˆ¶å™¨å’ŒI2Cä»è®¾å¤‡ã€‚ ä½œç”¨: å®ƒä¸ºI2Cè®¾å¤‡æä¾›äº†ä¸€å¥—æ ‡å‡†çš„APIï¼Œä½¿å¾—é©±åŠ¨å¼€å‘è€…å¯ä»¥æ–¹ä¾¿åœ°è¯»å†™I2Cè®¾å¤‡å¯„å­˜å™¨ï¼Œè€Œæ— éœ€å…³å¿ƒI2Cåè®®çš„åº•å±‚ç»†èŠ‚ã€‚ åŸç†: I2C æ€»çº¿åŒ…å«I2Cé€‚é…å™¨ï¼ˆI2C Adapterï¼Œå³I2Cæ§åˆ¶å™¨ï¼‰å’ŒI2Cå®¢æˆ·ç«¯ï¼ˆI2C Clientï¼Œå³I2Cä»è®¾å¤‡ï¼‰ã€‚é€‚é…å™¨æä¾›I2Cé€šä¿¡èƒ½åŠ›ï¼Œå®¢æˆ·ç«¯åˆ™ä»£è¡¨å…·ä½“çš„I2Cè®¾å¤‡ã€‚ åŒ¹é…è¿‡ç¨‹: I2Cè®¾å¤‡çš„åŒ¹é…é€šå¸¸æœ‰ä¸¤ç§æ–¹å¼ï¼š åŸºäºåç§°åŒ¹é…: i2c_client ä¸­çš„ name å­—æ®µä¸ i2c_driver ä¸­çš„ id_table é‡Œçš„ name å­—æ®µè¿›è¡ŒåŒ¹é…ã€‚ åŸºäºcompatibleå­—ç¬¦ä¸²åŒ¹é… (æ›´å¸¸ç”¨å’Œæ¨è): i2c_client ä¸­çš„ of_node-&gt;compatible å±æ€§ä¸ i2c_driver ä¸­çš„ of_match_table é‡Œçš„ compatible å­—ç¬¦ä¸²è¿›è¡ŒåŒ¹é…ã€‚è¿™ç§æ–¹å¼å¸¸ç”¨äºè®¾å¤‡æ ‘ (Device Tree) ä¸­ã€‚ é™¤äº†è¿™ä¸¤è€…ï¼Œè¿˜æœ‰ï¼š PCI æ€»çº¿ (PCI Bus): ç”¨äºè¿æ¥é«˜æ€§èƒ½å¤–è®¾ï¼Œå¦‚æ˜¾å¡ã€ç½‘å¡ã€å£°å¡ç­‰ã€‚ USB æ€»çº¿ (USB Bus): ç”¨äºè¿æ¥å„ç§USBè®¾å¤‡ï¼Œå¦‚Uç›˜ã€é”®ç›˜ã€é¼ æ ‡ã€æ‘„åƒå¤´ç­‰ã€‚ SPI æ€»çº¿ (SPI Bus): å¦ä¸€ç§ä¸²è¡Œé€šä¿¡åè®®ï¼Œå¸¸ç”¨äºè¿æ¥ä¼ æ„Ÿå™¨ã€FLASHå­˜å‚¨å™¨ç­‰ã€‚ MMC/SD æ€»çº¿ (MMC/SD Bus): ç”¨äºè¿æ¥SDå¡ã€eMMCå­˜å‚¨å™¨ç­‰ã€‚ Input æ€»çº¿ (Input Bus): ç”¨äºç®¡ç†å„ç§è¾“å…¥è®¾å¤‡ï¼Œå¦‚é”®ç›˜ã€é¼ æ ‡ã€è§¦æ‘¸å±ç­‰ã€‚ ç­‰ç­‰â€¦ 2. å®ƒä»¬ä¹‹é—´æœ‰ä»€ä¹ˆåŒºåˆ«å’Œè”ç³»ï¼Ÿéƒ½æœ‰ä»€ä¹ˆç”¨ï¼ŸåŸç†æ˜¯ä»€ä¹ˆï¼ŸåŒºåˆ«ï¼š ç‰©ç†ç‰¹æ€§: I2C: æ˜¯ä¸€ç§ä¸²è¡Œé€šä¿¡åè®®ï¼Œæœ‰SDAï¼ˆæ•°æ®çº¿ï¼‰å’ŒSCLï¼ˆæ—¶é’Ÿçº¿ï¼‰ä¸¤æ ¹çº¿ã€‚ Platform: æ˜¯ä¸€ç§è™šæ‹Ÿæ€»çº¿ï¼Œæ²¡æœ‰å¯¹åº”çš„ç‰©ç†è¿æ¥çº¿ï¼Œå®ƒæŠ½è±¡çš„æ˜¯CPUå†…éƒ¨æˆ–ç›´æ¥è¿æ¥åˆ°CPUçš„è®¾å¤‡ã€‚ å…¶ä»–æ€»çº¿ (PCI, USBç­‰): éƒ½æœ‰å„è‡ªçš„ç‰©ç†è¿æ¥æ–¹å¼å’Œé€šä¿¡åè®®ã€‚ è®¾å¤‡ç±»å‹: I2C: ä¸“æ³¨äºä½é€Ÿå¤–è®¾ã€‚ Platform: ä¸“æ³¨äºSoCå†…éƒ¨æˆ–ç›´æ¥è¿æ¥çš„ç‰‡ä¸Šè®¾å¤‡ã€‚ PCI: ä¸“æ³¨äºé«˜æ€§èƒ½ã€é«˜å¸¦å®½è®¾å¤‡ã€‚ USB: ä¸“æ³¨äºå³æ’å³ç”¨ã€é€šç”¨æ€§å¼ºçš„è®¾å¤‡ã€‚ è”ç³»ï¼š ç»Ÿä¸€çš„è®¾å¤‡æ¨¡å‹: å°½ç®¡æœ‰å„ç§ä¸åŒçš„æ€»çº¿ï¼Œä½† Linux å†…æ ¸æä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„è®¾å¤‡æ¨¡å‹ (Device Model)ã€‚è¿™ä¸ªæ¨¡å‹çš„ç›®æ ‡æ˜¯å°†è®¾å¤‡å’Œé©±åŠ¨è¿›è¡Œåˆ†ç¦»ï¼Œå®ç°é€šç”¨åŒ–å’Œå¯ç§»æ¤æ€§ã€‚ Bus-Device-Driver æ¶æ„: æ‰€æœ‰çš„æ€»çº¿éƒ½éµå¾ª Bus-Device-Driver æ¶æ„ã€‚ Bus (æ€»çº¿): è´Ÿè´£ç®¡ç†å…¶ä¸Šçš„è®¾å¤‡å’Œé©±åŠ¨ï¼Œæä¾›åŒ¹é…æœºåˆ¶ã€‚ Device (è®¾å¤‡): ä»£è¡¨å…·ä½“çš„ç¡¬ä»¶è®¾å¤‡ï¼ŒåŒ…å«è®¾å¤‡çš„å„ç§ä¿¡æ¯ï¼ˆåœ°å€ã€ä¸­æ–­å·ã€åç§°ã€IDç­‰ï¼‰ã€‚ Driver (é©±åŠ¨): è´Ÿè´£ä¸ç‰¹å®šç±»å‹çš„è®¾å¤‡è¿›è¡Œäº¤äº’ï¼Œå®ç°è®¾å¤‡çš„å„ç§åŠŸèƒ½ã€‚ Client-Driver é€‚é…: ä½ è¯´çš„æ²¡é”™ï¼æ— è®ºæ˜¯ I2Cã€Platform è¿˜æ˜¯å…¶ä»–æ€»çº¿ï¼Œå®ƒä»¬çš„æ ¸å¿ƒéƒ½æ˜¯ Client (è®¾å¤‡) å’Œ Driver (é©±åŠ¨) è¿›è¡Œé€‚é…ã€‚è¿™é‡Œçš„ â€œClientâ€ å¯¹åº”äº â€œDeviceâ€ã€‚ éƒ½æœ‰ä»€ä¹ˆç”¨ï¼Ÿ æŠ½è±¡ç¡¬ä»¶å·®å¼‚: ä¸åŒçš„æ€»çº¿å±è”½äº†åº•å±‚ç¡¬ä»¶çš„å¤æ‚æ€§ï¼Œæä¾›ç»Ÿä¸€çš„ç¼–ç¨‹æ¥å£ã€‚ ä»£ç å¤ç”¨: é©±åŠ¨å¯ä»¥ç‹¬ç«‹äºå…·ä½“çš„ç¡¬ä»¶å¹³å°å¼€å‘ï¼Œåªè¦è®¾å¤‡æ¨¡å‹æ”¯æŒï¼Œå°±å¯ä»¥åœ¨ä¸åŒçš„å¹³å°ä¸Šè¿è¡Œã€‚ æ¨¡å—åŒ–ç®¡ç†: å…è®¸è®¾å¤‡å’Œé©±åŠ¨ä½œä¸ºç‹¬ç«‹çš„æ¨¡å—åŠ è½½å’Œå¸è½½ï¼Œæé«˜äº†ç³»ç»Ÿçš„çµæ´»æ€§ã€‚ å³æ’å³ç”¨ (Plug-and-Play): å¯¹äºPCIã€USBç­‰æ”¯æŒçƒ­æ’æ‹”çš„æ€»çº¿ï¼Œè®¾å¤‡æ¨¡å‹å¯ä»¥å®ç°è®¾å¤‡çš„åŠ¨æ€è¯†åˆ«å’ŒåŠ è½½é©±åŠ¨ã€‚ åŸç†ï¼š Linux è®¾å¤‡æ¨¡å‹çš„æ ¸å¿ƒæ€æƒ³æ˜¯ â€œå°†è®¾å¤‡å’Œé©±åŠ¨åˆ†ç¦»â€ã€‚å®ƒé€šè¿‡ struct device å’Œ struct device_driver è¿™ä¸¤ä¸ªæ ¸å¿ƒç»“æ„ä½“æ¥è¡¨ç¤ºè®¾å¤‡å’Œé©±åŠ¨ã€‚ struct bus_type: å®šä¹‰äº†æ€»çº¿çš„å±æ€§å’Œæ“ä½œï¼ŒåŒ…æ‹¬è®¾å¤‡çš„æ³¨å†Œã€é©±åŠ¨çš„æ³¨å†Œã€è®¾å¤‡çš„éå†ã€é©±åŠ¨çš„åŒ¹é…å‡½æ•°ç­‰ã€‚ struct device: ä»£è¡¨ä¸€ä¸ªå…·ä½“çš„ç¡¬ä»¶è®¾å¤‡ã€‚å®ƒåŒ…å«è®¾å¤‡çš„é€šç”¨å±æ€§ï¼ˆå¦‚åç§°ã€çˆ¶è®¾å¤‡ã€è®¾å¤‡æ ‘èŠ‚ç‚¹ç­‰ï¼‰ï¼Œä»¥åŠç‰¹å®šæ€»çº¿çš„ç§æœ‰æ•°æ®ã€‚ struct device_driver: ä»£è¡¨ä¸€ä¸ªè®¾å¤‡é©±åŠ¨ã€‚å®ƒåŒ…å«é©±åŠ¨çš„é€šç”¨å±æ€§ï¼ˆå¦‚åç§°ã€é©±åŠ¨æ‰€æ”¯æŒçš„è®¾å¤‡IDè¡¨ï¼‰ï¼Œä»¥åŠé©±åŠ¨çš„æ“ä½œå‡½æ•°ï¼ˆå¦‚ probeã€remove ç­‰ï¼‰ã€‚ å½“ä¸€ä¸ªè®¾å¤‡è¢«æ³¨å†Œåˆ°æ€»çº¿ä¸Šæ—¶ï¼Œæ€»çº¿ä¼šéå†æ‰€æœ‰å·²æ³¨å†Œçš„é©±åŠ¨ï¼Œå°è¯•æ‰¾åˆ°èƒ½å¤Ÿä¸è¯¥è®¾å¤‡åŒ¹é…çš„é©±åŠ¨ã€‚ä¸€æ—¦åŒ¹é…æˆåŠŸï¼Œå°±ä¼šè°ƒç”¨é©±åŠ¨çš„ probe å‡½æ•°æ¥åˆå§‹åŒ–è®¾å¤‡ã€‚ 3. é©±åŠ¨ä¸å°±æ˜¯ä¸€ä»½ä»£ç å—ï¼Ÿä¸ºä»€ä¹ˆè¿˜æœ‰driverçš„ä»£ç å’Œclientçš„ä»£ç ï¼Œä¸¤ä»½ï¼Ÿè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é—®é¢˜ï¼Œä¹Ÿæ˜¯å¾ˆå¤šåˆå­¦è€…å®¹æ˜“æ··æ·†çš„åœ°æ–¹ã€‚ é©±åŠ¨ (Driver) ç¡®å®æ˜¯â€œä¸€ä»½ä»£ç â€ï¼Œä½†è¿™ä»½ä»£ç æ˜¯ä¸ºäº†ç®¡ç†ä¸€ç±»ç‰¹å®šåŠŸèƒ½çš„ç¡¬ä»¶è®¾å¤‡ã€‚ ä¸ºäº†å®ç°é©±åŠ¨çš„é€šç”¨æ€§å’Œå¯ç§»æ¤æ€§ï¼ŒLinux è®¾å¤‡æ¨¡å‹å°†é©±åŠ¨åˆ†æˆäº†ä¸¤ä¸ªé€»è¾‘éƒ¨åˆ†ï¼š è®¾å¤‡ (Device) çš„æè¿°ä»£ç  (Client/Platform Device): è¿™éƒ¨åˆ†ä»£ç ä¸»è¦è´Ÿè´£ æè¿°ç¡¬ä»¶è®¾å¤‡çš„ä¿¡æ¯ï¼Œè€Œä¸æ˜¯å®ç°è®¾å¤‡çš„åŠŸèƒ½ã€‚å®ƒå‘Šè¯‰å†…æ ¸ï¼šâ€œè¿™é‡Œæœ‰ä¸€ä¸ªè®¾å¤‡ï¼Œå®ƒçš„ç±»å‹æ˜¯ä»€ä¹ˆï¼Œå®ƒè¿æ¥åœ¨å“ªä¸ªæ€»çº¿ä¸Šï¼Œå®ƒçš„åœ°å€æ˜¯å¤šå°‘ï¼Œå®ƒéœ€è¦å“ªäº›èµ„æºï¼ˆå¦‚ä¸­æ–­ã€å†…å­˜åŒºåŸŸï¼‰â€ã€‚ è¿™éƒ¨åˆ†ä»£ç é€šå¸¸ä½äº æ¿çº§æ–‡ä»¶ (board-specific file) æˆ– è®¾å¤‡æ ‘ (Device Tree) ä¸­ã€‚ ä¾‹å¦‚ï¼š å¯¹äº Platform è®¾å¤‡ï¼Œä½ ä¼šçœ‹åˆ° struct platform_device çš„å®šä¹‰ï¼Œé‡Œé¢åŒ…å«äº†è®¾å¤‡çš„åç§°ã€èµ„æºç­‰ã€‚ å¯¹äº I2C è®¾å¤‡ï¼Œä½ ä¼šçœ‹åˆ° struct i2c_client çš„å®šä¹‰ï¼Œæˆ–è€…åœ¨è®¾å¤‡æ ‘ä¸­æè¿°I2Cè®¾å¤‡çš„èŠ‚ç‚¹ã€‚ é©±åŠ¨ (Driver) çš„åŠŸèƒ½å®ç°ä»£ç  (Platform Driver/I2C Driver): è¿™éƒ¨åˆ†ä»£ç æ‰æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„ â€œé©±åŠ¨â€ã€‚å®ƒè´Ÿè´£ å®ç°ä¸ç‰¹å®šç±»å‹è®¾å¤‡è¿›è¡Œäº¤äº’çš„é€»è¾‘ã€‚ å®ƒåŒ…å«äº†è®¾å¤‡åˆå§‹åŒ–ï¼ˆprobe å‡½æ•°ï¼‰ã€æ•°æ®ä¼ è¾“ã€ä¸­æ–­å¤„ç†ã€ç”µæºç®¡ç†ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚ è¿™éƒ¨åˆ†ä»£ç é€šå¸¸ä½äº ç‹¬ç«‹çš„é©±åŠ¨æ–‡ä»¶ ä¸­ï¼ˆä¾‹å¦‚ï¼šdrivers/char/xxx.c, drivers/i2c/chips/yyy.c, drivers/platform/zzz.cï¼‰ã€‚ ä¾‹å¦‚ï¼š å¯¹äº Platform é©±åŠ¨ï¼Œä½ ä¼šçœ‹åˆ° struct platform_driver çš„å®šä¹‰ï¼Œå…¶ä¸­åŒ…å«äº† probeã€remove ç­‰å‡½æ•°æŒ‡é’ˆã€‚ å¯¹äº I2C é©±åŠ¨ï¼Œä½ ä¼šçœ‹åˆ° struct i2c_driver çš„å®šä¹‰ï¼ŒåŒæ ·åŒ…å« probeã€remove ç­‰å‡½æ•°æŒ‡é’ˆã€‚ ä¸ºä»€ä¹ˆä¼šæœ‰ä¸¤ä»½ï¼Ÿ åˆ†ç¦»å…³æ³¨ç‚¹ (Separation of Concerns): å°†è®¾å¤‡æè¿°å’Œé©±åŠ¨åŠŸèƒ½åˆ†ç¦»ï¼Œä½¿å¾—é©±åŠ¨ä»£ç æ›´åŠ é€šç”¨ã€‚åŒä¸€ä¸ªé©±åŠ¨å¯ä»¥åœ¨ä¸åŒçš„ç¡¬ä»¶å¹³å°ä¸Šä½¿ç”¨ï¼Œåªè¦è¿™äº›å¹³å°èƒ½å¤Ÿæ­£ç¡®æè¿°å‡ºè¯¥è®¾å¤‡ã€‚ æ¿çº§å‚å•†åªéœ€è¦æè¿°å…¶ç¡¬ä»¶è®¾å¤‡çš„ç‰¹æ€§ï¼Œè€Œé©±åŠ¨å¼€å‘è€…å¯ä»¥ä¸“æ³¨äºå®ç°è®¾å¤‡åŠŸèƒ½ã€‚ å¯ç§»æ¤æ€§ (Portability): é©±åŠ¨ä»£ç å¯ä»¥ç‹¬ç«‹äºå…·ä½“çš„ç¡¬ä»¶å¹³å°ç¼–è¯‘å’ŒåŠ è½½ã€‚ å½“ç¡¬ä»¶å¹³å°å‘ç”Ÿå˜åŒ–æ—¶ï¼Œå¯èƒ½åªéœ€è¦ä¿®æ”¹è®¾å¤‡æè¿°éƒ¨åˆ†ï¼ˆå¦‚è®¾å¤‡æ ‘ï¼‰ï¼Œè€Œæ— éœ€ä¿®æ”¹é©±åŠ¨ä»£ç æœ¬èº«ã€‚ æ¨¡å—åŒ– (Modularity): è®¾å¤‡å’Œé©±åŠ¨å¯ä»¥ä½œä¸ºç‹¬ç«‹çš„æ¨¡å—åŠ¨æ€åŠ è½½å’Œå¸è½½ï¼Œæ–¹ä¾¿å¼€å‘å’Œè°ƒè¯•ã€‚ å³æ’å³ç”¨ (Plug and Play): å½“è®¾å¤‡è¢«å‘ç°æ—¶ï¼ˆä¾‹å¦‚æ’å…¥USBè®¾å¤‡ï¼‰ï¼Œå†…æ ¸å¯ä»¥æ ¹æ®è®¾å¤‡çš„æè¿°ä¿¡æ¯è‡ªåŠ¨å¯»æ‰¾å¹¶åŠ è½½å¯¹åº”çš„é©±åŠ¨ã€‚ 4. Match çš„è¿‡ç¨‹æ˜¯ä»€ä¹ˆæ ·å­çš„å‘¢ï¼ŸåŒ¹é… (Matching) æ˜¯è®¾å¤‡æ¨¡å‹ä¸­æœ€æ ¸å¿ƒçš„æœºåˆ¶ä¹‹ä¸€ã€‚å½“ä¸€ä¸ªè®¾å¤‡è¢«æ³¨å†Œåˆ°æ€»çº¿ä¸Šæ—¶ï¼Œå†…æ ¸ä¼šè§¦å‘åŒ¹é…è¿‡ç¨‹ï¼Œå¯»æ‰¾èƒ½å¤Ÿé©±åŠ¨è¯¥è®¾å¤‡çš„é©±åŠ¨ã€‚ é€šç”¨åŒ¹é…æµç¨‹ (ä»¥ Platform æ€»çº¿ä¸ºä¾‹)ï¼š è®¾å¤‡æ³¨å†Œ: å½“å†…æ ¸æˆ–æŸä¸ªæ¨¡å—å‘ç°å¹¶æ³¨å†Œä¸€ä¸ª platform_device åˆ° platform_bus ä¸Šæ—¶ï¼ŒåŒ¹é…è¿‡ç¨‹å¼€å§‹ã€‚ è¿™é€šå¸¸å‘ç”Ÿåœ¨å†…æ ¸å¯åŠ¨æ—¶ï¼Œæˆ–è€…é€šè¿‡è®¾å¤‡æ ‘åŠ¨æ€è§£æè®¾å¤‡ã€‚ platform_device_register() å‡½æ•°ä¼šè¢«è°ƒç”¨ã€‚ éå†é©±åŠ¨: platform_bus ä¼šéå†æ‰€æœ‰å·²ç»æ³¨å†Œåˆ°å®ƒä¸Šé¢çš„ platform_driverã€‚ è°ƒç”¨åŒ¹é…å‡½æ•°: å¯¹äºæ¯ä¸€ä¸ª platform_driverï¼Œæ€»çº¿ä¼šè°ƒç”¨å…¶å†…éƒ¨çš„ match å‡½æ•°ï¼ˆå¯¹äº Platform æ€»çº¿ï¼Œé€šå¸¸æ˜¯ platform_match()ï¼‰ã€‚ åŒ¹é…é€»è¾‘: match å‡½æ•°ä¼šæ ¹æ®é¢„å®šçš„è§„åˆ™ï¼ˆé€šå¸¸æ˜¯åç§°åŒ¹é…æˆ– compatible å­—ç¬¦ä¸²åŒ¹é…ï¼‰æ¥åˆ¤æ–­å½“å‰è®¾å¤‡æ˜¯å¦ä¸å½“å‰é©±åŠ¨å…¼å®¹ã€‚ åç§°åŒ¹é…: platform_device-&gt;name == platform_driver-&gt;driver.nameã€‚ è®¾å¤‡æ ‘ compatible åŒ¹é… (æ›´å¸¸ç”¨): platform_device-&gt;of_node-&gt;compatible å±æ€§ä¸ platform_driver-&gt;of_match_table ä¸­çš„ compatible å­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒã€‚ æˆåŠŸåŒ¹é…: å¦‚æœ match å‡½æ•°è¿”å›æˆåŠŸï¼ˆè¡¨ç¤ºè®¾å¤‡å’Œé©±åŠ¨åŒ¹é…ï¼‰ï¼Œé‚£ä¹ˆæ€»çº¿å°±ä¼šå°†è¯¥è®¾å¤‡ä¸è¯¥é©±åŠ¨å…³è”èµ·æ¥ã€‚ è°ƒç”¨ probe å‡½æ•°: æ¥ç€ï¼Œå†…æ ¸ä¼šè°ƒç”¨åŒ¹é…æˆåŠŸçš„ platform_driver çš„ probe å‡½æ•°ã€‚ probe å‡½æ•°æ˜¯é©±åŠ¨çš„æ ¸å¿ƒï¼Œå®ƒè´Ÿè´£åˆå§‹åŒ–è®¾å¤‡ã€è¯·æ±‚èµ„æºã€æ³¨å†Œä¸­æ–­ã€åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ç­‰ç­‰ã€‚ å¦‚æœ probe å‡½æ•°æˆåŠŸè¿”å›ï¼Œè¡¨ç¤ºè®¾å¤‡é©±åŠ¨åŠ è½½æˆåŠŸï¼›å¦‚æœè¿”å›é”™è¯¯ç ï¼Œåˆ™è¡¨ç¤ºåŠ è½½å¤±è´¥ã€‚ I2C æ€»çº¿åŒ¹é…æµç¨‹ï¼š I2C æ€»çº¿çš„åŒ¹é…ä¸ Platform ç±»ä¼¼ï¼Œä½†å®ƒæœ‰è‡ªå·±çš„ i2c_bus_type å’ŒåŒ¹é…å‡½æ•°ã€‚ I2C é€‚é…å™¨æ³¨å†Œ: I2C æ§åˆ¶å™¨ä½œä¸º Platform è®¾å¤‡æ³¨å†Œåï¼Œå…¶ Platform é©±åŠ¨ä¼šæ³¨å†Œ i2c_adapterï¼Œè¿™ä»£è¡¨äº†ä¸€ä¸ªå¯ç”¨çš„ I2C æ€»çº¿ã€‚ I2C å®¢æˆ·ç«¯æ³¨å†Œ: I2C è®¾å¤‡çš„æè¿°ï¼ˆé€šå¸¸åœ¨è®¾å¤‡æ ‘ä¸­ï¼‰è¢«è§£æåï¼Œä¼šåˆ›å»ºä¸€ä¸ª i2c_client ç»“æ„ä½“å¹¶å°†å…¶æ³¨å†Œåˆ°å¯¹åº”çš„ i2c_adapter ä¸Šã€‚ éå† I2C é©±åŠ¨: I2C æ€»çº¿ä¼šéå†æ‰€æœ‰å·²ç»æ³¨å†Œçš„ i2c_driverã€‚ è°ƒç”¨åŒ¹é…å‡½æ•°: I2C æ€»çº¿ä¼šè°ƒç”¨å…¶å†…éƒ¨çš„åŒ¹é…å‡½æ•° (i2c_device_match())ã€‚ åŒ¹é…é€»è¾‘: ID è¡¨åŒ¹é…: i2c_driver-&gt;id_table å­—æ®µä¸­çš„ name æˆå‘˜ä¸ i2c_client-&gt;name è¿›è¡ŒåŒ¹é…ã€‚ è®¾å¤‡æ ‘ compatible åŒ¹é… (æ›´å¸¸ç”¨): i2c_client-&gt;dev.of_node-&gt;compatible å±æ€§ä¸ i2c_driver-&gt;driver.of_match_table ä¸­çš„ compatible å­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒã€‚ æˆåŠŸåŒ¹é…: åŒ¹é…æˆåŠŸåï¼Œè°ƒç”¨ i2c_driver çš„ probe å‡½æ•°ã€‚ æ€»ç»“ï¼š Linux è®¾å¤‡æ¨¡å‹çš„æ ¸å¿ƒæ˜¯ Bus-Device-Driver æ¶æ„ï¼Œæ—¨åœ¨å°†è®¾å¤‡å’Œé©±åŠ¨åˆ†ç¦»ï¼Œå®ç°ä»£ç çš„é€šç”¨æ€§å’Œå¯ç§»æ¤æ€§ã€‚ æ€»çº¿ (Bus) è´Ÿè´£ç®¡ç†è®¾å¤‡å’Œé©±åŠ¨çš„æ³¨å†Œä¸åŒ¹é…ã€‚ è®¾å¤‡ (Device/Client) æè¿°äº†ç¡¬ä»¶çš„ç‰¹æ€§å’Œèµ„æºã€‚ é©±åŠ¨ (Driver) å®ç°äº†ä¸è®¾å¤‡äº¤äº’çš„é€»è¾‘ã€‚ åŒ¹é…è¿‡ç¨‹æ˜¯æ€»çº¿æ ¹æ®é¢„å®šçš„è§„åˆ™ï¼ˆåç§°æˆ– compatible å­—ç¬¦ä¸²ï¼‰å°†è®¾å¤‡å’Œé©±åŠ¨å…³è”èµ·æ¥çš„è¿‡ç¨‹ï¼ŒæˆåŠŸåä¼šè°ƒç”¨é©±åŠ¨çš„ probe å‡½æ•°ã€‚ å¸Œæœ›è¿™äº›è§£é‡Šèƒ½å¸®åŠ©ä½ æ›´å¥½åœ°ç†è§£ Linux è®¾å¤‡é©±åŠ¨çš„ Bus-Device-Driver æ¶æ„ï¼è¿™æ˜¯ä¸€ä¸ªå€¼å¾—æ·±å…¥å­¦ä¹ çš„é¢†åŸŸï¼Œä¸€æ—¦æŒæ¡ï¼Œä½ ä¼šå¯¹æ“ä½œç³»ç»Ÿå¦‚ä½•ä¸ç¡¬ä»¶äº¤äº’æœ‰æ›´æ·±åˆ»çš„ç†è§£ã€‚","link":"/post/wds-IIC.html"},{"title":"xv6-riscv-ch2","text":"This chapter2 explains how the OS is structured internally to manage hardware resources, run processes, and enforce protection. ch2: Operating system organization A key requirement for an operating system is to support several activities at once. an operating system must fulfill three requirements: multiplexing, isolation, andinteraction. Xv6 runs on a multi-core1 RISC-V microprocessor, and much of its low-level functionality(for example, its process implementation) is specific to RISC-V. RISC-V is a 64-bit CPU, and xv6is written in â€œLP64â€ C, which means long (L) and pointers (P) in the C programming languageare 64 bits, but an int is 32 bits. RISCV Technical Specifications 2.1 Abstracting physical resources The Unix interface is not the only way to abstractresources, but it has proved to be a good one. 2.2 User mode, supervisor mode, and system calls CPUs provide hardware support for strong isolation. For example, RISC-V has three modes inwhich the CPU can execute instructions: machine mode, supervisor mode, and user mode. Instruc-tions executing in machine mode have full privilege; a CPU starts in machine mode. Machine modeis mostly intended for setting up the computer during boot. Xv6 executes a few lines in machinemode and then changes to supervisor mode. In supervisor mode the CPU is allowed to execute privileged instructions: for example, en-abling and disabling interrupts, reading and writing the register that holds the address of a pagetable, etc. An application can execute only user-mode instructions (e.g., addingnumbers, etc.) and is said to be running in user space, while the software in supervisor mode canalso execute privileged instructions and is said to be running in kernel space. The software runningin kernel space (or in supervisor mode) is called the kernel. CPUs provide aspecial instruction that switches the CPU from user mode to supervisor mode and enters the kernelat an entry point specified by the kernel. (RISC-V provides the ecall instruction for this purpose.)Once the CPU has switched to supervisor mode, the kernel can then validate the arguments of thesystem call (e.g., check if the address passed to the system call is part of the applicationâ€™s memory),decide whether the application is allowed to perform the requested operation (e.g., check if theapplication is allowed to write the specified file), and then deny it or execute it. It is important thatthe kernel control the entry point for transitions to supervisor mode; if the application could decidethe kernel entry point, a malicious application could, for example, enter the kernel at a point wherethe validation of arguments is skipped. 2.3 Kernel organization A key design question is what part of the operating system should run in supervisor mode. Onepossibility is that the entire operating system resides in the kernel, so that the implementations ofall system calls run in supervisor mode. This organization is called a monolithic kernel. A downside of the monolithic organization is that the interactions among different parts ofthe operating system are often complex (as we will see in the rest of this text), and therefore it is easy for an operating system developer to make a mistake. In a monolithic kernel, a mistake isfatal, because an error in supervisor mode will often cause the kernel to fail. If the kernel fails,the computer stops working, and thus all applications fail too. The computer must reboot to startagain. To reduce the risk of mistakes in the kernel, OS designers can minimize the amount of operatingsystem code that runs in supervisor mode, and execute the bulk of the operating system in usermode. This kernel organization is called a microkernel. Figure 2.1 illustrates this microkernel design. In the figure, the file system runs as a user-levelprocess. OS services running as processes are called servers. To allow applications to interact withthe file server, the kernel provides an inter-process communication mechanism to send messagesfrom one user-mode process to another. Xv6 is implemented as a monolithic kernel, like most Unix operating systems. Thus, the xv6kernel interface corresponds to the operating system interface, and the kernel implements the com-plete operating system. Since xv6 doesnâ€™t provide many services, its kernel is smaller than somemicrokernels, but conceptually xv6 is monolithic. 2.4 Code: xv6 organization The xv6 kernel source is in the kernel/ sub-directory. The source is divided into files, followinga rough notion of modularity; Figure 2.2 lists the files.The inter-module interfaces are defined in defs.h (kernel/defs.h). 2.5 Process overview The unit of isolation in xv6 (as in other Unix operating systems) is a process. The process ab-straction prevents one process from wrecking or spying on another processâ€™s memory, CPU, filedescriptors, etc. It also prevents a process from wrecking the kernel itself, so that a process canâ€™tsubvert the kernelâ€™s isolation mechanisms. To help enforce isolation, the process abstraction provides the illusion to a program that it hasits own private machine. A process provides a program with what appears to be a private memorysystem, or address space, which other processes cannot read or write. A process also provides theprogram with what appears to be its own CPU to execute the programâ€™s instructions. Xv6 uses page tables (which are implemented by hardware) to give each process its own ad-dress space. The RISC-V page table translates (or â€œmapsâ€) a virtual address (the address that anRISC-V instruction manipulates) to a physical address (an address that the CPU sends to mainmemory). 12345678910111213| 9 bits | 9 bits | 9 bits | 12 bits || VPN[2] | VPN[1] | VPN[0] | Page Offset ||-------- é¡µè¡¨ç´¢å¼• --------| é¡µå†…åç§» |example:è™šæ‹Ÿåœ°å€ï¼š0x0000004001234567 â†“VPN[2] = 0x01 â†’ level-2 é¡µè¡¨ï¼ˆæ ¹ï¼‰ä¸­åç§» 8ï¼Œå¾—åˆ° PTE1 â†’ æŒ‡å‘ 0x2000_0000VPN[1] = 0x01 â†’ level-1 é¡µè¡¨ä¸­åç§» 8ï¼Œå¾—åˆ° PTE2 â†’ æŒ‡å‘ 0x3000_0000VPN[0] = 0x46 â†’ level-0 é¡µè¡¨ä¸­åç§» 0x230ï¼Œå¾—åˆ° PTE3 â†’ é¡µå¸§ 0x4000offset = 0x4567â†’ æœ€ç»ˆç‰©ç†åœ°å€ = 0x4000_0000 + 0x4567 = **0x4000_4567** Xv6 maintains a separate page table for each process that defines that processâ€™s address space.As illustrated in Figure 2.3, an address space includes the processâ€™s user memory starting at virtualaddress zero. Instructions come first, followed by global variables, then the stack, and finally a â€œheapâ€ area (for malloc) that the process can expand as needed. There are a number of factors that limit the maximum size of a processâ€™s address space: pointers on the RISC-V are 64 bits wide; the hardware uses only the low 39 bits when looking up virtual addresses in page tables; and xv6 uses only 38 of those 39 bits. Thus, the maximum address is 238 âˆ’ 1 = 0x3fffffffff, which is MAXVA (kernel/riscv.h:378). At the top of the address space xv6 places a trampoline page (4096 bytes) and a trapframe page. Xv6 uses these two pages to transition into the kernel and back; the trampoline page contains the code to transition in and out of the kernel, and the trapframe is where the kernel saves the processâ€™s user registers, as Chapter 4 explains. The xv6 kernel maintains many pieces of state for each process, which it gathers into a struct proc (kernel/proc.h:85). A processâ€™s most important pieces of kernel state are its page table, its kernelstack, and its run state. Weâ€™ll use the notation p-&gt;xxx to refer to elements of the proc structure; for example, p-&gt;pagetable is a pointer to the processâ€™s page table. Each process has a thread of control (or thread for short) that holds the state needed to ex-ecute the process.might be executing on a CPU, or suspended (notexecuting, but capable of resuming executing in the future). Each process has two stacks: user stack: When the process is executing user instructions,only its user stack is in use, and its kernel stack is empty. kernel stack: When the process enters the kernel (for a system call or interrupt), the kernel code executes on the processâ€™s kernel stack; while a process is in the kernel, its user stack still contains saved data, but isnâ€™t actively used. A processâ€™s thread alternates between actively using its user stack and its kernel stack. The kernel stack is separate (and protected from user code) so that the kernel can execute even if a process has wrecked its user stack. A process can make a system call by executing the RISC-V ecall instruction. This instruction raises the hardware privilege level and changes the program counter to a kernel-defined entry point. The code at the entry point switches to the processâ€™s kernel stack and executes the kernel instructions that implement the system call. When the system call completes, the kernel switches back to the user stack and returns to user space by calling the sret instruction, which lowers the hardware privilege level and resumes executing user instructions just after the system call instruction. A processâ€™s thread can â€œblockâ€ in the kernel to wait for I/O, and resume where it left off when the I/O has finished. p-&gt;state indicates whether the process is allocated, ready to run, currently running on a CPU, waiting for I/O, or exiting. p-&gt;pagetable holds the processâ€™s page table, in the format that the RISC-V hardware ex- pects. Xv6 causes the paging hardware to use a processâ€™s p-&gt;pagetable when executing that process in user space. A processâ€™s page table also serve In summary, a process bundles two design ideas: an address space to give a process the illusion of its own memory, and a thread to give the process the illusion of its own CPU. In xv6, a process consists of one address space and one thread. In real operating systems a process may have more than one thread to take advantage of multiple CPUs. 2.6 Code: starting xv6, the first process and system callTo make xv6 more concrete, weâ€™ll outline how the kernel starts and runs the first process.The subsequent chapters will describe the mechanisms that show up in this overview in more detail. When the RISC-V computer powers on, it initializes itself and runs a boot loader which is stored in read-only memory.The boot loader loads the xv6 kernel into memory.Then, in machine mode, the CPU executes xv6 starting at _entry (kernel/entry.S:7).The RISC-V starts with paging hardware disabled: virtual addresses map directly to physical addresses. The loader loads the xv6 kernel into memory at physical address 0x80000000.The reason it places the kernel at 0x80000000 rather than 0x0 is because the address range 0x0:0x80000000 contains I/O devices. The instructions at _entry set up a stack so that xv6 can run C code.Xv6 declares space for an initial stack, stack0, in the file start.c (kernel/start.c:11).The code at _entry loads the stack pointer register sp with the address stack0 + 4096, the top of the stack, because the stack on RISC-V grows down.Now that the kernel has a stack, _entry calls into C code at start (kernel/start.c:15). The function start performs some configuration that is only allowed in machine mode, and then switches to supervisor mode.To enter supervisor mode, RISC-V provides the instruction mret.This instruction is most often used to return from a previous call from supervisor mode to machine mode.start isnâ€™t returning from such a call, but sets things up as if it were: it sets the previous privilege mode to supervisor in the register mstatus, it sets the return address to main by writing mainâ€™s address into the register mepc, disables virtual address translation in supervisor mode by writing 0 into the page-table register satp, and delegates all interrupts and exceptions to supervisor mode. Before jumping into supervisor mode, start performs one more task:it programs the clock chip to generate timer interrupts.With this housekeeping out of the way, start â€œreturnsâ€ to supervisor mode by calling mret.This causes the program counter to change to main (kernel/main.c:11), the address previously stored in mepc. After main (kernel/main.c:11) initializes several devices and subsystems, it creates the first process by calling userinit (kernel/proc.c:233).The first process executes a small program written in RISC-V assembly, which makes the first system call in xv6.initcode.S (user/initcode.S:3) loads the number for the exec system call, SYS_EXEC (kernel/syscall.h:8), into register a7,and then calls ecall to re-enter the kernel. The kernel uses the number in register a7 in syscall (kernel/syscall.c:132) to call the desired system call.The system call table (kernel/syscall.c:107) maps SYS_EXEC to the function sys_exec, which the kernel invokes.As we saw in Chapter 1, exec replaces the memory and registers of the current process with a new program (in this case, /init). Once the kernel has completed exec, it returns to user space in the /init process.init (user/init.c:15) creates a new console device file if needed and then opens it as file descriptors 0, 1, and 2. Then it starts a shell on the console. The system is up. 2.7 Security Model The operating system must assume that a processâ€™s user-level code will do its best to wreck the kernel or other processes.User code may try to dereference pointers outside its allowed address space; it may attempt to execute any RISC-V instructions, even those not intended for user code; it may try to read and write any RISC-V control register; it may try to directly access device hardware; and it may pass clever values to system calls in an attempt to trick the kernel into crashing or doing something stupid. The kernelâ€™s goal is to restrict each user process so that all it can do is: read/write/execute its own user memory, use the 32 general-purpose RISC-V registers, and affect the kernel and other processes only in the ways that system calls are intended to allow. The expectations for the kernelâ€™s own code are quite different.Kernel code is assumed to be written by well-meaning and careful programmers.Kernel code is expected to be bug-free, and certainly to contain nothing malicious.This assumption affects how we analyze kernel code.For example, there are many internal kernel functions (e.g., the spin locks) that would cause serious problems if kernel code used them incorrectly.When examining any specific piece of kernel code, weâ€™ll want to convince ourselves that it behaves correctly.We assume, however, that kernel code in general is correctly written, and follows all the rules about use of the kernelâ€™s own functions and data structures. At the hardware level, the RISC-V CPU, RAM, disk, etc. are assumed to operate as advertised in the documentation, with no hardware bugs. 2.8 Real worldMost operating systems have adopted the process concept, and most processes look similar to xv6â€™s. Modern operating systems, however, support several threads within a process, to allow a single process to exploit multiple CPUs. Supporting multiple threads in a process involves quite a bit of machinery that xv6 doesnâ€™t have, often including interface changes (e.g., Linuxâ€™s clone, a variant of fork), to control which aspects of a process threads share.","link":"/post/xv6-riscv-ch2.html"},{"title":"xv6-riscv_ch4","text":"How traps and system calls work on RISC-V. It introduces the trap mechanism, how user programs invoke system calls, how the kernel handles those traps, and how arguments are passed. It also covers kernel-mode traps, page faults, and real-world implications like protection and isolation. ch4: Traps and system calls There are three kinds of event which cause the CPU to set aside ordinary execution of instructions and force a transfer of control to special code that handles the event. and we uses trap as a generic term for these situations. One situation is a systemcall, when a user program executes the ecall instruction to ask the kernel to do something for it. Another situation is an exception: an instruction (user or kernel) does something illegal, such as divide by zero or use an invalid virtual address. The third situation is a device interrupt, when a device signals that it needs attention, for example when the disk hardware finishes a read or write request. Xv6 handles all traps in the kernel; traps are not delivered to user code. Handling traps in the kernel is natural for system calls. It makes sense for interrupts since isolation demands that only the kernel be allowed to use devices, and because the kernel is a convenient mechanism with which to share devices among multiple processes. It also makes sense for exceptions since xv6 responds to all exceptions from user space by killing the offending program. Xv6 trap handling proceeds in four stages: hardware actions taken by the RISC-V CPU, some assembly instructions that prepare the way for kernel C code a C function that decides what to do with the trap and the system call or device-driver service routine. While commonality among the three trap types suggests that a kernel could handle all traps with a single code path, it turns out to be convenient to have separate code for two distinct cases: traps from user space, and traps from kernel space. Kernel code (assembler or C) that processes a trap is often called a handler; the first handler instructions are usually written in assembler (rather than C) and are sometimes called a vector. 4.1 RISC-V trap machineryæœºåˆ¶ Each RISC-V CPU has a set of control registers that the kernel writes to tell the CPU how to handle traps, and that the kernel can read to find out about a trap that has occurred. The RISC-V documents contain the full story [3]. riscv.h (kernel/riscv.h:1) contains definitions that xv6 uses. Hereâ€™s an outline of the most important registers: stvec: The kernel writes the address of its trap handler here; the RISC-V jumps to the address in stvec to handle a trap. sepc: When a trap occurs, RISC-V saves the program counter here (since the pc is then overwritten with the value in stvec). The sret (return from trap) instruction copies sepc to the pc. The kernel can write sepc to control where sret goes. scause: RISC-V puts a number here that describes the reason for the trap. sscratch: The trap handler code uses sscratch to help it avoid overwriting user registers before saving them. sstatus: The SIE bit in sstatus controls whether device interrupts are enabled. If the kernel clears SIE, the RISC-V will defer device interrupts until the kernel sets SIE. The SPP bit indicates whether a trap came from user mode or supervisor mode, and controls to what mode sret returns. The above registers relate to traps handled in supervisor mode, and they cannot be read or written in user mode. Each CPU on a multi-core chip has its own set of these registers, and more than one CPU may be handling a trap at any given time. When it needs to force a trap, the RISC-V hardware does the following for all trap types: If the trap is a device interrupt, and the sstatus SIE bit is clear, donâ€™t do any of the following. Disable interrupts by clearing the SIE bit in sstatus. Copy the pc to sepc. Save the current mode (user or supervisor) in the SPP bit in sstatus. Set scause to reflect the trapâ€™s cause. Set the mode to supervisor. Copy stvec to the pc. Start executing at the new pc. Note that the CPU doesnâ€™t switch to the kernel page table, doesnâ€™t switch to a stack in the kernel, and doesnâ€™t save any registers other than the pc. Kernel software must perform these tasks. One reason that the CPU does minimal work during a traps is to provide flexibility to software; for example, some operating systems omit a page table switch in some situations to increase trap performance.Itâ€™s worth thinking about whether any of the steps listed above could be omitted, perhaps in search of faster traps. Though there are situations in which a simpler sequence can work, many of the steps would be dangerous to omit in general. For example, suppose that the CPU didnâ€™t switch program counters. Then a trap from user space could switch to supervisor mode while still running user instructions. Those user instructions could break user/kernel isolation, for example by modifying the satp register to point to a page table that allowed accessing all of physical memory. It is thus important that the CPU switch to a kernel-specified instruction address, namely stvec. 4.2 Traps from user spaceXv6 handles traps differently depending on whether the trap occurs while executing in the kernelor in user code. Here is the story for traps from user code; Section 4.5 describes traps from kernelcode.A trap may occur while executing in user space if the user program makes a system call (ecallinstruction), or does something illegal, or if a device interrupts. The high-level path of a trap fromuser space is uservec (kernel/trampoline.S:22), then usertrap (kernel/trap.c:37); and when re-turning, usertrapret (kernel/trap.c:90) and then userret (kernel/trampoline.S:101).A major constraint on the design of xv6â€™s trap handling is the fact that the RISC-V hardwaredoes not switch page tables when it forces a trap. This means that the trap handler address instvec must have a valid mapping in the user page table, since thatâ€™s the page table in force whenthe trap handling code starts executing. Furthermore, xv6â€™s trap handling code needs to switch tothe kernel page table; in order to be able to continue executing after that switch, the kernel pagetable must also have a mapping for the handler pointed to by stvec.Xv6 satisfies these requirements using a trampoline page. The trampoline page contains uservec,the xv6 trap handling code that stvec points to. The trampoline page is mapped in every processâ€™spage table at address TRAMPOLINE, which is at the top of the virtual address space so that it will beabove memory that programs use for themselves. The trampoline page is also mapped at addressTRAMPOLINE in the kernel page table. See Figure 2.3 and Figure 3.3. Because the trampolinepage is mapped in the user page table, traps can start executing there in supervisor mode. Becausethe trampoline page is mapped at the same address in the kernel address space, the trap handlercan continue to execute after it switches to the kernel page table.The code for the uservec trap handler is in trampoline.S (kernel/trampoline.S:22). Whenuservec starts, all 32 registers contain values owned by the interrupted user code. These 32values need to be saved somewhere in memory, so that later on the kernel can restore them beforereturning to user space. Storing to memory requires use of a register to hold the address, but at thispoint there are no general-purpose registers available! Luckily RISC-V provides a helping hand inthe form of the sscratch register. The csrw instruction at the start of uservec saves a0 insscratch. Now uservec has one register (a0) to play with.uservecâ€™s next task is to save the 32 user registers. The kernel allocates, for each process, apage of memory for a trapframe structure that (among other things) has space to save the 32user registers (kernel/proc.h:43). Because satp still refers to the user page table, uservec needsthe trapframe to be mapped in the user address space. Xv6 maps each processâ€™s trapframe at virtualaddress TRAPFRAME in that processâ€™s user page table; TRAPFRAME is just below TRAMPOLINE.The processâ€™s p-&gt;trapframe also points to the trapframe, though at its physical address so thekernel can use it through the kernel page table.Thus uservec loads address TRAPFRAME into a0 and saves all the user registers there,including the userâ€™s a0, read back from sscratch.The trapframe contains the address of the current processâ€™s kernel stack, the current CPUâ€™shartid, the address of the usertrap function, and the address of the kernel page table. uservecretrieves these values, switches satp to the kernel page table, and jumps to usertrap.The job of usertrap is to determine the cause of the trap, process it, and return (kernel/-trap.c:37). It first changes stvec so that a trap while in the kernel will be handled by kernelvecrather than uservec. It saves the sepc register (the saved user program counter), becauseusertrap might call yield to switch to another processâ€™s kernel thread, and that process mightreturn to user space, in the process of which it will modify sepc. If the trap is a system call,usertrap calls syscall to handle it; if a device interrupt, devintr; otherwise itâ€™s an ex-ception, and the kernel kills the faulting process. The system call path adds four to the saved userprogram counter because RISC-V, in the case of a system call, leaves the program pointer pointingto the ecall instruction but user code needs to resume executing at the subsequent instruction.On the way out, usertrap checks if the process has been killed or should yield the CPU (if thistrap is a timer interrupt).The first step in returning to user space is the call to usertrapret (kernel/trap.c:90). Thisfunction sets up the RISC-V control registers to prepare for a future trap from user space: settingstvec to uservec and preparing the trapframe fields that uservec relies on. usertrapretsets sepc to the previously saved user program counter. At the end, usertrapret calls userreton the trampoline page that is mapped in both user and kernel page tables; the reason is that as-sembly code in userret will switch page tables.usertrapretâ€™s call to userret passes a pointer to the processâ€™s user page table in a0(kernel/trampoline.S:101). userret switches satp to the processâ€™s user page table. Recall that theuser page table maps both the trampoline page and TRAPFRAME, but nothing else from the kernel.The trampoline page mapping at the same virtual address in user and kernel page tables allowsuserret to keep executing after changing satp. From this point on, the only data userretcan use is the register contents and the content of the trapframe. userret loads the TRAPFRAMEaddress into a0, restores saved user registers from the trapframe via a0, restores the saved usera0, and executes sret to return to user space. 4.3 Code: Calling system callsChapter 2 ended with initcode.S invoking the exec system call (user/initcode.S:11). Letâ€™s lookat how the user call makes its way to the exec system callâ€™s implementation in the kernel.initcode.S places the arguments for exec in registers a0 and a1, and puts the system callnumber in a7. System call numbers match the entries in the syscalls array, a table of functionpointers (kernel/syscall.c:107). The ecall instruction traps into the kernel and causes uservec,usertrap, and then syscall to execute, as we saw above.syscall (kernel/syscall.c:132) retrieves the system call number from the saved a7 in the trapframeand uses it to index into syscalls. For the first system call, a7 contains SYS_exec (ker-nel/syscall.h:8), resulting in a call to the system call implementation function sys_exec.When sys_exec returns, syscall records its return value in p-&gt;trapframe-&gt;a0. This willcause the original user-space call to exec() to return that value, since the C calling conventionon RISC-V places return values in a0. System calls conventionally return negative numbers toindicate errors, and zero or positive numbers for success. If the system call number is invalid,syscall prints an error and returns âˆ’1. 4.4 Code: System call arguments System call implementations in the kernel need to find the arguments passed by user code. Becauseuser code calls system call wrapper functions, the arguments are initially where the RISC-V Ccalling convention places them: in registers. The kernel trap code saves user registers to the currentprocessâ€™s trap frame, where kernel code can find them. The kernel functions argint, argaddr,and argfd retrieve the n â€™th system call argument from the trap frame as an integer, pointer, or a filedescriptor. They all call argraw to retrieve the appropriate saved user register (kernel/syscall.c:34).Some system calls pass pointers as arguments, and the kernel must use those pointers to reador write user memory. The exec system call, for example, passes the kernel an array of pointersreferring to string arguments in user space. These pointers pose two challenges. First, the user pro-gram may be buggy or malicious, and may pass the kernel an invalid pointer or a pointer intendedto trick the kernel into accessing kernel memory instead of user memory. Second, the xv6 kernelpage table mappings are not the same as the user page table mappings, so the kernel cannot useordinary instructions to load or store from user-supplied addresses.The kernel implements functions that safely transfer data to and from user-supplied addresses.fetchstr is an example (kernel/syscall.c:25). File system calls such as exec use fetchstr toretrieve string file-name arguments from user space. fetchstr calls copyinstr to do the hardwork.copyinstr (kernel/vm.c:415) copies up to max bytes to dst from virtual address srcva inthe user page table pagetable. Since pagetable is not the current page table, copyinstruses walkaddr (which calls walk) to look up srcva in pagetable, yielding physical addresspa0. The kernelâ€™s page table maps all of physical RAM at virtual addresses that are equal to theRAMâ€™s physical address. This allows copyinstr to directly copy string bytes from pa0 to dst.walkaddr (kernel/vm.c:109) checks that the user-supplied virtual address is part of the processâ€™s user address space, so programs cannot trick the kernel into reading other memory. A similarfunction, copyout, copies data from the kernel to a user-supplied address. 4.5 Traps from kernel spaceXv6 handles traps from kernel code in a different way than traps from user code. When enteringthe kernel, usertrap points stvec to the assembly code at kernelvec (kernel/kernelvec.S:12).Since kernelvec only executes if xv6 was already in the kernel, kernelvec can rely onsatp being set to the kernel page table, and on the stack pointer referring to a valid kernel stack.kernelvec pushes all 32 registers onto the stack, from which it will later restore them so thatthe interrupted kernel code can resume without disturbance.kernelvec saves the registers on the stack of the interrupted kernel thread, which makessense because the register values belong to that thread. This is particularly important if the trapcauses a switch to a different thread â€“ in that case the trap will actually return from the stack of thenew thread, leaving the interrupted threadâ€™s saved registers safely on its stack.kernelvec jumps to kerneltrap (kernel/trap.c:135) after saving registers. kerneltrapis prepared for two types of traps: device interrupts and exceptions. It calls devintr (kernel/-trap.c:185) to check for and handle the former. If the trap isnâ€™t a device interrupt, it must be anexception, and that is always a fatal error if it occurs in the xv6 kernel; the kernel calls panic andstops executing.If kerneltrap was called due to a timer interrupt, and a processâ€™s kernel thread is running(as opposed to a scheduler thread), kerneltrap calls yield to give other threads a chance torun. At some point one of those threads will yield, and let our thread and its kerneltrap resumeagain. Chapter 7 explains what happens in yield.When kerneltrapâ€™s work is done, it needs to return to whatever code was interruptedby the trap. Because a yield may have disturbed sepc and the previous mode in sstatus,kerneltrap saves them when it starts. It now restores those control registers and returns tokernelvec (kernel/kernelvec.S:38). kernelvec pops the saved registers from the stack and ex-ecutes sret, which copies sepc to pc and resumes the interrupted kernel code.Itâ€™s worth thinking through how the trap return happens if kerneltrap called yield due toa timer interrupt.Xv6 sets a CPUâ€™s stvec to kernelvec when that CPU enters the kernel from user space;you can see this in usertrap (kernel/trap.c:29). Thereâ€™s a window of time when the kernel hasstarted executing but stvec is still set to uservec, and itâ€™s crucial that no device interrupt occurduring that window. Luckily the RISC-V always disables interrupts when 4.6 Page-fault exceptions4.7 Real world4.8 Exercises","link":"/post/xv6-riscv-ch4.html"},{"title":"xv6-riscv_struct","text":"File structure of xv6-riscv 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475.â”œâ”€â”€ kernelâ”‚ â”œâ”€â”€ bio.câ”‚ â”œâ”€â”€ buf.hâ”‚ â”œâ”€â”€ console.câ”‚ â”œâ”€â”€ defs.hâ”‚ â”œâ”€â”€ elf.hâ”‚ â”œâ”€â”€ entry.Sâ”‚ â”œâ”€â”€ exec.câ”‚ â”œâ”€â”€ fcntl.hâ”‚ â”œâ”€â”€ file.câ”‚ â”œâ”€â”€ file.hâ”‚ â”œâ”€â”€ fs.câ”‚ â”œâ”€â”€ fs.hâ”‚ â”œâ”€â”€ kalloc.câ”‚ â”œâ”€â”€ kernel.ldâ”‚ â”œâ”€â”€ kernelvec.Sâ”‚ â”œâ”€â”€ log.câ”‚ â”œâ”€â”€ main.câ”‚ â”œâ”€â”€ memlayout.hâ”‚ â”œâ”€â”€ param.hâ”‚ â”œâ”€â”€ pipe.câ”‚ â”œâ”€â”€ plic.câ”‚ â”œâ”€â”€ printf.câ”‚ â”œâ”€â”€ proc.câ”‚ â”œâ”€â”€ proc.hâ”‚ â”œâ”€â”€ riscv.hâ”‚ â”œâ”€â”€ sleeplock.câ”‚ â”œâ”€â”€ sleeplock.hâ”‚ â”œâ”€â”€ spinlock.câ”‚ â”œâ”€â”€ spinlock.hâ”‚ â”œâ”€â”€ start.câ”‚ â”œâ”€â”€ stat.hâ”‚ â”œâ”€â”€ string.câ”‚ â”œâ”€â”€ swtch.Sâ”‚ â”œâ”€â”€ syscall.câ”‚ â”œâ”€â”€ syscall.hâ”‚ â”œâ”€â”€ sysfile.câ”‚ â”œâ”€â”€ sysproc.câ”‚ â”œâ”€â”€ trampoline.Sâ”‚ â”œâ”€â”€ trap.câ”‚ â”œâ”€â”€ types.hâ”‚ â”œâ”€â”€ uart.câ”‚ â”œâ”€â”€ virtio_disk.câ”‚ â”œâ”€â”€ virtio.hâ”‚ â””â”€â”€ vm.câ”œâ”€â”€ LICENSEâ”œâ”€â”€ Makefileâ”œâ”€â”€ mkfsâ”‚ â””â”€â”€ mkfs.câ”œâ”€â”€ READMEâ””â”€â”€ user â”œâ”€â”€ cat.c â”œâ”€â”€ echo.c â”œâ”€â”€ forktest.c â”œâ”€â”€ grep.c â”œâ”€â”€ grind.c â”œâ”€â”€ init.c â”œâ”€â”€ initcode.S â”œâ”€â”€ kill.c â”œâ”€â”€ ln.c â”œâ”€â”€ ls.c â”œâ”€â”€ mkdir.c â”œâ”€â”€ printf.c â”œâ”€â”€ rm.c â”œâ”€â”€ sh.c â”œâ”€â”€ stressfs.c â”œâ”€â”€ ulib.c â”œâ”€â”€ umalloc.c â”œâ”€â”€ user.h â”œâ”€â”€ user.ld â”œâ”€â”€ usertests.c â”œâ”€â”€ usys.pl â”œâ”€â”€ wc.c â””â”€â”€ zombie.c é€æ–‡ä»¶è¯¦ç»†è§£è¯»å®ƒä»¬çš„ä½œç”¨ã€é‡è¦æ€§ï¼š ğŸ§  æ•´ä½“ç»“æ„ ç›®å½•/æ–‡ä»¶ ä½œç”¨ å»ºè®®é‡ç‚¹å…³æ³¨ kernel/ xv6 æ ¸å¿ƒå®ç°ï¼Œå†…æ ¸æºç  âœ… å¿…çœ‹ user/ ç”¨æˆ·æ€ç¨‹åºã€æµ‹è¯•ç¨‹åºã€åº“ âœ… æ¨è mkfs/ æ„å»ºæ–‡ä»¶ç³»ç»Ÿé•œåƒå·¥å…· â—å¯é€‰ é¡¶å±‚æ„å»ºæ–‡ä»¶ Makefile, README, LICENSE ç­‰ ğŸ§© ç†Ÿæ‚‰ç»“æ„ç”¨ ğŸ“ kernel/ â€” xv6 çš„å¿ƒè„ï¼ˆé‡ç‚¹æ¨¡å—ï¼‰xv6 ä¸»è¦æ¨¡å—å¯åˆ†ä¸ºï¼š å†…æ ¸å¯åŠ¨ä¸å†…å­˜ç®¡ç†ï¼šentry.Sã€start.cã€vm.cã€kalloc.c ä¸­æ–­ã€å¼‚å¸¸ã€ç³»ç»Ÿè°ƒç”¨ï¼štrap.cã€syscall.cã€kernelvec.Sã€trampoline.S è¿›ç¨‹è°ƒåº¦ä¸ç®¡ç†ï¼šproc.cã€swtch.S æ–‡ä»¶ç³»ç»Ÿä¸æ–‡ä»¶æ¥å£ï¼šfs.cã€file.cã€bio.cã€log.c è®¾å¤‡é©±åŠ¨ï¼šuart.cã€console.cã€virtio_disk.cã€plic.c å†…æ ¸å·¥å…·ä»£ç ï¼šspinlock.cã€sleeplock.cã€printf.cã€string.c ğŸ§¾ æ–‡ä»¶çº§è¯¦ç»†è§£é‡Šï¼ˆæŒ‰å­ç³»ç»Ÿåˆ†ç±»ï¼‰ ğŸŸ© ä¸€ã€å†…æ ¸å¯åŠ¨ä¸å†…å­˜ç®¡ç† æ–‡ä»¶ ä½œç”¨ è¯´æ˜ entry.S æ ¸å¿ƒå¯åŠ¨æ±‡ç¼–å…¥å£ è®¾ç½®é¡µè¡¨ã€è·³è½¬åˆ° start() start.c C è¯­è¨€å…¥å£ main() å‰åšç¯å¢ƒåˆå§‹åŒ–ï¼ˆé¡µè¡¨ã€trapframeï¼‰ main.c å†…æ ¸ä¸»å‡½æ•° å¯åŠ¨å†…æ ¸æ¨¡å—ï¼Œå¦‚ userinit() kernel.ld å†…æ ¸é“¾æ¥è„šæœ¬ æŒ‡å®šå†…æ ¸æ®µåœ°å€ã€ç¬¦å·å¯¼å‡ºé¡ºåº vm.c è™šæ‹Ÿå†…å­˜ç³»ç»Ÿ é¡µè¡¨åˆ†é…ã€æ‹·è´ã€æ˜ å°„ï¼ˆåŸºäº Sv39ï¼‰ kalloc.c ç‰©ç†é¡µåˆ†é…å™¨ ç®¡ç†ç©ºé—²é¡µé“¾è¡¨ï¼Œç”¨äº allocuvm memlayout.h å†…å­˜å¸ƒå±€å® å®šä¹‰ KERNBASEã€PHYSTOP ç­‰å¸¸é‡ ğŸ“Œ å»ºè®®ä» entry.S â†’ start.c â†’ main.c â†’ userinit() è·‘ä¸€éæµç¨‹ã€‚ ğŸŸ¦ äºŒã€è¿›ç¨‹ç®¡ç†ä¸è°ƒåº¦ æ–‡ä»¶ ä½œç”¨ è¯´æ˜ proc.c ç®¡ç†è¿›ç¨‹è¡¨ã€fork/wait scheduler() æ˜¯è°ƒåº¦å™¨æ ¸å¿ƒ proc.h è¿›ç¨‹ç»“æ„ä½“å®šä¹‰ ç»“æ„ä½“ struct proc åŒ…å«é¡µè¡¨ã€çŠ¶æ€ã€trapframe swtch.S ä¸Šä¸‹æ–‡åˆ‡æ¢æ±‡ç¼– ä¿å­˜/æ¢å¤å¯„å­˜å™¨ï¼Œè°ƒåº¦å¿…ç”¨ trap.c trap/ä¸­æ–­å…¥å£ ç”¨æˆ· â†’ å†…æ ¸çš„æ€»å…¥å£ï¼›å¼‚å¸¸è°ƒåº¦ã€syscall éƒ½èµ°å®ƒ sysproc.c ä¸è¿›ç¨‹ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ sys_exitã€sys_forkã€sys_wait ğŸ“Œ å¼ºçƒˆå»ºè®®ï¼šç»™ fork()ã€scheduler()ã€yield() åŠ æ‰“å°è§‚å¯Ÿè¿è¡Œã€‚ ğŸŸ¨ ä¸‰ã€ç³»ç»Ÿè°ƒç”¨æœºåˆ¶ æ–‡ä»¶ ä½œç”¨ è¯´æ˜ syscall.c syscall åˆ†å‘å™¨ æ ¹æ® syscall num åˆ†å‘åˆ° sys_* syscall.h syscall ç¼–å· ç”¨ #define SYS_write 1 ç­‰æ˜ å°„ sysfile.c æ–‡ä»¶ç›¸å…³ syscall open/close/read/write çš„å†…æ ¸å®ç° usys.pl â†’ usys.S ç”¨æˆ·æ€ syscall åŒ…è£… ç”Ÿæˆç”¨æˆ·ä»£ç  mov a7, id; ecall ğŸ“Œ syscall æµç¨‹ = ç”¨æˆ·æ€ ecall â†’ trap â†’ syscall.c â†’ sys_*() ğŸŸ§ å››ã€æ–‡ä»¶ç³»ç»Ÿä¸ I/O æ¥å£ æ–‡ä»¶ ä½œç”¨ è¯´æ˜ fs.c inode å±‚ ialloc, readi, writeiï¼Œæ–‡ä»¶æ ¸å¿ƒç»“æ„ fs.h inode å®šä¹‰ struct inodeï¼Œå—åœ°å€ä¿¡æ¯ç­‰ file.c æ–‡ä»¶æè¿°ç¬¦å±‚ struct fileï¼Œç®¡ç† open/close ç­‰ file.h æ–‡ä»¶æè¿°ç¬¦å®šä¹‰ æ”¯æŒ pipe/dev/inode ç­‰ç±»å‹ bio.c ç¼“å­˜å—è¯»å†™ å®ç° block çº§è¯»å†™ç¼“å­˜ log.c æ—¥å¿—æœºåˆ¶ crash-safe å†™æ“ä½œäº‹åŠ¡ï¼ˆwrite-ahead loggingï¼‰ pipe.c ç®¡é“å®ç° å†…å­˜ä¸­åŒå‘ FIFO fcntl.h, stat.h POSIX ç›¸å…³å¤´æ–‡ä»¶ ç”¨äº open flagã€stat ç»“æ„ä½“ ğŸ“Œ å»ºè®®è°ƒè¯• fs.c çš„ namei()ã€dirlookup()ï¼Œçœ‹è·¯å¾„å¦‚ä½•è¢«è§£æã€‚ ğŸŸ¥ äº”ã€è®¾å¤‡é©±åŠ¨ä¸ä¸­æ–­æ§åˆ¶ æ–‡ä»¶ ä½œç”¨ è¯´æ˜ uart.c ä¸²å£é©±åŠ¨ åˆå§‹åŒ–ä¸²å£ï¼Œå†™å…¥å­—ç¬¦ç»™ç»ˆç«¯ console.c æ§åˆ¶å° I/O ä¸ UART é…åˆå®ç° shell è¾“å…¥è¾“å‡º plic.c ä¸­æ–­æ§åˆ¶å™¨ Platform-Level Interrupt Controller virtio_disk.c è™šæ‹Ÿç£ç›˜é©±åŠ¨ QEMU è™šæ‹Ÿç£ç›˜ç¡¬ä»¶è®¿é—®å±‚ virtio.h virtio è®¾å¤‡å®šä¹‰ é…å¥—æ•°æ®ç»“æ„ ğŸ“Œ virtio_disk.c è°ƒè¯•æ–¹æ³•ï¼šè§‚å¯Ÿ virtio_rw() å®ç°çš„è¯»å†™é€»è¾‘ã€‚ ğŸŸ« å…­ã€å·¥å…·ç±» / å†…æ ¸åº“å‡½æ•° æ–‡ä»¶ ä½œç”¨ è¯´æ˜ defs.h å†…æ ¸å‡½æ•°å£°æ˜ extern æ‰€æœ‰æ¨¡å—å‡½æ•°ï¼Œä¾›å…¨å±€ä½¿ç”¨ riscv.h RISC-V CSR å®ã€å¯„å­˜å™¨å®šä¹‰ åŒ…å« rdtime, csrr, sstatus ç­‰ spinlock.c/.h è‡ªæ—‹é”å®ç° æ ¸å¿ƒäº’æ–¥æœºåˆ¶ï¼Œéœ€å…³ä¸­æ–­ sleeplock.c/.h ç¡çœ é”å®ç° ç”¨äºæ–‡ä»¶ç³»ç»Ÿï¼Œsleep/wakeup ç®¡ç† string.c libc å®ç° memcpy, strlen ç­‰å†…æ ¸è‡ªå¸¦å‡½æ•° printf.c å†…æ ¸çº§ printf ç”¨äºè°ƒè¯•æ‰“å°ï¼Œæ— ç¼“å†²ç‰ˆ param.h ç³»ç»Ÿå‚æ•°å® å®šä¹‰ NPROC, MAXPATH ç­‰å…¨å±€å‚æ•° types.h å¸¸ç”¨ç±»å‹å®šä¹‰ uchar, uint, sint ç­‰ç®€å†™ ğŸ“Œ å¸¸ç”¨ grep å‘½ä»¤ï¼šgrep -rn &quot;spin_lock&quot; kernel/ è¿½è¸ªå¹¶å‘ç‚¹ ğŸ“ user/ â€” ç”¨æˆ·æ€ç¨‹åºä¸æµ‹è¯• æ–‡ä»¶ ä½œç”¨ è¯´æ˜ *.c å‘½ä»¤ç¨‹åº shell å‘½ä»¤å¦‚ ls, cat, echo, sh ç­‰ init.c é¦–ä¸ªç”¨æˆ·è¿›ç¨‹ userinit() å¯åŠ¨çš„ç¨‹åºï¼Œè¿è¡Œ /init initcode.S æœ€åŸå§‹çš„ç”¨æˆ·æ€ä»£ç  ç”± userinit() è½½å…¥çš„ç¨‹åºï¼ˆæ±‡ç¼–ï¼‰ ulib.c libc å‡½æ•° ç”¨æˆ·æ€çš„ malloc, printf ç­‰ umalloc.c malloc å®ç° ç”¨æˆ·æ€å †åˆ†é… usertests.c ç”¨æˆ·æ€æµ‹è¯•é›† æµ‹è¯• syscallã€è¿›ç¨‹ã€æ–‡ä»¶åŠŸèƒ½ user.ld ç”¨æˆ·æ€é“¾æ¥è„šæœ¬ æ§åˆ¶ç”¨æˆ·ç¨‹åºçš„æ®µåˆ†å¸ƒ user.h å‡½æ•°å£°æ˜ ä¾›ç”¨æˆ·ç¨‹åºå¼•ç”¨ printf, fork ç­‰æ¥å£ ğŸ“Œ å¼ºçƒˆæ¨èä½ ä» init.c å¼€å§‹ debugï¼Œç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹çš„è¿è¡Œå…³é”®è·¯å¾„ï¼ ğŸ“ mkfs/ â€” æ„å»ºæ–‡ä»¶ç³»ç»Ÿé•œåƒå·¥å…· æ–‡ä»¶ è¯´æ˜ mkfs.c æ„å»º xv6 æ–‡ä»¶ç³»ç»Ÿé•œåƒï¼ˆuser/init ç­‰æ–‡ä»¶å‹å…¥ï¼‰ ğŸ“Œ ä¸çœ‹ä¹Ÿæ— å¦¨ï¼Œç”¨äº make é˜¶æ®µæ„å»º fs.img ğŸ“„ é¡¶å±‚æ–‡ä»¶ æ–‡ä»¶ è¯´æ˜ Makefile ç¼–è¯‘å…¥å£ï¼Œæ„å»º kernel, fs.img, qemu ç­‰ README ç®€è¦è¯´æ˜æ–‡æ¡£ï¼Œè®²è§£å¦‚ä½•ä½¿ç”¨ LICENSE æˆæƒæ¡æ¬¾ï¼ˆMITï¼‰ âœ… æ€»ç»“ ç”¨ æ¨¡å—åŒ–æ€ç»´ åˆ†é˜¶æ®µå­¦ï¼Œæ¯”å¦‚ â€œå…ˆæŠŠ trap ç†æ¸…æ¥šâ€ï¼Œå†çœ‹ syscallã€‚ æ¨èæ­é…å¦‚ä¸‹å·¥å…·ï¼š tmux zsh grepâ€¦","link":"/post/xv6-riscv-struct.html"},{"title":"xv6-riscv_ch3","text":"This chapter covers the fundamental concepts of paging hardware, memory allocation, and process address space management, including practical code implementations like creating address spaces, physical memory allocation, and process management functions such as sbrk and exec. ch3: Page tables Page tables are the most popular mechanism through which the operating system provides each process with its own private address space and memory. Xv6 performs a few tricks: mapping the same memory (a trampoline page) in several address spaces, and guarding kernel and user stacks with an unmapped page. The rest of this chapter explains the page tables that the RISC-V hardware provides and how xv6 uses them. 3.1 Paging hardware As a reminder, RISC-V instructions (both user and kernel) manipulate virtual addresses. The machineâ€™s RAM, or physical memory, is indexed with physical addresses. The RISC-V page table hardware connects these two kinds of addresses, by mapping each virtual address to a physical address. Xv6 runs on Sv39 RISC-V, which means that only the bottom 39 bits of a 64-bit virtual address are used; the top 25 bits are not used. In this Sv39 configuration, a RISC-V page table is logically an array of 227 (134,217,728) page table entries (PTEs). Each PTE contains a 44-bit physical page number (PPN) and some flags. The paging hardware translates a virtual address by using the top 27 bits of the 39 bits to index into the page table to find a PTE, and making a 56-bit physical address whose top 44 bits come from the PPN in the PTE and whose bottom 12 bits are copied from the original virtual address. Figure 3.1 shows this process with a logical view of the page table as a simple array of PTEs (see Figure 3.2 for a fuller story). A page table gives the operating system control over virtual-to-physical address translations at the granularity of aligned chunks of 4096 (212 ) bytes. Such a chunk is called a page. In Sv39 RISC-V, the top 25 bits of a virtual address are not used for translation. The physicaladdress also has room for growth: there is room in the PTE format for the physical page numberto grow by another 10 bits. The designers of RISC-V chose these numbers based on technologypredictions. 239 bytes is 512 GB, which should be enough address space for applications running on RISC-V computers. 256 is enough physical memory space for the near future to fit many I/Odevices and RAM chips. If more is needed, the RISC-V designers have defined Sv48 with 48-bitvirtual addresses [3]. As Figure 3.2 shows, a RISC-V CPU translates a virtual address into a physical in three steps.A page table is stored in physical memory as a three-level tree. The root of the tree is a 4096-bytepage-table page that contains 512 PTEs, which contain the physical addresses for page-table pagesin the next level of the tree. Each of those pages contains 512 PTEs for the final level in the tree.The paging hardware uses the top 9 bits of the 27 bits to select a PTE in the root page-table page,the middle 9 bits to select a PTE in a page-table page in the next level of the tree, and the bottom9 bits to select the final PTE. (In Sv48 RISC-V a page table has four levels, and bits 39 through 47of a virtual address index into the top-level.)If any of the three PTEs required to translate an address is not present, the paging hardwareraises a page-fault exception, leaving it up to the kernel to handle the exception (see Chapter 4).The three-level structure of Figure 3.2 allows a memory-efficient way of recording PTEs, com-pared to the single-level design of Figure 3.1. In the common case in which large ranges of virtualaddresses have no mappings, the three-level structure can omit entire page directories. For exam-ple, if an application uses only a few pages starting at address zero, then the entries 1 through 511of the top-level page directory are invalid, and the kernel doesnâ€™t have to allocate pages those for511 intermediate page directories. Furthermore, the kernel also doesnâ€™t have to allocate pages forthe bottom-level page directories for those 511 intermediate page directories. So, in this example,the three-level design saves 511 pages for intermediate page directories and 511 Ã— 512 pages forbottom-level page directories.Although a CPU walks the three-level structure in hardware as part of executing a load or storeinstruction, a potential downside of three levels is that the CPU must load three PTEs from memoryto perform the translation of the virtual address in the load/store instruction to a physical address.To avoid the cost of loading PTEs from physical memory, a RISC-V CPU caches page table entriesin a Translation Look-aside Buffer (TLB).allowed to be used. PTE_V indicates whether the PTE is present: if it is not set, a reference to thepage causes an exception (i.e., is not allowed). PTE_R controls whether instructions are allowedto read to the page. PTE_W controls whether instructions are allowed to write to the page. PTE_Xcontrols whether the CPU may interpret the content of the page as instructions and execute them.PTE_U controls whether instructions in user mode are allowed to access the page; if PTE_U is notset, the PTE can be used only in supervisor mode. Figure 3.2 shows how it all works. The flags andall other page hardware-related structures are defined in (kernel/riscv.h) To tell a CPU to use a page table, the kernel must write the physical address of the root page-table page into the satp register. A CPU will translate all addresses generated by subsequentinstructions using the page table pointed to by its own satp. Each CPU has its own satp so thatdifferent CPUs can run different processes, each with a private address space described by its ownpage table. notice:A few notes about terms used in this book. Physical memory refers to storage cells in RAM.A byte of physical memory has an address, called a physical address. Instructions that dereferenceaddresses (such as loads, stores, jumps, and function calls) use only virtual addresses, which thepaging hardware translates to physical addresses, and then sends to the RAM hardware to read orwrite storage. An address space is the set of virtual addresses that are valid in a given page table; each xv6 process has a separate user address space, and the xv6 kernel has its own address space aswell. User memory refers to a processâ€™s user address space plus the physical memory that the pagetable allows the process to access. Virtual memory refers to the ideas and techniques associatedwith managing page tables and using them to achieve goals such as isolation. 3.2 Kernel address space Xv6 maintains one page table per process, describing each processâ€™s user address space, plus a sin-gle page table that describes the kernelâ€™s address space. The kernel configures the layout of its ad-dress space to give itself access to physical memory and various hardware resources at predictable virtual addresses. Figure 3.3 shows how this layout maps kernel virtual addresses to physical addresses. The file (kernel/memlayout.h) declares the constants for xv6â€™s kernel memory layout. The kernel gets at RAM and memory-mapped device registers using â€œdirect mapping;â€ thatis, mapping the resources at virtual addresses that are equal to the physical address. For example,the kernel itself is located at KERNBASE=0x80000000 in both the virtual address space and inphysical memory. Direct mapping simplifies kernel code that reads or writes physical memory. There are a couple of kernel virtual addresses that arenâ€™t direct-mapped: The trampoline page. It is mapped at the top of the virtual address space; user page tables have this same mapping. Chapter 4 discusses the role of the trampoline page, but we see here an interesting use case of page tables; a physical page (holding the trampoline code) is mapped twice in the virtual address space of the kernel: once at top of the virtual address space and once with a direct mapping. The kernel stack pages. Each process has its own kernel stack, which is mapped high so that below it xv6 can leave an unmapped guard page. The guard pageâ€™s PTE is invalid (i.e., PTE_V is not set), so that if the kernel overflows a kernel stack, it will likely cause an exception and the kernel will panic. Without a guard page an overflowing stack would overwrite other kernel memory, resulting in incorrect operation. A panic crash is preferable. 3.3 Code: creating an address space Most of the xv6 code for manipulating address spaces and page tables resides in vm.c (kernel/vm.c:1). The central data structure is pagetable_t, which is really a pointer to a RISC-V root page-table page; a pagetable_t may be either the kernel page table, or one of the per-process page tables. The central functions are walk, which finds the PTE for a virtual address,and mappages, which installs PTEs for new mappings. Functions starting with kvm manipulate the kernel page table; functions starting with uvm manipulate a user page table; other functions are used for both. copyout and copyin copy data to and from user virtual addresses provided as system call arguments; they are in vm.c because they need to explicitly translate those addresses in order to find the corresponding physical memory. Early in the boot sequence, main calls kvminit (kernel/vm.c:54) to create the kernelâ€™s page ta-ble using kvmmake (kernel/vm.c:20). This call occurs before xv6 has enabled paging on the RISC-V,so addresses refer directly to physical memory. kvmmake first allocates a page of physical mem-ory to hold the root page-table page. Then it calls kvmmap to install the translations that the kernelneeds. The translations include the kernelâ€™s instructions and data, physical memory up to PHYSTOP,and memory ranges which are actually devices. proc_mapstacks (kernel/proc.c:33) allocates akernel stack for each process. It calls kvmmap to map each stack at the virtual address generatedby KSTACK, which leaves room for the invalid stack-guard pages. kvmmap (kernel/vm.c:132) calls mappages (kernel/vm.c:144), which installs mappings into apage table for a range of virtual addresses to a corresponding range of physical addresses. It doesthis separately for each virtual address in the range, at page intervals. For each virtual address tobe mapped, mappages calls walk to find the address of the PTE for that address. It then initializesthe PTE to hold the relevant physical page number, the desired permissions (PTE_W, PTE_X, and/orPTE_R), and PTE_V to mark the PTE as valid (kernel/vm.c:165). walk (kernel/vm.c:86) mimics the RISC-V paging hardware as it looks up the PTE for a virtualaddress (see Figure 3.2). walk descends the page table one level at a time, using each levelâ€™s 9bits of virtual address to index into the relevant page directory page. At each level it finds eitherthe PTE of the next levelâ€™s page directory page, or the PTE of final page (kernel/vm.c:92). If a PTEin a first or second level page directory page isnâ€™t valid, then the required directory page hasnâ€™tyet been allocated; if the alloc argument is set, walk allocates a new page-table page and putsits physical address in the PTE. It returns the address of the PTE in the lowest layer in the tree(kernel/vm.c:102). main calls kvminithart (kernel/vm.c:62) to install the kernel page table. It writes the physicaladdress of the root page-table page into the register satp. After this the CPU will translate ad-dresses using the kernel page table. Since the kernel uses a direct mapping, the now virtual addressof the next instruction will map to the right physical memory address. Each RISC-V CPU caches page table entries in a Translation Look-aside Buffer (TLB), andwhen xv6 changes a page table, it must tell the CPU to invalidate corresponding cached TLBentries. If it didnâ€™t, then at some point later the TLB might use an old cached mapping, point-ing to a physical page that in the meantime has been allocated to another process, and as a re-sult, a process might be able to scribble on some other processâ€™s memory. The RISC-V has an instruction sfence.vma that flushes the current CPUâ€™s TLB. Xv6 executes sfence.vma inkvminithart after reloading the satp register, and in the trampoline code that switches to auser page table before returning to user space (kernel/trampoline.S:89).It is also necessary to issue sfence.vma before changing satp, in order to wait for comple-tion of all outstanding loads and stores. This wait ensures that preceding updates to the page tablehave completed, and ensures that preceding loads and stores use the old page table, not the newone.To avoid flushing the complete TLB, RISC-V CPUs may support address space identifiers(ASIDs) [3]. The kernel can then flush just the TLB entries for a particular address space. Xv6does not use this feature. 3.4 Physical memory allocation The kernel must allocate and free physical memory at run-time for page tables, user memory,kernel stacks, and pipe buffers. Xv6 uses the physical memory between the end of the kernel and PHYSTOP for run-time alloca-tion. It allocates and frees whole 4096-byte pages at a time. It keeps track of which pages are freeby threading a linked list through the pages themselves. Allocation consists of removing a pagefrom the linked list; freeing consists of adding the freed page to the list. 3.5 Code: Physical memory allocator The allocator resides in kalloc.c (kernel/kalloc.c:1). The allocatorâ€™s data structure is a free listof physical memory pages that are available for allocation. Each free pageâ€™s list element is astruct run (kernel/kalloc.c:17). Where does the allocator get the memory to hold that data struc-ture? It store each free pageâ€™s run structure in the free page itself, since thereâ€™s nothing else storedthere. The free list is protected by a spin lock (kernel/kalloc.c:21-24). The list and the lock arewrapped in a struct to make clear that the lock protects the fields in the struct. For now, ignore thelock and the calls to acquire and release; Chapter 6 will examine locking in detail.The function main calls kinit to initialize the allocator (kernel/kalloc.c:27). kinit initializesthe free list to hold every page between the end of the kernel and PHYSTOP. Xv6 ought to de-termine how much physical memory is available by parsing configuration information providedby the hardware. Instead xv6 assumes that the machine has 128 megabytes of RAM. kinit callsfreerange to add memory to the free list via per-page calls to kfree. A PTE can only refer toa physical address that is aligned on a 4096-byte boundary (is a multiple of 4096), so freerangeuses PGROUNDUP to ensure that it frees only aligned physical addresses. The allocator starts withno memory; these calls to kfree give it some to manage.The allocator sometimes treats addresses as integers in order to perform arithmetic on them(e.g., traversing all pages in freerange), and sometimes uses addresses as pointers to read andwrite memory (e.g., manipulating the run structure stored in each page); this dual use of addressesis the main reason that the allocator code is full of C type casts.The function kfree (kernel/kalloc.c:47) begins by setting every byte in the memory being freedto the value 1. This will cause code that uses memory after freeing it (uses â€œdangling referencesâ€)to read garbage instead of the old valid contents; hopefully that will cause such code to break faster.Then kfree prepends the page to the free list: it casts pa to a pointer to struct run, records theold start of the free list in r-&gt;next, and sets the free list equal to r. kalloc removes and returnsthe first element in the free list. 3.6 Process address space Each process has its own page table, and when xv6 switches between processes, it also changespage tables. Figure 3.4 shows a processâ€™s address space in more detail than Figure 2.3. A processâ€™suser memory starts at virtual address zero and can grow up to MAXVA (kernel/riscv.h:375), allowinga process to address in principle 256 Gigabytes of memory.A processâ€™s address space consists of pages that contain the text of the program (which xv6maps with the permissions PTE_R, PTE_X, and PTE_U), pages that contain the pre-initialized dataof the program, a page for the stack, and pages for the heap. Xv6 maps the data, stack, and heapwith the permissions PTE_R, PTE_W, and PTE_U.Using permissions within a user address space is a common technique to harden a user process.If the text were mapped with PTE_W, then a process could accidentally modify its own program;for example, a programming error may cause the program to write to a null pointer, modifyinginstructions at address 0, and then continue running, perhaps creating more havoc. To detect sucherrors immediately, xv6 maps the text without PTE_W; if a program accidentally attempts to storeto address 0, the hardware will refuse to execute the store and raises a page fault (see Section 4.6).The kernel then kills the process and prints out an informative message so that the developer cantrack down the problem.Similarly, by mapping data without PTE_X, a user program cannot accidentally jump to anaddress in the programâ€™s data and start executing at that address.In the real world, hardening a process by setting permissions carefully also aids in defendingagainst security attacks. An adversary may feed carefully-constructed input to a program (e.g., aWeb server) that triggers a bug in the program in the hope of turning that bug into an exploit [14].Setting permissions carefully and other techniques, such as randomizing of the layout of the useraddress space, make such attacks harder.The stack is a single page, and is shown with the initial contents as created by exec. Stringscontaining the command-line arguments, as well as an array of pointers to them, are at the verytop of the stack. Just under that are values that allow a program to start at main as if the functionmain(argc, argv) had just been called.To detect a user stack overflowing the allocated stack memory, xv6 places an inaccessible guardpage right below the stack by clearing the PTE_U flag. If the user stack overflows and the processtries to use an address below the stack, the hardware will generate a page-fault exception becausethe guard page is inaccessible to a program running in user mode. A real-world operating systemmight instead automatically allocate more memory for the user stack when it overflows.When a process asks xv6 for more user memory, xv6 grows the processâ€™s heap. Xv6 first uses kalloc to allocate physical pages. It then adds PTEs to the processâ€™s page table that point to thenew physical pages. Xv6 sets the PTE_W, PTE_R, PTE_U, and PTE_V flags in these PTEs. Mostprocesses do not use the entire user address space; xv6 leaves PTE_V clear in unused PTEs.We see here a few nice examples of use of page tables. First, different processesâ€™ page tablestranslate user addresses to different pages of physical memory, so that each process has private usermemory. Second, each process sees its memory as having contiguous virtual addresses starting atzero, while the processâ€™s physical memory can be non-contiguous. Third, the kernel maps a pagewith trampoline code at the top of the user address space (without PTE_U), thus a single page ofphysical memory shows up in all address spaces, but can be used only by the kernel. 3.7 Code: sbrk sbrk is the system call for a process to shrink or grow its memory. The system call is implementedby the function growproc (kernel/proc.c:260). growproc calls uvmalloc or uvmdealloc, de-pending on whether n is positive or negative. uvmalloc (kernel/vm.c:233) allocates physical mem-ory with kalloc, zeros the allocated memory, and adds PTEs to the user page table with mappages.uvmdealloc calls uvmunmap (kernel/vm.c:178), which uses walk to find PTEs and kfree tofree the physical memory they refer to.Xv6 uses a processâ€™s page table not just to tell the hardware how to map user virtual addresses, but also as the only record of which physical memory pages are allocated to that process. That is the reason why freeing user memory (in uvmunmap) requires examination of the user page table. 3.8 Code: exec A binary is typically the output of the compiler and linker, and holdsmachine instructions and program data. exec (kernel/exec.c:23) opens the named binary path usingnamei (kernel/exec.c:36), which is explained in Chapter 8. Then, it reads the ELF header. Xv6binaries are formatted in the widely-used ELF format, defined in (kernel/elf.h). An ELF binaryconsists of an ELF header, struct elfhdr (kernel/elf.h:6), followed by a sequence of programsection headers, struct proghdr (kernel/elf.h:25). Each progvhdr describes a section of theapplication that must be loaded into memory; xv6 programs have two program section headers:one for instructions and one for data.The first step is a quick check that the file probably contains an ELF binary. An ELF binarystarts with the four-byte â€œmagic numberâ€ 0x7F, â€˜Eâ€™, â€˜Lâ€™, â€˜Fâ€™, or ELF_MAGIC (kernel/elf.h:3). Ifthe ELF header has the right magic number, exec assumes that the binary is well-formed.exec allocates a new page table with no user mappings with proc_pagetable (kernel/exec.c:49),allocates memory for each ELF segment with uvmalloc (kernel/exec.c:65), and loads each segmentinto memory with loadseg (kernel/exec.c:10). loadseg uses walkaddr to find the physical ad-dress of the allocated memory at which to write each page of the ELF segment, and readi to readfrom the file. The program section header for /init, the first user program created with exec, looks like this: 12345678910111213141516# objdump -p user/_init# å‘Šè¯‰æ“ä½œç³»ç»Ÿå¦‚ä½•å°†æ–‡ä»¶çš„å„ä¸ªæ®µï¼ˆsegmentï¼‰åŠ è½½åˆ°å†…å­˜ä¸­å»æ‰§è¡Œuser/_init: file format elf64-littleProgram Header:0x70000003 off 0x0000000000006bb0 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**0 filesz 0x000000000000004a memsz 0x0000000000000000 flags r--LOAD off 0x0000000000001000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**12 filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-xLOAD off 0x0000000000002000 vaddr 0x0000000000001000 paddr 0x0000000000001000 align 2**12 filesz 0x0000000000000010 memsz 0x0000000000000030 flags rw-STACK off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4 filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw- The output of objdump -p shows the Program Header Table of an ELF (Executable and Linkable Format) file. This is a crucial part of the ELF file, telling the operating system how to load each segment into memory for execution. ğŸŒŸ Explanation of ELF Program Header fields â€” each segment corresponds to the following fields: Field Meaning off Byte offset of the segment in the file, counted from the beginning. vaddr Virtual address of the segment in memory. paddr Physical address â€” usually ignored by modern OSes. align Alignment requirement; the segment must be aligned to this (often a page size). filesz Size of the segment in the file (in bytes). loadseg reads this many bytes. memsz Total size the segment occupies in memory after loading (may be larger than in the file, e.g., for bss). flags Permission flags: r (read), w (write), x (execute). type Segment type (e.g., LOAD, STACK, NOTE, DYNAMIC, etc.). align Memory alignment requirement. 4 Program Headers (Segments):1. First Segment: Type 0x70000003 (non-standard) 1230x70000003 off 0x0000000000006bb0 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**0 filesz 0x000000000000004a memsz 0x0000000000000000 flags r-- type=0x70000003 is processor-specific and non-standard â€” generally ignored by developers. off=0x6bb0 â€” the offset within the file. filesz=0x4a â€” 74 bytes of data. memsz=0x0 â€” although there is data in the file, nothing is loaded into memory (e.g., debug info, notes). This is typically metadata, not code or data. 2. Second Segment: The actual code segment (text segment) 123LOAD off 0x0000000000001000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**12 filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x Type: LOAD â€” to be loaded into memory. off=0x1000 â€” loading starts from offset 0x1000 in the file. vaddr=0x0 â€” to be loaded at virtual address 0x0 (important). filesz = memsz = 0x1000 â€” both file and memory size are 4KB. flags=r-x â€” readable and executable. Indicates this is the code segment. ğŸ”‘ This segment contains program instructions (text segment), and exec/loadseg will load it into memory at 0x0. 3. Third Segment: Data segment 123LOAD off 0x0000000000002000 vaddr 0x0000000000001000 paddr 0x0000000000001000 align 2**12 filesz 0x0000000000000010 memsz 0x0000000000000030 flags rw- Type: LOAD â€” also needs to be loaded. File offset: 0x2000 Virtual address: 0x1000 filesz = 0x10, memsz = 0x30 â€” 16 bytes from file, the rest is BSS (needs to be zero-initialized). flags = rw- â€” read/write permission, indicates this is a data segment. ğŸ”‘ This segment holds global variables â€” part comes from the file, the rest is zeroed out by memset or page initialization. 4. Fourth Segment: Stack segment 123STACK off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4 filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw- Type: STACK â€” indicates a stack segment. Usually has no actual content; the stack is manually allocated by the kernel (not loaded from ELF). This is just a marker indicating that the ELF expects a stack. ğŸ”§ Main points in how exec loads ELF in xv6 ELF segment loading Each segment (like .text, .data) specifies a vaddr (virtual address). The kernel reads filesz bytes from the file offset and loads them into memory at vaddr. If memsz &gt; filesz, the remaining space (like .bss) must be zero-initialized. User stack initialization One page of memory is allocated for the user stack; the top stores the argument strings. A â€œguard pageâ€ is placed below the stack and made inaccessible. Arguments are passed to main() via a0 (argc) and a1 (argv). Security checks A malicious ELF file could attempt to set dangerous vaddr values or trigger integer overflows. xv6 performs checks, such as preventing vaddr + memsz overflows. On RISC-V, xv6 uses separate page tables for user and kernel space to prevent interference. ELF loading steps (in exec) The kernel reads the ELF header and locates the Program Headers. For each LOAD-type segment: It calls uvmalloc to allocate memory from vaddr to vaddr + memsz. It uses loadseg to read filesz bytes from the file into that memory. If memsz &gt; filesz, the remaining bytes are cleared to zero. Finally, it creates the user stack, sets up the trap frame and arguments, and jumps to user mode for execution. 3.9 Real world Xv6 is simplified by the kernelâ€™s use of a direct map between virtual and physical addresses, andby its assumption that there is physical RAM at address 0x80000000, where the kernel expects tobe loaded. This works with QEMU, but on real hardware it turns out to be a bad idea; real hardwareplaces RAM and devices at unpredictable physical addresses, so that (for example) there might beno RAM at 0x80000000, where xv6 expect to be able to store the kernel. More serious kerneldesigns exploit the page table to turn arbitrary hardware physical memory layouts into predictablekernel virtual address layouts. RISC-V supports protection at the level of physical addresses, but xv6 doesnâ€™t use that feature. On machines with lots of memory it might make sense to use RISC-Vâ€™s support for â€œsuperpages.â€ Small pages make sense when physical memory is small, to allow allocation and page-outto disk with fine granularity. For example, if a program uses only 8 kilobytes of memory, givingit a whole 4-megabyte super-page of physical memory is wasteful. Larger pages make sense onmachines with lots of RAM, and may reduce overhead for page-table manipulation. The xv6 kernelâ€™s lack of a malloc-like allocator that can provide memory for small objectsprevents the kernel from using sophisticated data structures that would require dynamic allocation.A more elaborate kernel would likely allocate many different sizes of small blocks, rather than (asin xv6) just 4096-byte blocks; a real kernel allocator would need to handle small allocations aswell as large ones.","link":"/post/xv6-riscv-ch3.html"}],"tags":[{"name":"Trace","slug":"Trace","link":"/tags/Trace/"},{"name":"riscv","slug":"riscv","link":"/tags/riscv/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"riscv-toolchain","slug":"riscv-toolchain","link":"/tags/riscv-toolchain/"},{"name":"xv6-riscv","slug":"xv6-riscv","link":"/tags/xv6-riscv/"},{"name":"linux-dirvers","slug":"linux-dirvers","link":"/tags/linux-dirvers/"}],"categories":[],"pages":[{"title":"","text":"Troy's Blog >>> æ¬¢è¿äº¤æ¢å‹é“¾~ è¯·é€šè¿‡é‚®ä»¶è”ç³»æˆ‘ã€‚","link":"/friend/index.html"}]}
{"posts":[{"title":"xv6-riscv_PLAN","text":"How do you learn in 12 hours? from chatgpt, but I do it. ğŸ• ç¬¬ 1 é˜¶æ®µï¼šxv6 æ˜¯æ€ä¹ˆâ€œæ´»â€èµ·æ¥çš„ï¼ˆ0â€“2hï¼‰â¬› ç¬¬0ç« ï¼šxv6 overview ï¼ˆPDFå¼€å¤´ï¼‰å­¦ä¹ ç›®æ ‡ï¼šå¤§è‡´çŸ¥é“ xv6 æœ‰å“ªäº›æ¨¡å—ï¼Œè°ƒç”¨å›¾ æ–¹æ³•ï¼šé€šè¯»ç›®å½•ï¼Œç†è§£å®ƒçš„å­ç³»ç»Ÿåˆ’åˆ†ã€è¿›ç¨‹å›¾ â¬› ç¬¬1ç« ï¼šå¯åŠ¨ä¸ç”¨æˆ·æ€æ–‡ä»¶ï¼škernel/entry.S, kernel/start.c, kernel/main.cè·¯å¾„ï¼šQEMU â†’ bootloader â†’ å†…æ ¸ â†’ main â†’ userinit() é‡ç‚¹ç†è§£ï¼š entry.S ä½œç”¨ï¼ˆè®¾ç½® satpã€spã€mretï¼‰ kvminit / kvmmap / kvminithart å¦‚ä½•è®¾ç½®é¡µè¡¨ userinit() å¦‚ä½•è®¾ç½®ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼ˆinitprocï¼‰ âœ… å»ºè®®æ“ä½œï¼š ç»™ start.c å’Œ main.c æ‰“æ—¥å¿—ï¼Œè§‚å¯Ÿ kvminitã€procinit è°ƒç”¨é¡ºåºã€‚ ğŸ•’ ç¬¬ 2 é˜¶æ®µï¼šè¿›ç¨‹ç®¡ç†å’Œç³»ç»Ÿè°ƒç”¨ï¼ˆ2â€“5hï¼‰â¬› ç¬¬2ç« ï¼šè¿›ç¨‹ç®¡ç†ï¼ˆé‡ç‚¹ï¼‰æ–‡ä»¶ï¼škernel/proc.c, kernel/proc.h å…³é”®ç‚¹ï¼š allocproc, fork, scheduler, yield, exit, wait è¿›ç¨‹çŠ¶æ€ enum procstate çš„æµè½¬å›¾ï¼ˆNEW â†’ RUNNABLE â†’ RUNNING â†’ ZOMBIEï¼‰ âœ… å»ºè®®æ“ä½œï¼š ç”¨ ps ç±»ä¼¼å‘½ä»¤éªŒè¯çŠ¶æ€ æ‰‹åŠ¨ä¿®æ”¹ user/test.c å¢åŠ  fork å’Œ wait â¬› ç¬¬3ç« ï¼šç³»ç»Ÿè°ƒç”¨æœºåˆ¶æ–‡ä»¶ï¼škernel/syscall.c, kernel/trap.c, user/usys.S æµç¨‹ï¼šç”¨æˆ·æ€ â†’ ecall â†’ trap â†’ syscall() â†’ sys_*() âœ… å»ºè®®æ“ä½œï¼š æ‰“æ—¥å¿—çœ‹ syscall number ä¼ å…¥è·¯å¾„ è¿½è¸ª sys_write æ˜¯å¦‚ä½•è°ƒç”¨åˆ° filewrite ğŸ•“ ç¬¬ 3 é˜¶æ®µï¼šå†…å­˜ç®¡ç†ï¼ˆ5â€“7hï¼‰â¬› ç¬¬4ç« ï¼šå†…å­˜å­ç³»ç»Ÿæ–‡ä»¶ï¼škernel/vm.c, kernel/kalloc.c, kernel/defs.h é‡ç‚¹å‡½æ•°ï¼š allocuvm, deallocuvm, uvmcopy walk, mappagesï¼Œé¡µè¡¨ç»“æ„ Sv39 âœ… å­¦ä¹ æ–¹æ³•ï¼š ç”»å›¾ï¼šSv39 ä¸‰çº§é¡µè¡¨çš„ index æ˜¯æ€ä¹ˆåˆ’åˆ†çš„ ä½¿ç”¨ make qemu-gdb ä¸­æ–­åœ¨ uvmcopy çœ‹é¡µè¡¨ ğŸ•” ç¬¬ 4 é˜¶æ®µï¼šI/O + æ–‡ä»¶ç³»ç»Ÿï¼ˆ7â€“9hï¼‰â¬› ç¬¬5ç« ï¼šæ–‡ä»¶ç³»ç»Ÿæ–‡ä»¶ï¼šfs.c, file.c, bio.c, log.c å…³é”®ç†è§£ï¼š inodeã€ç›®å½•é¡¹ã€open/file ç»“æ„ä½“ file-&gt;ip-&gt;dev-&gt;read() ç­‰å±‚çº§è°ƒç”¨ âœ… æ“ä½œå»ºè®®ï¼š æ‰‹åŠ¨åˆ›å»ºå°æ–‡ä»¶ï¼ŒæŸ¥çœ‹ inode åˆ†é… ç»™ fs.c ä¸­çš„ readi / writei åŠ æ—¥å¿— â¬› ç¬¬6ç« ï¼šè®¾å¤‡é©±åŠ¨æ–‡ä»¶ï¼šuart.c, console.c, virtio_disk.c ç†è§£ï¼š UART è¾“å‡ºå’Œä¸­æ–­æœºåˆ¶ virtio å¦‚ä½•æ¨¡æ‹Ÿç¡¬ç›˜è¯»å†™ âœ… å°æµ‹è¯•ï¼š æ”¹å†™ consoleintr() ä¸­çš„å­—ç¬¦åˆ¤æ–­ï¼Œå±è”½è¾“å…¥ 'a' è¯•è¯• ğŸ•– ç¬¬ 5 é˜¶æ®µï¼šè°ƒè¯• + å›é¡¾ï¼ˆ9â€“12hï¼‰ ä½¿ç”¨ make qemu-gdbï¼Œç”¨ gdb æ‰“æ–­ç‚¹çœ‹å¯åŠ¨æµç¨‹ã€trap è¿‡ç¨‹ ä½¿ç”¨ grep + cscope å­¦ä¼šå¿«é€Ÿå®šä½å‡½æ•°å®šä¹‰ æ•´ç† syscall æµç¨‹ã€trap æµç¨‹å›¾ å¤ç° lab ä¸­çš„ç»ƒä¹ é¢˜ï¼ˆå¦‚æ·»åŠ ç³»ç»Ÿè°ƒç”¨ï¼‰","link":"/post/xv6-riscv-PLAN.html"},{"title":"xv6-riscv-ch1","text":"How does xv6 come to life? ch1: Operating system interfaces As Figure 1.1 shows, xv6 takes the traditional form of a kernel, a special program that providesservices to running programs. Each running program, called a process, has memory containinginstructions, data, and a stack. The instructions implement the programâ€™s computation. The dataare the variables on which the computation acts. The stack organizes the programâ€™s procedure calls.A given computer typically has many processes but only a single kernel. When a user program invokes a sys-tem call, the hardware raises the privilege level and starts executing a pre-arranged function in thekernel.The collection of system calls that a kernel provides is the interface that user programs see. Thexv6 kernel provides a subset of the services and system calls that Unix kernels traditionally offer.Figure 1.2 lists all of xv6â€™s system calls. The shell is an ordinary program that reads commands from the user and executes them. Thefact that the shell is a user program, and not part of the kernel, illustrates the power of the systemcall interface: there is nothing special about the shell. It also means that the shell is easy to replace;as a result, modern Unix systems have a variety of shells to choose from, each with its own userinterface and scripting features. The xv6 shell is a simple implementation of the essence of theUnix Bourne shell. Its implementation can be found at (user/sh.c:1).The xv6 shell uses the exec calls of blew to run programs on behalf of users. The main structure ofthe shell is simple; see main (user/sh.c:146). The main loop reads a line of input from the user withgetcmd. Then it calls fork, which creates a copy of the shell process. The parent calls wait,while the child runs the command. For example, if the user had typed â€œecho helloâ€ to the shell,runcmd would have been called with â€œecho helloâ€ as the argument. runcmd (user/sh.c:55) runsthe actual command. For â€œecho helloâ€, it would call exec (user/sh.c:79). If exec succeeds thenthe child will execute instructions from echo instead of runcmd. At some point echo will callexit, which will cause the parent to return from wait in main (user/sh.c:146). 1.1 Processes and memory An xv6 process consists of user-space memory (instructions, data, and stack) and per-process stateprivate to the kernel. Xv6 time-shares processes: it transparently switches the available CPUsamong the set of processes waiting to execute. When a process is not executing, xv6 saves theprocessâ€™s CPU registers, restoring them when it next runs the process. The kernel associates aprocess identifier, or PID, with each process. the following program fragment written in the C programming lan-guage 1234567891011int pid = fork();if(pid &gt; 0){printf(&quot;parent: child=%d\\n&quot;, pid);pid = wait((int *) 0);printf(&quot;child %d is done\\n&quot;, pid);} else if(pid == 0){printf(&quot;child: exiting\\n&quot;);exit(0);} else {printf(&quot;fork error\\n&quot;);} In the example, the output linesparent: child=1234child: exitingmight come out in either order (or even intermixed), depending on whether the parent or child getsto its printf call first. After the child exits, the parentâ€™s wait returns, causing the parent to printparent: child 1234 is doneAlthough the child has the same memory contents as the parent initially, the parent and child areexecuting with separate memory and separate registers: changing a variable in one does not affectthe other. For example, when the return value of wait is stored into pid in the parent process, itdoesnâ€™t change the variable pid in the child. The value of pid in the child will still be zero. The exec system call replaces the calling processâ€™s memory with a new memory image loadedfrom a file stored in the file system. The file must have a particular format, which specifies whichpart of the file holds instructions, which part is data, at which instruction to start, etc. Xv6 uses theELF format, which Chapter 3 discusses in more detail. Usually the file is the result of compilinga programâ€™s source code. When exec succeeds, it does not return to the calling program; instead,the instructions loaded from the file start executing at the entry point declared in the ELF header.exec takes two arguments: the name of the file containing the executable and an array of stringarguments. For example 123456char *argv[3];argv[0] = &quot;echo&quot;;argv[1] = &quot;hello&quot;;argv[2] = 0;exec(&quot;/bin/echo&quot;, argv);printf(&quot;exec error\\n&quot;); This fragment replaces the calling program with an instance of the program /bin/echo runningwith the argument list echo hello. Most programs ignore the first element of the argument array,which is conventionally the name of the program. why fork and exec are not combined in a single callwe will see later thatthe shell exploits the separation in its implementation of I/O redirection.Xv6 allocates most user-space memory implicitly: fork allocates the memory required for thechildâ€™s copy of the parentâ€™s memory, and exec allocates enough memory to hold the executablefile. A process that needs more memory at run-time (perhaps for malloc) can call sbrk(n) togrow its data memory by n zero bytes; sbrk returns the location of the new memory. 1.2 I/O and File descriptors A file descriptor is a small integer representing a kernel-managed object that a process may readfrom or write to. A process may obtain a file descriptor by opening a file, directory, or device,or by creating a pipe, or by duplicating an existing descriptor. For simplicity weâ€™ll often referto the object a file descriptor refers to as a â€œfileâ€; the file descriptor interface abstracts away thedifferences between files, pipes, and devices, making them all look like streams of bytes. Weâ€™llrefer to input and output as I/O. Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so thatevery process has a private space of file descriptors starting at zero. By convention, a process readsfrom file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), andwrites error messages to file descriptor 2 (standard error). As we will see, the shell exploits theconvention to implement I/O redirection and pipelines. The shell ensures that it always has threefile descriptors open (user/sh.c:152), which are by default file descriptors for the console. The following program fragment (which forms the essence of the program cat) copies datafrom its standard input to its standard output. If an error occurs, it writes a message to the standarderror. 123456789101112131415char buf[512];int n;for(;;){n = read(0, buf, sizeof buf);if(n == 0)break;if(n &lt; 0){fprintf(2, &quot;read error\\n&quot;);exit(1);}if(write(1, buf, n) != n){fprintf(2, &quot;write error\\n&quot;);exit(1);}} The important thing to note in the code fragment is that cat doesnâ€™t know whether it is readingfrom a file, console, or a pipe. Similarly cat doesnâ€™t know whether it is printing to a console, afile, or whatever. The use of file descriptors and the convention that file descriptor 0 is input andfile descriptor 1 is output allows a simple implementation of cat. The close system call releases a file descriptor, making it free for reuse by a future open,pipe, or dup system call (see below). A newly allocated file descriptor is always the lowest-numbered unused descriptor of the current process. File descriptors and fork interact to make I/O redirection easy to implement. 12345678char *argv[2];argv[0] = &quot;cat&quot;;argv[1] = 0;if(fork() == 0) {close(0);open(&quot;input.txt&quot;, O_RDONLY);exec(&quot;cat&quot;, argv);} After the child closes file descriptor 0, open is guaranteed to use that file descriptor for the newlyopened input.txt: 0 will be the smallest available file descriptor. cat then executes with filedescriptor 0 (standard input) referring to input.txt. The parent processâ€™s file descriptors are notchanged by this sequence Two file descriptors share an offset if they were derived from the same original file descriptorby a sequence of fork and dup calls. Otherwise file descriptors do not share offsets, even if theyresulted from open calls for the same file. dup allows shells to implement commands like this: ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1. The 2&gt;&amp;1 tells the shell to give the command a file descriptor 2 that is a duplicate of descriptor 1. Both the name of the existing file and the error message for the non-existing file will show up in the file tmp1. The xv6 shell doesnâ€™t support I/O redirection for the error file descriptor, but now you know how to implement it. 1.3 Pipes A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for readingand one for writing. Writing data to one end of the pipe makes that data available for reading fromthe other end of the pipe. Pipes provide a way for processes to communicate. The following example code runs the program wc with standard input connected to the readend of a pipe. 12345678910111213141516int p[2];char *argv[2];argv[0] = &quot;wc&quot;;argv[1] = 0;pipe(p);if(fork() == 0) {close(0);dup(p[0]);close(p[0]);close(p[1]);exec(&quot;/bin/wc&quot;, argv);} else {close(p[0]);write(p[1], &quot;hello world\\n&quot;, 12);close(p[1]);} 12345678910 pipe [p[1]] -------&gt; [p[0]] (write) (read)parent: write(p[1], ...)child: dup(p[0]) -&gt; fd 0 exec(&quot;wc&quot;) -&gt; wc reads from stdin (=read of pipe) The fact that read blocks until it is impossible for new data to arriveis one reason that itâ€™s important for the child to close the write end of the pipe before executingwc above: if one of wc â€™s file descriptors referred to the write end of the pipe and not close, wc would never seeend-of-file. The xv6 shell implements pipelines such as grep fork sh.c | wc -l in a manner similarto the above code (user/sh.c:101). The child process creates a pipe to connect the left end of thepipeline with the right end. Then it calls fork and runcmd for the left end of the pipeline andfork and runcmd for the right end, and waits for both to finish. The right end of the pipelinemay be a command that itself includes a pipe (e.g., a | b | c), which itself forks two new childprocesses (one for b and one for c). Thus, the shell may create a tree of processes. The leaves16of this tree are commands and the interior nodes are processes that wait until the left and rightchildren complete. 12345 sh / \\a sh / \\ b c echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyzPipes have at least three advantages over temporary files in this situation. First, pipes automatically clean themselves up; with the file redirection, a shell would have to be careful to remove /tmp/xyz when done. Second, pipes can pass arbitrarily long streams of data, while file redirection requires enough free space on disk to store all the data. Third, pipes allow for parallel execution of pipeline stages, while the file approach requires the first program to finish before the second starts. 1.4 File system The xv6 file system provides data files, which contain uninterpreted byte arrays, and directories,which contain named references to data files and other directories. There are system calls to create new files and directories: mkdir creates a new directory, openwith the O_CREATE flag creates a new data file, and mknod creates a new device file. This exampleillustrates all three: 1234mkdir(&quot;/dir&quot;);fd = open(&quot;/dir/file&quot;, O_CREATE|O_WRONLY);close(fd);mknod(&quot;/console&quot;, 1, 1); mknod creates a special file that refers to a device. Associated with a device file are the major andminor device numbers (the two arguments to mknod), which uniquely identify a kernel device.When a process later opens a device file, the kernel diverts read and write system calls to thekernel device implementation instead of passing them to the file system. A fileâ€™s name is distinct from the file itself; the same underlying file, called an inode, can havemultiple names, called links. Each link consists of an entry in a directory; the entry contains a filename and a reference to an inode. An inode holds metadata about a file, including its type (file ordirectory or device), its length, the location of the fileâ€™s content on disk, and the number of links toa file. The fstat system call retrieves information from the inode that a file descriptor refers to. Itfills in a struct stat, defined in stat.h (kernel/stat.h) as: 1234567891011#define T_DIR 1// Directory#define T_FILE 2// File#define T_DEVICE 3// Devicestruct stat { int dev; // File systemâ€™s disk device uint ino; // Inode number short type; // Type of file short nlink; // Number of links to file uint64 size; // Size of file in bytes}; The link system call creates another file system name referring to the same inode as an exist-ing file. This fragment creates a new file named both a and b. 12open(&quot;a&quot;, O_CREATE|O_WRONLY);link(&quot;a&quot;, &quot;b&quot;); Reading from or writing to a is the same as reading from or writing to b. Each inode is identifiedby a unique inode number. After the code sequence above, it is possible to determine that a and brefer to the same underlying contents by inspecting the result of fstat: both will return the sameinode number (ino), and the nlink count will be set to 2.The unlink system call removes a name from the file The unlink system call removes a name from the file system. The fileâ€™s inode and the diskspace holding its content are only freed when the fileâ€™s link count is zero and no file descriptorsrefer to it. Thus adding 1unlink(&quot;a&quot;); to the last code sequence leaves the inode and file content accessible as b. Furthermore, 12fd = open(&quot;/tmp/xyz&quot;, O_CREATE|O_RDWR);unlink(&quot;/tmp/xyz&quot;); is an idiomatic way to create a temporary inode with no name that will be cleaned up when theprocess closes fd or exits. Unix provides file utilities callable from the shell as user-level programs, for example mkdir,ln, and rm. This design allows anyone to extend the command-line interface by adding new user-level programs. In hindsight this plan seems obvious, but other systems designed at the time ofUnix often built such commands into the shell (and built the shell into the kernel).One exception is cd, which is built into the shell (user/sh.c:161). cd must change the currentworking directory of the shell itself. If cd were run as a regular command, then the shell would18fork a child process, the child process would run cd, and cd would change the child â€™s workingdirectory. The parentâ€™s (i.e., the shellâ€™s) working directory would not change. 1.5 Real world the shell was the first so-called â€œscripting language.â€ The Unix system call interface persists today insystems like BSD, Linux, and macOS. The Unix system call interface has been standardized through the Portable Operating SystemInterface (POSIX) standard. Xv6 is not POSIX compliant: it is missing many system calls (in-cluding basic ones such as lseek), and many of the system calls it does provide differ from thestandard. Our main goals for xv6 are simplicity and clarity while providing a simple UNIX-likesystem-call interface. Several people have extended xv6 with a few more system calls and a sim-ple C library in order to run basic Unix programs. Modern kernels, however, provide many moresystem calls, and many more kinds of kernel services, than xv6. For example, they support net-working, windowing systems, user-level threads, drivers for many devices, and so on. Modernkernels evolve continuously and rapidly, and offer many features beyond POSIX. Xv6 does not provide a notion of users or of protecting one user from another; in Unix terms,all xv6 processes run as root. commentsï¼š Linux tries to adhere to POSIX (glibc provides most of the POSIX interfaces), but has its own extensions (e.g., epoll). Programmers who write POSIX interfaces can compile and run them on macOS, BSD, and Linux (as long as they donâ€™t use platform-specific extensions). Think of the xv6 system call interface as a â€œsubset implementation of POSIX.â€ POSIXæ–‡æ¡£","link":"/post/xv6-riscv-ch1.html"},{"title":"hexoåšå®¢æ­å»º","text":"1. å®‰è£…å¹¶åˆå§‹åŒ–Hexo å®‰è£… Hexo CLI 1npm install -g hexo-cli åˆå§‹åŒ–åšå®¢é¡¹ç›®ç›®å½• 123mkdir my-blog &amp;&amp; cd my-bloghexo initnpm install æœ¬åœ°é¢„è§ˆ 1hexo server å¯åŠ¨æœ¬åœ°æœåŠ¡ï¼šåœ¨æµè§ˆå™¨è®¿é—® http://localhost:4000 æŸ¥çœ‹æ•ˆæœ 2. é…ç½® GitHub Pages éƒ¨ç½² åˆ›å»ºGitHubä»“åº“ åˆ›å»ºä¸€ä¸ªä»“åº“ï¼Œåå­—å« ä½ çš„GitHubç”¨æˆ·å.github.io æ¯”å¦‚ä½ æ˜¯ gokoï¼Œå°±å« goko.github.io å®‰è£…éƒ¨ç½²æ’ä»¶ 1npm install hexo-deployer-git --save ä¿®æ”¹ _config.ymlï¼ˆæ ¹ç›®å½•ä¸‹ï¼‰æ·»åŠ éƒ¨ç½²é…ç½®ï¼š 12345deploy: type: git # repoå»ºè®®ä½¿ç”¨SSH, SSHå…å¯† repo: https://github.com/ä½ çš„GitHubç”¨æˆ·å/ä½ çš„GitHubç”¨æˆ·å.github.io.git branch: main # æˆ–è€… masterï¼Œçœ‹ä½ çš„é»˜è®¤åˆ†æ”¯ ç”Ÿæˆå¹¶éƒ¨ç½²åšå®¢ 123hexo cleanhexo generatehexo deploy 3. åŸŸå(.com)ç»‘å®š æ·»åŠ åŸŸå(åœ¨my-blogä¸‹) 123echo &quot;&lt;xxxx&gt;.com&quot; &gt; source/CNAME# æˆ–è€…å¯ä»¥ï¼šecho &quot;www.&lt;xxxx&gt;.com&quot; &gt; source/CNAME# åªèƒ½æ·»åŠ ä¸€ä¸ªï¼Œè€Œä¸”ä¸¤ä¸ªéœ€è¦æ·»åŠ ä¸åŒçš„åŸŸåè§£æï¼ˆå¦‚ä¸‹ï¼‰ é‡æ–°éƒ¨ç½² 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d è®¾ç½® DNS è§£ææŒ‡å‘ GitHub Pages A. ä½¿ç”¨è£¸åŸŸåï¼ˆapex åŸŸåï¼‰goku72.com è®°å½•ç±»å‹ ä¸»æœºè®°å½• è®°å½•å€¼ è¯´æ˜ A @ 185.199.108.153 GitHub Pages IP A @ 185.199.109.153 GitHub Pages IP A @ 185.199.110.153 GitHub Pages IP A @ 185.199.111.153 GitHub Pages IP example aliyun: é€‰æ‹©ä¸šåŠ¡éœ€æ±‚: å°†ç½‘ç«™åŸŸåè§£æåˆ°æœåŠ¡å™¨IPv4åœ°å€ é€‰æ‹©ç½‘ç«™åŸŸå(ä¸»æœºè®°å½•): .comï¼ˆå¯¹åº”è®¾ç½®â€œ@â€ä¸»æœºè®°å½•ï¼‰ å¡«å†™ IPï¼ˆè®°å½•å€¼ï¼‰ï¼š åœ¨è¾“å…¥æ¡†é‡Œç²˜è´´ä»¥ä¸‹å››è¡Œï¼ˆæ¯ä¸€è¡Œä¸€ä¸ª IPï¼‰ï¼š &gt; 185.199.109.153 &gt; 185.199.108.153 &gt; 185.199.110.153 &gt; 185.199.111.153 B. ä½¿ç”¨ www.goku72.com ä½œä¸ºä¸»åŸŸå è®°å½•ç±»å‹ ä¸»æœºè®°å½• è®°å½•å€¼ è¯´æ˜ CNAME www &lt;githubç”¨æˆ·å&gt;.github.io. æŒ‡å‘ä½ çš„ GitHub ç”¨æˆ·é¡µä»“åº“ example aliyun: é€‰æ‹©ä¸šåŠ¡éœ€æ±‚: å°†ç½‘ç«™åŸŸåè§£æåˆ°å¦å¤–çš„ç›®æ ‡åŸŸå é€‰æ‹©ç½‘ç«™åŸŸå(ä¸»æœºè®°å½•): www..comï¼ˆå¯¹åº”è®¾ç½®â€œwwwâ€ä¸»æœºè®°å½•ï¼‰ å¡«å†™ IPï¼ˆè®°å½•å€¼ï¼‰ï¼š&lt;githubç”¨æˆ·å&gt;.github.io. (æœ€æœ‰æœ‰ä¸€ä¸ªç¬¦å·â€.â€) 4. è®¾ç½®ä¸»é¢˜ cd my-blog/themes git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git butterfly ä¿®æ”¹_config.yml: theme: butterfly hexo clean &amp;&amp; hexo g &amp;&amp; hexo d æ›´å¤šä¸»é¢˜ï¼šhttps://hexo.io/themes/ æ³¨ï¼š å¦‚æœABä¸¤ä¸ªæ–¹å¼éƒ½æ·»åŠ äº†ï¼Œåªéœ€è¦åœ¨ Hexo é¡¹ç›®çš„ source/CNAME æ–‡ä»¶ä¸­å†™ www..comï¼ŒGitHub Pages å°±ä¼šè‡ªåŠ¨æŠŠ goku72.com é‡å®šå‘è¿‡å»ï¼Œæ— éœ€é¢å¤–è®¾ç½®ï¼ åç»­æ¢åŸŸååªéœ€è¦ï¼šé˜¿é‡Œäº‘é‡æ–°è§£æ + ä¿®æ”¹ source/CNAME + é‡æ–°éƒ¨ç½² Hexoï¼Œå°±èƒ½å®ŒæˆåŸŸåè¿ç§»ã€‚ æœ‰äº›ä¸»é¢˜å¯èƒ½éœ€è¦ä¸‹è½½æ’ä»¶","link":"/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html"},{"title":"xv6-riscv_struct","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475.â”œâ”€â”€ kernelâ”‚ â”œâ”€â”€ bio.câ”‚ â”œâ”€â”€ buf.hâ”‚ â”œâ”€â”€ console.câ”‚ â”œâ”€â”€ defs.hâ”‚ â”œâ”€â”€ elf.hâ”‚ â”œâ”€â”€ entry.Sâ”‚ â”œâ”€â”€ exec.câ”‚ â”œâ”€â”€ fcntl.hâ”‚ â”œâ”€â”€ file.câ”‚ â”œâ”€â”€ file.hâ”‚ â”œâ”€â”€ fs.câ”‚ â”œâ”€â”€ fs.hâ”‚ â”œâ”€â”€ kalloc.câ”‚ â”œâ”€â”€ kernel.ldâ”‚ â”œâ”€â”€ kernelvec.Sâ”‚ â”œâ”€â”€ log.câ”‚ â”œâ”€â”€ main.câ”‚ â”œâ”€â”€ memlayout.hâ”‚ â”œâ”€â”€ param.hâ”‚ â”œâ”€â”€ pipe.câ”‚ â”œâ”€â”€ plic.câ”‚ â”œâ”€â”€ printf.câ”‚ â”œâ”€â”€ proc.câ”‚ â”œâ”€â”€ proc.hâ”‚ â”œâ”€â”€ riscv.hâ”‚ â”œâ”€â”€ sleeplock.câ”‚ â”œâ”€â”€ sleeplock.hâ”‚ â”œâ”€â”€ spinlock.câ”‚ â”œâ”€â”€ spinlock.hâ”‚ â”œâ”€â”€ start.câ”‚ â”œâ”€â”€ stat.hâ”‚ â”œâ”€â”€ string.câ”‚ â”œâ”€â”€ swtch.Sâ”‚ â”œâ”€â”€ syscall.câ”‚ â”œâ”€â”€ syscall.hâ”‚ â”œâ”€â”€ sysfile.câ”‚ â”œâ”€â”€ sysproc.câ”‚ â”œâ”€â”€ trampoline.Sâ”‚ â”œâ”€â”€ trap.câ”‚ â”œâ”€â”€ types.hâ”‚ â”œâ”€â”€ uart.câ”‚ â”œâ”€â”€ virtio_disk.câ”‚ â”œâ”€â”€ virtio.hâ”‚ â””â”€â”€ vm.câ”œâ”€â”€ LICENSEâ”œâ”€â”€ Makefileâ”œâ”€â”€ mkfsâ”‚ â””â”€â”€ mkfs.câ”œâ”€â”€ READMEâ””â”€â”€ user â”œâ”€â”€ cat.c â”œâ”€â”€ echo.c â”œâ”€â”€ forktest.c â”œâ”€â”€ grep.c â”œâ”€â”€ grind.c â”œâ”€â”€ init.c â”œâ”€â”€ initcode.S â”œâ”€â”€ kill.c â”œâ”€â”€ ln.c â”œâ”€â”€ ls.c â”œâ”€â”€ mkdir.c â”œâ”€â”€ printf.c â”œâ”€â”€ rm.c â”œâ”€â”€ sh.c â”œâ”€â”€ stressfs.c â”œâ”€â”€ ulib.c â”œâ”€â”€ umalloc.c â”œâ”€â”€ user.h â”œâ”€â”€ user.ld â”œâ”€â”€ usertests.c â”œâ”€â”€ usys.pl â”œâ”€â”€ wc.c â””â”€â”€ zombie.c é€æ–‡ä»¶è¯¦ç»†è§£è¯»å®ƒä»¬çš„ä½œç”¨ã€é‡è¦æ€§ï¼š ğŸ§  æ•´ä½“ç»“æ„ ç›®å½•/æ–‡ä»¶ ä½œç”¨ å»ºè®®é‡ç‚¹å…³æ³¨ kernel/ xv6 æ ¸å¿ƒå®ç°ï¼Œå†…æ ¸æºç  âœ… å¿…çœ‹ user/ ç”¨æˆ·æ€ç¨‹åºã€æµ‹è¯•ç¨‹åºã€åº“ âœ… æ¨è mkfs/ æ„å»ºæ–‡ä»¶ç³»ç»Ÿé•œåƒå·¥å…· â—å¯é€‰ é¡¶å±‚æ„å»ºæ–‡ä»¶ Makefile, README, LICENSE ç­‰ ğŸ§© ç†Ÿæ‚‰ç»“æ„ç”¨ ğŸ“ kernel/ â€” xv6 çš„å¿ƒè„ï¼ˆé‡ç‚¹æ¨¡å—ï¼‰xv6 ä¸»è¦æ¨¡å—å¯åˆ†ä¸ºï¼š å†…æ ¸å¯åŠ¨ä¸å†…å­˜ç®¡ç†ï¼šentry.Sã€start.cã€vm.cã€kalloc.c ä¸­æ–­ã€å¼‚å¸¸ã€ç³»ç»Ÿè°ƒç”¨ï¼štrap.cã€syscall.cã€kernelvec.Sã€trampoline.S è¿›ç¨‹è°ƒåº¦ä¸ç®¡ç†ï¼šproc.cã€swtch.S æ–‡ä»¶ç³»ç»Ÿä¸æ–‡ä»¶æ¥å£ï¼šfs.cã€file.cã€bio.cã€log.c è®¾å¤‡é©±åŠ¨ï¼šuart.cã€console.cã€virtio_disk.cã€plic.c å†…æ ¸å·¥å…·ä»£ç ï¼šspinlock.cã€sleeplock.cã€printf.cã€string.c ğŸ§¾ æ–‡ä»¶çº§è¯¦ç»†è§£é‡Šï¼ˆæŒ‰å­ç³»ç»Ÿåˆ†ç±»ï¼‰ ğŸŸ© ä¸€ã€å†…æ ¸å¯åŠ¨ä¸å†…å­˜ç®¡ç† æ–‡ä»¶ ä½œç”¨ è¯´æ˜ entry.S æ ¸å¿ƒå¯åŠ¨æ±‡ç¼–å…¥å£ è®¾ç½®é¡µè¡¨ã€è·³è½¬åˆ° start() start.c C è¯­è¨€å…¥å£ main() å‰åšç¯å¢ƒåˆå§‹åŒ–ï¼ˆé¡µè¡¨ã€trapframeï¼‰ main.c å†…æ ¸ä¸»å‡½æ•° å¯åŠ¨å†…æ ¸æ¨¡å—ï¼Œå¦‚ userinit() kernel.ld å†…æ ¸é“¾æ¥è„šæœ¬ æŒ‡å®šå†…æ ¸æ®µåœ°å€ã€ç¬¦å·å¯¼å‡ºé¡ºåº vm.c è™šæ‹Ÿå†…å­˜ç³»ç»Ÿ é¡µè¡¨åˆ†é…ã€æ‹·è´ã€æ˜ å°„ï¼ˆåŸºäº Sv39ï¼‰ kalloc.c ç‰©ç†é¡µåˆ†é…å™¨ ç®¡ç†ç©ºé—²é¡µé“¾è¡¨ï¼Œç”¨äº allocuvm memlayout.h å†…å­˜å¸ƒå±€å® å®šä¹‰ KERNBASEã€PHYSTOP ç­‰å¸¸é‡ ğŸ“Œ å»ºè®®ä» entry.S â†’ start.c â†’ main.c â†’ userinit() è·‘ä¸€éæµç¨‹ã€‚ ğŸŸ¦ äºŒã€è¿›ç¨‹ç®¡ç†ä¸è°ƒåº¦ æ–‡ä»¶ ä½œç”¨ è¯´æ˜ proc.c ç®¡ç†è¿›ç¨‹è¡¨ã€fork/wait scheduler() æ˜¯è°ƒåº¦å™¨æ ¸å¿ƒ proc.h è¿›ç¨‹ç»“æ„ä½“å®šä¹‰ ç»“æ„ä½“ struct proc åŒ…å«é¡µè¡¨ã€çŠ¶æ€ã€trapframe swtch.S ä¸Šä¸‹æ–‡åˆ‡æ¢æ±‡ç¼– ä¿å­˜/æ¢å¤å¯„å­˜å™¨ï¼Œè°ƒåº¦å¿…ç”¨ trap.c trap/ä¸­æ–­å…¥å£ ç”¨æˆ· â†’ å†…æ ¸çš„æ€»å…¥å£ï¼›å¼‚å¸¸è°ƒåº¦ã€syscall éƒ½èµ°å®ƒ sysproc.c ä¸è¿›ç¨‹ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ sys_exitã€sys_forkã€sys_wait ğŸ“Œ å¼ºçƒˆå»ºè®®ï¼šç»™ fork()ã€scheduler()ã€yield() åŠ æ‰“å°è§‚å¯Ÿè¿è¡Œã€‚ ğŸŸ¨ ä¸‰ã€ç³»ç»Ÿè°ƒç”¨æœºåˆ¶ æ–‡ä»¶ ä½œç”¨ è¯´æ˜ syscall.c syscall åˆ†å‘å™¨ æ ¹æ® syscall num åˆ†å‘åˆ° sys_* syscall.h syscall ç¼–å· ç”¨ #define SYS_write 1 ç­‰æ˜ å°„ sysfile.c æ–‡ä»¶ç›¸å…³ syscall open/close/read/write çš„å†…æ ¸å®ç° usys.pl â†’ usys.S ç”¨æˆ·æ€ syscall åŒ…è£… ç”Ÿæˆç”¨æˆ·ä»£ç  mov a7, id; ecall ğŸ“Œ syscall æµç¨‹ = ç”¨æˆ·æ€ ecall â†’ trap â†’ syscall.c â†’ sys_*() ğŸŸ§ å››ã€æ–‡ä»¶ç³»ç»Ÿä¸ I/O æ¥å£ æ–‡ä»¶ ä½œç”¨ è¯´æ˜ fs.c inode å±‚ ialloc, readi, writeiï¼Œæ–‡ä»¶æ ¸å¿ƒç»“æ„ fs.h inode å®šä¹‰ struct inodeï¼Œå—åœ°å€ä¿¡æ¯ç­‰ file.c æ–‡ä»¶æè¿°ç¬¦å±‚ struct fileï¼Œç®¡ç† open/close ç­‰ file.h æ–‡ä»¶æè¿°ç¬¦å®šä¹‰ æ”¯æŒ pipe/dev/inode ç­‰ç±»å‹ bio.c ç¼“å­˜å—è¯»å†™ å®ç° block çº§è¯»å†™ç¼“å­˜ log.c æ—¥å¿—æœºåˆ¶ crash-safe å†™æ“ä½œäº‹åŠ¡ï¼ˆwrite-ahead loggingï¼‰ pipe.c ç®¡é“å®ç° å†…å­˜ä¸­åŒå‘ FIFO fcntl.h, stat.h POSIX ç›¸å…³å¤´æ–‡ä»¶ ç”¨äº open flagã€stat ç»“æ„ä½“ ğŸ“Œ å»ºè®®è°ƒè¯• fs.c çš„ namei()ã€dirlookup()ï¼Œçœ‹è·¯å¾„å¦‚ä½•è¢«è§£æã€‚ ğŸŸ¥ äº”ã€è®¾å¤‡é©±åŠ¨ä¸ä¸­æ–­æ§åˆ¶ æ–‡ä»¶ ä½œç”¨ è¯´æ˜ uart.c ä¸²å£é©±åŠ¨ åˆå§‹åŒ–ä¸²å£ï¼Œå†™å…¥å­—ç¬¦ç»™ç»ˆç«¯ console.c æ§åˆ¶å° I/O ä¸ UART é…åˆå®ç° shell è¾“å…¥è¾“å‡º plic.c ä¸­æ–­æ§åˆ¶å™¨ Platform-Level Interrupt Controller virtio_disk.c è™šæ‹Ÿç£ç›˜é©±åŠ¨ QEMU è™šæ‹Ÿç£ç›˜ç¡¬ä»¶è®¿é—®å±‚ virtio.h virtio è®¾å¤‡å®šä¹‰ é…å¥—æ•°æ®ç»“æ„ ğŸ“Œ virtio_disk.c è°ƒè¯•æ–¹æ³•ï¼šè§‚å¯Ÿ virtio_rw() å®ç°çš„è¯»å†™é€»è¾‘ã€‚ ğŸŸ« å…­ã€å·¥å…·ç±» / å†…æ ¸åº“å‡½æ•° æ–‡ä»¶ ä½œç”¨ è¯´æ˜ defs.h å†…æ ¸å‡½æ•°å£°æ˜ extern æ‰€æœ‰æ¨¡å—å‡½æ•°ï¼Œä¾›å…¨å±€ä½¿ç”¨ riscv.h RISC-V CSR å®ã€å¯„å­˜å™¨å®šä¹‰ åŒ…å« rdtime, csrr, sstatus ç­‰ spinlock.c/.h è‡ªæ—‹é”å®ç° æ ¸å¿ƒäº’æ–¥æœºåˆ¶ï¼Œéœ€å…³ä¸­æ–­ sleeplock.c/.h ç¡çœ é”å®ç° ç”¨äºæ–‡ä»¶ç³»ç»Ÿï¼Œsleep/wakeup ç®¡ç† string.c libc å®ç° memcpy, strlen ç­‰å†…æ ¸è‡ªå¸¦å‡½æ•° printf.c å†…æ ¸çº§ printf ç”¨äºè°ƒè¯•æ‰“å°ï¼Œæ— ç¼“å†²ç‰ˆ param.h ç³»ç»Ÿå‚æ•°å® å®šä¹‰ NPROC, MAXPATH ç­‰å…¨å±€å‚æ•° types.h å¸¸ç”¨ç±»å‹å®šä¹‰ uchar, uint, sint ç­‰ç®€å†™ ğŸ“Œ å¸¸ç”¨ grep å‘½ä»¤ï¼šgrep -rn &quot;spin_lock&quot; kernel/ è¿½è¸ªå¹¶å‘ç‚¹ ğŸ“ user/ â€” ç”¨æˆ·æ€ç¨‹åºä¸æµ‹è¯• æ–‡ä»¶ ä½œç”¨ è¯´æ˜ *.c å‘½ä»¤ç¨‹åº shell å‘½ä»¤å¦‚ ls, cat, echo, sh ç­‰ init.c é¦–ä¸ªç”¨æˆ·è¿›ç¨‹ userinit() å¯åŠ¨çš„ç¨‹åºï¼Œè¿è¡Œ /init initcode.S æœ€åŸå§‹çš„ç”¨æˆ·æ€ä»£ç  ç”± userinit() è½½å…¥çš„ç¨‹åºï¼ˆæ±‡ç¼–ï¼‰ ulib.c libc å‡½æ•° ç”¨æˆ·æ€çš„ malloc, printf ç­‰ umalloc.c malloc å®ç° ç”¨æˆ·æ€å †åˆ†é… usertests.c ç”¨æˆ·æ€æµ‹è¯•é›† æµ‹è¯• syscallã€è¿›ç¨‹ã€æ–‡ä»¶åŠŸèƒ½ user.ld ç”¨æˆ·æ€é“¾æ¥è„šæœ¬ æ§åˆ¶ç”¨æˆ·ç¨‹åºçš„æ®µåˆ†å¸ƒ user.h å‡½æ•°å£°æ˜ ä¾›ç”¨æˆ·ç¨‹åºå¼•ç”¨ printf, fork ç­‰æ¥å£ ğŸ“Œ å¼ºçƒˆæ¨èä½ ä» init.c å¼€å§‹ debugï¼Œç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹çš„è¿è¡Œå…³é”®è·¯å¾„ï¼ ğŸ“ mkfs/ â€” æ„å»ºæ–‡ä»¶ç³»ç»Ÿé•œåƒå·¥å…· æ–‡ä»¶ è¯´æ˜ mkfs.c æ„å»º xv6 æ–‡ä»¶ç³»ç»Ÿé•œåƒï¼ˆuser/init ç­‰æ–‡ä»¶å‹å…¥ï¼‰ ğŸ“Œ ä¸çœ‹ä¹Ÿæ— å¦¨ï¼Œç”¨äº make é˜¶æ®µæ„å»º fs.img ğŸ“„ é¡¶å±‚æ–‡ä»¶ æ–‡ä»¶ è¯´æ˜ Makefile ç¼–è¯‘å…¥å£ï¼Œæ„å»º kernel, fs.img, qemu ç­‰ README ç®€è¦è¯´æ˜æ–‡æ¡£ï¼Œè®²è§£å¦‚ä½•ä½¿ç”¨ LICENSE æˆæƒæ¡æ¬¾ï¼ˆMITï¼‰ âœ… æ€»ç»“ ç”¨ æ¨¡å—åŒ–æ€ç»´ åˆ†é˜¶æ®µå­¦ï¼Œæ¯”å¦‚ â€œå…ˆæŠŠ trap ç†æ¸…æ¥šâ€ï¼Œå†çœ‹ syscallã€‚ æ¨èæ­é…å¦‚ä¸‹å·¥å…·ï¼š tmux zsh grepâ€¦","link":"/post/xv6-riscv-struct.html"},{"title":"xv6-riscv-ch2","text":"ch2: Operating system organization2.1 Abstracting physical resources2.2 User mode, supervisor mode, and system calls2.3 Kernel organization2.4 Code: xv6 organization2.5 Process overview2.6 Code: starting xv6, the first process and system call2.7 Security Model2.8 Real world2.9 Exercises","link":"/post/xv6-riscv-ch2.html"}],"tags":[{"name":"xv6-riscv","slug":"xv6-riscv","link":"/tags/xv6-riscv/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"}],"categories":[],"pages":[{"title":"","text":"Troyâ€™s Blog &gt;&gt;&gt; æ¬¢è¿äº¤æ¢å‹é“¾~ è¯·é€šè¿‡é‚®ä»¶è”ç³»æˆ‘ã€‚","link":"/friend/index.html"}]}
<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>GoKo&#39;s blog</title>
    <link>https://GoKo-Son626.github.io/</link>
    
    <atom:link href="https://goko-son626.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 11 Sep 2025 08:35:13 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>bpftrace环境的配置和使用(基于riscv-k1)</title>
      <link>https://goko-son626.github.io/post/use-bpftrace-on-k1.html</link>
      <guid>https://goko-son626.github.io/post/use-bpftrace-on-k1.html</guid>
      <pubDate>Thu, 31 Jul 2025 18:36:11 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;在k1上配置并使用bpftrace,基于上一篇的配置&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>在k1上配置并使用bpftrace,基于上一篇的配置</strong></em></li></ul><span id="more"></span><h3 id="bpftrace"><a href="#bpftrace" class="headerlink" title="bpftrace"></a>bpftrace</h3><p>配置过程大部分就是依赖的安装和编译问题，不再详细说明</p><ul><li>安装依赖  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get update &amp;&amp; <span class="hljs-built_in">sudo</span> apt-get install -y \<br>cmake flex bison \<br>python3-dev python3-setuptools \<br>libclang-20-dev libedit-dev libcurl4-openssl-dev libdebuginfod-dev liblzma-dev \<br>zip unzip \<br>llvm-20-tools llvm-20-dev libpolly-20-dev \<br>libbpf-dev libcereal-dev \<br>binutils-dev libdw-dev libpcap-dev \<br>curl \<br>dwarves \<br>libgtest-dev<br></code></pre></td></tr></table></figure></li><li>配置编译和安装BCC（因为全部编译bpftrace需要依赖BCC的文件）  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/repo<br>git <span class="hljs-built_in">clone</span> https://github.com/iovisor/bcc.git<br><span class="hljs-built_in">cd</span> bcc<br>git submodule update --init --recursive<br><span class="hljs-comment"># 创建一个干净的编译目录</span><br><span class="hljs-built_in">rm</span> -rf build &amp;&amp; <span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br><span class="hljs-comment"># 运行 cmake，并禁用示例以防止内存耗尽</span><br>cmake -DCMAKE_INSTALL_PREFIX=/usr -DENABLE_EXAMPLES=OFF ..<br><span class="hljs-comment"># 以较低的并行度进行编译，防止系统卡死</span><br>make -j4 <br><span class="hljs-comment"># 安装</span><br><span class="hljs-built_in">sudo</span> make install<br><span class="hljs-built_in">sudo</span> ldconfig<br></code></pre></td></tr></table></figure></li><li>配置编译和安装bpftrace<ul><li>GTest需要手动编译<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/src/googletest<br><span class="hljs-built_in">sudo</span> cmake .<br><span class="hljs-built_in">sudo</span> make -j$(<span class="hljs-built_in">nproc</span>)<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> lib/*.a /usr/lib/<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> -r googletest/include/gtest /usr/include/<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> -r googlemock/include/gmock /usr/include/<br></code></pre></td></tr></table></figure></li><li>编译并安装bpftool<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> bpftool/src <span class="hljs-comment"># 从 libbpf/src 目录回到 bpftool/src</span><br>make<br><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure></li><li>编译并配置 blazesym<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 Rust 环境(网速慢可用国内镜像)</span><br><span class="hljs-built_in">export</span> RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup<br><span class="hljs-built_in">export</span> RUSTUP_UPDATE_ROOT=https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup<br>wget https://sh.rustup.rs -O rustup-init.sh<br><span class="hljs-built_in">chmod</span> +x rustup-init.sh <br><span class="hljs-built_in">sudo</span> ./rustup-init.sh -y<br>rustc --version<br>cargo --version<br><br><span class="hljs-built_in">cd</span> ~/repo/libbpf-bootstrap/blazesym/capi<br>cargo build --release <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> target/release/libblazesym_c.a /usr/local/lib/<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> capi/include/blazesym.h /usr/local/include/blazesym.h <br><span class="hljs-built_in">sudo</span> ldconfig<br></code></pre></td></tr></table></figure></li><li>clong bpftrace并编译安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/repo<br>git <span class="hljs-built_in">clone</span> https://github.com/iovisor/bpftrace.git<br><span class="hljs-built_in">cd</span> bpftrace<br>git submodule update --init --recursive<br><span class="hljs-built_in">rm</span> -rf build &amp;&amp; <span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br>cmake ..<br>make -j$(<span class="hljs-built_in">nproc</span>)<br><span class="hljs-built_in">sudo</span> make install<br>bpftrace --version<br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>安装完成！</strong></p><h3 id="命令测试"><a href="#命令测试" class="headerlink" title="命令测试"></a>命令测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出</span><br><span class="hljs-built_in">sudo</span> bpftrace -e <span class="hljs-string">&#x27;BEGIN &#123; printf(&quot;Hello, World! I have conquered eBPF on RISC-V!\n&quot;); &#125;&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/bpftrace-on-k1/image-0.png" alt="test bpftrace on k1"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 追踪所有打开文件的操作</span><br><span class="hljs-built_in">sudo</span> bpftrace -e <span class="hljs-string">&#x27;tracepoint:syscalls:sys_enter_openat &#123; printf(&quot;PID %d opening: %s\n&quot;, pid, str(args-&gt;filename)); &#125;&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/bpftrace-on-k1/image-1.png" alt="test bpftrace on k1"></p>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/">linux</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/">kernel</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/trace/">trace</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/trace/bpftrace/">bpftrace</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/bpftrace/">bpftrace</category>
      
      
      <comments>https://goko-son626.github.io/post/use-bpftrace-on-k1.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux bpf技术解析及libbpf的使用(基于riscv-k1)</title>
      <link>https://goko-son626.github.io/post/ebpf-and-use-libbpf.html</link>
      <guid>https://goko-son626.github.io/post/ebpf-and-use-libbpf.html</guid>
      <pubDate>Wed, 30 Apr 2025 15:42:34 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;了解ebpf并在riscv平台上支持ebpf, 最后理解并使用libbpf库中的示例&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>了解ebpf并在riscv平台上支持ebpf, 最后理解并使用libbpf库中的示例</strong></em></li></ul><span id="more"></span><h3 id="BPF-和-eBPF"><a href="#BPF-和-eBPF" class="headerlink" title="BPF 和 eBPF"></a>BPF 和 eBPF</h3><ul><li>BPF （extened Berkeley Packet Filter）:  <ul><li>BPF提供了一种在各种内核事件和应用程序事件发生时运行一小段程序的机制。该技术将内核变成完全可编程，允许用户定制和控制它们的系统，以解决现实问题。提供了一套内核接口&#x2F;bpf() 系统调用集合。</li><li>BPF是一项灵活而高效的技术，由指令集、存储对象和辅助函数等几部分组成。由于它采用了虚拟指令集规范，因此也可将它视作一种虚拟机实现。这些指令由Linux内核的BPF运行时模块执行。</li></ul></li><li><strong>eBPF</strong>（extened Berkeley Packet Filter）:<ul><li>扩展版 BPF（64-bit regs、更多指令、复杂验证、maps、helper 函数、更广泛用途）。现在说 BPF&#x2F; eBPF 基本都指 eBPF。</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p>eBPF 的工作原理主要分为三个步骤：加载、编译和执行。</p></li><li><p>eBPF 需要在内核中运行。这通常是由用户态的应用程序完成的，它会通过系统调用来<strong>加载</strong> eBPF 程序。在加载过程中，内核会将 eBPF 程序的代码复制到内核空间。</p></li><li><p>eBPF 程序需要经过<strong>编译和执行</strong>。这通常是由<code>Clang/LLVM</code>的编译器完成，然后形成<code>字节码</code>后，将<code>用户态</code>的字节码装载进<code>内核</code>，<code>Verifier</code>会对要注入内核的程序进行一些内核<code>安全机制</code>的检查,这是为了确保 eBPF 程序不会破坏内核的稳定性和安全性。在检查过程中，内核会对 eBPF 程序的代码进行分析，以确保它不会进行恶意操作，如系统调用、内存访问等。如果 eBPF 程序通过了内核安全机制的检查，它就可以在内核中正常运行了，其会通过通过一个<code>JIT编译步骤</code>将程序的<code>通用字节码</code>转换为<code>机器特定指令集</code>，以优化程序的执行<code>速度</code>。</p><p><strong>JIT</strong>:(即时编译，Just-In-Time compilation): 动态编译技术，它介于解释执行和提前编译（AOT, Ahead-Of-Time）之间。</p><ul><li>解释执行：代码一行行解释运行（如 Python、早期 JavaScript），启动快，但运行慢。</li><li>提前编译（AOT）：代码在运行前全部编译成目标机器码（如 C&#x2F;C++），运行快，但灵活性差。</li><li>JIT：在运行时，把中间表示（IR, bytecode）翻译成机器码，并缓存起来，下次直接运行机器码。既能接近原生性能，又保留了灵活性。<ul><li>JIT 的本质过程：程序一开始以 字节码（或中间表示）形式运行。运行过程中，JIT 编译器发现“这段代码执行得<strong>很频繁</strong>”（<strong>热点代码</strong>），于是触发编译。把字节码即时翻译成当前 CPU 架构的机器码（x86、ARM、RISC-V 等）。后续直接执行机器码（免去解释器逐条解释的开销）。</li></ul></li></ul><p><strong>Clang&#x2F;LLVM</strong>:</p><ul><li>Clang：C&#x2F;C++ 前端（把 <code>C/C++/Objective-C</code> 源转成通用的标准化的中间语言<code>LLVM IR</code>）。<ul><li>词法分析：把代码拆成一个个单词（token），比如 int, main, (, ), {, }。</li><li>语法分析：检查这些单词组合起来是否符合 C&#x2F;C++ 的语法规则。如果写了 int main{) 这种错误，Clang 就在这一步报错。</li><li>生成中间表示 (IR)：如果语法正确，Clang 会把代码转换成一种通用的、与具体计算机架构无关的格式，这就是 LLVM Intermediate Representation (LLVM IR)。</li></ul></li><li>LLVM：编译器后台&#x2F;工具链，接收Clang生成的LLVM IR, 进行一系列加工，生成可执行的机器码。<ul><li>优化 (Optimization)：LLVM 会对 IR 进行大量的优化。比如删除无用的代码、合并重复的计算、展开循环等等，让最终的程序跑得更快、体积更小。这是 LLVM 的核心优势之一。</li><li>代码生成 (Code Generation)：这是最关键的一步。LLVM 会根据你指定的 “目标平台 (Target)”，将优化后的 IR 翻译成该平台专属的机器指令。</li></ul></li></ul></li><li><p>可移植性：Clang&#x2F;LLVM 支持很多后端&#x2F;目标（x86&#x2F;arm&#x2F;bpf 等）。当你用 -target bpf 时，Clang 输出的是 eBPF 字节码（虚拟指令），不是 x86 或 arm 机器码。这个字节码理论上可以在任何支持 eBPF 的内核上运行（但内核版本&#x2F;ABI 细节会影响，CO-RE&#x2F;BTF 出现就是为了解决这类兼容性问题）。最终在内核里，JIT 会把字节码翻译成当前 CPU 的本地机器码。</p></li></ul><p><strong>所以，Clang&#x2F;LLVM 实现了第一层可移植性（源码 -&gt; eBPF 字节码），而内核的 JIT 编译器实现了第二层可移植性（eBPF 字节码 -&gt; 具体 CPU 机器码）。</strong></p><h4 id="ebpf结构图"><a href="#ebpf结构图" class="headerlink" title="ebpf结构图"></a>ebpf结构图</h4><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/ebpf/image-0.png" alt="ebpf-structure"></p><p>用户空间程序与内核中的 BPF 字节码交互的流程主要如下：</p><ul><li>我们可以使用 LLVM 或者 GCC 工具将编写的 BPF 代码程序编译成 BPF 字节码；</li><li>然后使用加载程序 Loader 将字节码加载至内核；内核使用验证器（verfier） 组件保证执行字节码的安全性，以避免对内核造成灾难，在确认字节码安全后将其加载对应的内核模块执行；BPF 观测技术相关的程序程序类型可能是 kprobes&#x2F;uprobes&#x2F;tracepoint&#x2F;perf_events 中的一个或多个，其中：<br>kprobes：实现内核中动态跟踪。kprobes 可以跟踪到 Linux 内核中的导出函数入口或返回点，但是不是稳定 ABI 接口，可能会因为内核版本变化导致，导致跟踪失效。<br>uprobes：用户级别的动态跟踪。与 kprobes 类似，只是跟踪用户程序中的函数。<br>tracepoints：内核中静态跟踪。tracepoints 是内核开发人员维护的跟踪点，能够提供稳定的 ABI 接口，但是由于是研发人员维护，数量和场景可能受限。<br>perf_events：定时采样和 PMC。</li></ul><p>内核中运行的 BPF 字节码程序可以使用两种方式将测量数据回传至用户空间</p><ul><li>maps 方式可用于将内核中实现的统计摘要信息（比如测量延迟、堆栈信息）等回传至用户空间；</li><li>perf-event 用于将内核采集的事件实时发送至用户空间，用户空间程序实时读取分析；</li></ul><h3 id="用途和优势"><a href="#用途和优势" class="headerlink" title="用途和优势"></a>用途和优势</h3><ul><li><strong>用途</strong><ul><li>网络监控：eBPF 可以用于捕获网络数据包，并执行特定的逻辑来分析网络流量。例如，可以使用 eBPF 程序来监控网络流量，并在发现异常流量时进行警报。</li><li>安全过滤：eBPF 可以用于对网络数据包进行安全过滤。例如，可以使用 eBPF 程序来阻止恶意流量的传播，或者在发现恶意流量时对其进行拦截。</li><li>性能分析：eBPF 可以用于对内核的性能进行分析。例如，可以使用 eBPF 程序来收集内核的性能指标，并通过特定的接口将其可视化。这样，可以更好地了解内核的性能瓶颈，并进行优化。</li><li>虚拟化：eBPF 可以用于虚拟化技术。例如，可以使用 eBPF 程序来收集虚拟机的性能指标，并进行负载均衡。这样，可以更好地利用虚拟化环境的资源，提高系统的性能和稳定性。</li></ul></li><li><strong>优势</strong><ul><li>安全：验证器确保了任何 eBPF 程序都不会搞垮内核。</li><li>可移植：同一份 eBPF 字节码，理论上可以在任何架构（x86, ARM, RISC-V）的 Linux 内核上运行，因为 JIT(见下文) 会为它们翻译出对应的原生机器码。</li><li>高性能：因为 JIT 的存在，最终运行的是原生机器码，速度接近于原生内核代码。</li></ul></li></ul><h3 id="在k1上安装并配置ebpf的环境和工具"><a href="#在k1上安装并配置ebpf的环境和工具" class="headerlink" title="在k1上安装并配置ebpf的环境和工具"></a>在k1上安装并配置ebpf的环境和工具</h3><ol><li>烧录官方提供的<a href="https://archive.spacemit.com/image/k1/version/bianbu/v3.0/">bianbu镜像v3.0</a></li></ol><ul><li>但是启动后发现：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@k1:/sys/kernel# <span class="hljs-built_in">cat</span> /boot/config-6.1.15 | grep BPF<br>CONFIG_BPF=y<br>CONFIG_HAVE_EBPF_JIT=y<br>BPF subsystem<br>CONFIG_BPF_SYSCALL=y<br>CONFIG_BPF_JIT is not <span class="hljs-built_in">set</span>       <span class="hljs-comment"># JIT 编译器被关闭 (JIT Compiler is Disabled)</span><br>CONFIG_BPF_UNPRIV_DEFAULT_OFF=y<br>end of BPF subsystem<br>CONFIG_CGROUP_BPF=y<br>CONFIG_NETFILTER_XT_MATCH_BPF=y<br>CONFIG_BPFILTER is not <span class="hljs-built_in">set</span><br>CONFIG_NET_CLS_BPF is not <span class="hljs-built_in">set</span>   <span class="hljs-comment"># 缺少网络核心功能</span><br>CONFIG_BPF_STREAM_PARSER is not <span class="hljs-built_in">set</span><br>CONFIG_NBPFAXI_DMA is not <span class="hljs-built_in">set</span><br>CONFIG_BPF_EVENTS=y<br>root@k1:/sys/kernel# grep BTF /boot/config-x.x.x<br>CONFIG_DEBUG_INFO_BTF=y         <span class="hljs-comment"># 内核没有编译进 BTF (BPF Type Format) 信息</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>编译源码替换内核镜像</li></ol><ul><li><h2 id="备份旧文件"><a href="#备份旧文件" class="headerlink" title="备份旧文件"></a>备份旧文件</h2>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /boot<br><span class="hljs-built_in">cp</span> vmlinuz-6.6.63 vmlinuz-6.6.63.bak<br><span class="hljs-built_in">cp</span> spacemit/6.6.63/k1-x_evb.dtb spacemit/6.6.63/k1-x_evb.dtb.bak<br></code></pre></td></tr></table></figure><ul><li>vmlinuz只有一个，但是dtb有多个，需要确定是哪一个<ul><li>这里查看dtb和model输出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@k1:~# <span class="hljs-built_in">ls</span> /boot/spacemit/6.6.63/<br>k1-x_baton-camera.dtb  k1-x_fpga.dtb       k1-x_MUSE-Card.dtb    k1-x_som.dtb<br>k1-x_bit-brick.dtb     k1-x_FusionOne.dtb      k1-x_MUSE-N1.dtb    k1-x_uav.dtb<br>k1-x_deb1.dtb       k1-x_InnoBoard-Pi.dtb   k1-x_MUSE-Paper2.dtb    k1-x_ZT001H.dtb<br>k1-x_deb2.dtb       k1-x_lpi3a.dtb       k1-x_MUSE-Paper-mini-4g.dtb  k1-x_ZT_RVOH007.dtb<br>k1-x_evb.dtb       k1-x_LX-V10.dtb       k1-x_MUSE-Pi.dtb    m1-x_milkv-jupiter.dtb<br>k1-x_evb.dtb.bak       k1-x_milkv-jupiter.dtb  k1-x_MUSE-Pi-Pro.dtb<br>k1-x_fpga_1x4.dtb      k1-x_MINI-PC.dtb        k1-x_NetBridge-C1.dtb<br>k1-x_fpga_2x2.dtb      k1-x_MUSE-Book.dtb      k1-x_RV4B.dtb<br>root@k1:~# <span class="hljs-built_in">cat</span> /proc/device-tree/model<br>spacemit k1-x deb1 boardroot<br></code></pre></td></tr></table></figure><ul><li>然后就感觉可能是其中的k1-x_deb1.dtb</li><li>但是不放心就又去查看Uboot启动时加载的dtb</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">=&gt; <span class="hljs-built_in">printenv</span> boot<br>boot_default boot_device boot_devnum bootcmd bootdelay bootfs_devname<br>bootfs_part bootmenu_0 bootmenu_1 bootmenu_2 bootmenu_3 bootmenu_4<br>bootmenu_5 bootmenu_6 bootmenu_7 bootmenu_8 bootmenu_9 bootmenu_delay<br>=&gt; <span class="hljs-built_in">printenv</span> bootcmd<br>bootcmd=run autoboot; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;run autoboot&quot;</span><br></code></pre></td></tr></table></figure><ul><li>再查看autoboot: 显示如果从 eMMC 启动，那么就执行 mmc_boot 这个脚本。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printenv</span> autoboot<br>autoboot=<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> <span class="hljs-variable">$&#123;boot_device&#125;</span> = nand; <span class="hljs-keyword">then</span> run nand_boot; <span class="hljs-keyword">elif</span> <span class="hljs-built_in">test</span> <span class="hljs-variable">$&#123;boot_device&#125;</span> = nor; <span class="hljs-keyword">then</span> run nor_boot; <span class="hljs-keyword">elif</span> <span class="hljs-built_in">test</span> <span class="hljs-variable">$&#123;boot_device&#125;</span> = mmc; <span class="hljs-keyword">then</span> run mmc_boot; <span class="hljs-keyword">fi</span>;<br></code></pre></td></tr></table></figure><ul><li>查看mmc_boot: 执行 detect_dtb 脚本。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">=&gt; <span class="hljs-built_in">printenv</span> mmc_boot <br>mmc_boot=<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Try to boot from <span class="hljs-variable">$&#123;bootfs_devname&#125;</span><span class="hljs-variable">$&#123;boot_devnum&#125;</span> ...&quot;</span>; run commonargs; run set_mmc_root; run set_mmc_args; run detect_dtb; run loadknl; run loaddtb; run loadramdisk; bootm <span class="hljs-variable">$&#123;kernel_addr_r&#125;</span> <span class="hljs-variable">$&#123;ramdisk_combo&#125;</span> <span class="hljs-variable">$&#123;dtb_addr&#125;</span>; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;########### boot kernel failed by d</span><br><span class="hljs-string">=&gt; printenv detect_dtb </span><br><span class="hljs-string">detect_dtb=echo &quot;</span>product_name: <span class="hljs-variable">$&#123;product_name&#125;</span><span class="hljs-string">&quot;; run dtb_env; echo &quot;</span><span class="hljs-keyword">select</span> <span class="hljs-variable">$&#123;dtb_name&#125;</span> to load<span class="hljs-string">&quot;;</span><br></code></pre></td></tr></table></figure><ul><li>继续查看dev_env</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">=&gt; <span class="hljs-built_in">printenv</span> dtb_env<br>dtb_env=<span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;product_name&#125;</span>&quot;</span>; <span class="hljs-keyword">then</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;product_name&#125;</span>&quot;</span> = k1_evb; <span class="hljs-keyword">then</span> setenv dtb_name <span class="hljs-variable">$&#123;dtb_dir&#125;</span>/k1-x_evb.dtb; <span class="hljs-keyword">elif</span> <span class="hljs-built_in">test</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;product_name&#125;</span>&quot;</span> = k1_deb1; <span class="hljs-keyword">then</span> setenv dtb_name <span class="hljs-variable">$&#123;dtb_dir&#125;</span>/k1-x_deb1.dtb; <span class="hljs-keyword">elif</span> <span class="hljs-built_in">test</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;product_name&#125;</span>&quot;</span> = k1_deb2; <span class="hljs-keyword">then</span> setenv dtb_name <span class="hljs-variable">$&#123;dt=&gt; printenv product_name </span><br><span class="hljs-variable">product_name=k1-x_deb1</span><br><span class="hljs-variable">=&gt; printenv dtb_name</span><br><span class="hljs-variable">dtb_name=k1-x_evb.dtb</span><br></code></pre></td></tr></table></figure></li><li><strong>最后发现加载的dtb为k1-x_exb.dtb</strong></li><li>最后备份并且替换的是k1-x_exb.dtb文件</li></ul></li><li><p>clone linux6.6内核源码</p><ul><li>git clone <a href="https://gitee.com/bianbu-linux/linux-6.6.git">https://gitee.com/bianbu-linux/linux-6.6.git</a> –depth &#x3D; 1</li><li><h2 id="在原有基础上检查并打开配置并编译"><a href="#在原有基础上检查并打开配置并编译" class="headerlink" title="在原有基础上检查并打开配置并编译"></a>在原有基础上检查并打开配置并编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">make k1_defconfig<br>make menuconfig   <span class="hljs-comment"># 建议手动开启，可以打开对应更高级配置</span><br><span class="hljs-comment">#  eBPF 核心与性能 (必须开启)</span><br>./scripts/config --<span class="hljs-built_in">enable</span> BPF_JIT<br>./scripts/config --<span class="hljs-built_in">enable</span> BPF_JIT_ALWAYS_ON<br>./scripts/config --<span class="hljs-built_in">enable</span> DEBUG_INFO_BTF<br><br><span class="hljs-comment">#  eBPF 网络功能 (推荐开启)</span><br>./scripts/config --<span class="hljs-built_in">enable</span> NET_CLS_BPF<br>./scripts/config --<span class="hljs-built_in">enable</span> NET_ACT_BPF<br>./scripts/config --<span class="hljs-built_in">enable</span> XDP_SOCKETS<br><br><span class="hljs-comment">#  eBPF 追踪与调试功能 (必须开启)</span><br>./scripts/config --<span class="hljs-built_in">enable</span> BPF_EVENTS<br>./scripts/config --<span class="hljs-built_in">enable</span> KPROBES<br>./scripts/config --<span class="hljs-built_in">enable</span> UPROBES<br>./scripts/config --<span class="hljs-built_in">enable</span> TRACEPOINTS<br>./scripts/config --<span class="hljs-built_in">enable</span> FTRACE<br>./scripts/config --<span class="hljs-built_in">enable</span> KPROBE_EVENTS<br>./scripts/config --<span class="hljs-built_in">enable</span> UPROBE_EVENTS<br>./scripts/config --<span class="hljs-built_in">enable</span> FTRACE_SYSCALLS<br></code></pre></td></tr></table></figure></li><li>这里编译时报错，发现工具链不支持zicond扩展，应该是当时编译时没有开启，重新编译<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">CC      scripts/mod/empty.o<br>HOSTCC  scripts/mod/mk_elfconfig<br>CC      scripts/mod/devicetable-offsets.s<br>Assembler messages:<br>错误： rv64imac_zicond_zihintpause_zba_zbc_zbs: unknown prefixed ISA extension `zicond<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 假设你的安装目录还是 /opt/riscv</span><br>./configure --prefix=/opt/riscv --with-arch=rv64gc_zba_zbb_zbc_zbs_zicond<br><span class="hljs-comment"># 这个过程会比较长，请耐心等待</span><br>make -j$(<span class="hljs-built_in">nproc</span>) linux<br></code></pre></td></tr></table></figure><ul><li>重新编译工具链后内核可完成编译，替换镜像和设备树</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> /home/share/Image /boot/vmlinuz-6.6.63<br><span class="hljs-built_in">mv</span> /home/share/k1-x_evb.dtb /boot/spacemit/6.6.63/k1-x_evb.dtb<br></code></pre></td></tr></table></figure><ul><li>确保写入磁盘并重启</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sync</span> <br>reboot<br></code></pre></td></tr></table></figure></li></ul></li><li><p>配置libbpf并使用libbpf-bootstrap库中示例</p><ul><li>clone 仓库<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/libbpf/libbpf-bootstrap.git --depth=1<br>git submodule update --init --recursive<br><span class="hljs-built_in">cd</span> libbpf-bootstrap<br></code></pre></td></tr></table></figure></li><li>编译<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> examples/c<br>make<br></code></pre></td></tr></table></figure></li></ul></li><li><p>刚开始打算在pc上交叉编译，但是尝试了好久都没成功编译出来，于是在开发板上直接本地编译了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">- <span class="hljs-built_in">sudo</span> apt update<br>- <span class="hljs-built_in">sudo</span> apt install -y build-essential clang llvm libelf-dev libz-dev git<br>- <span class="hljs-built_in">cd</span> libbpf-bootstrap/examples/c<br>- make<br></code></pre></td></tr></table></figure></li><li><p>编译成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译成功</span><br>root@k1:~# <span class="hljs-built_in">ls</span> repo/libbpf-bootstrap/examples/c/<br>bootstrap kprobe lsm.c       minimal_ns sockfilter.c  tc.c<br>bootstrap.bpf.c  kprobe.bpf.c Makefile       minimal_ns.bpf.c  sockfilter.h  uprobe<br>bootstrap.c kprobe.c minimal       minimal_ns.c task_iter  uprobe.bpf.c<br>bootstrap.h ksyscall minimal.bpf.c       profile.bpf.c task_iter.bpf.c  uprobe.c<br>CMakeLists.txt ksyscall.bpf.c  minimal.c       profile.c task_iter.c  usdt<br>fentry ksyscall.c minimal_legacy        profile.h task_iter.h  usdt.bpf.c<br>fentry.bpf.c lsm minimal_legacy.bpf.c  sockfilter tc  usdt.c<br>fentry.c lsm.bpf.c minimal_legacy.c      sockfilter.bpf.c  tc.bpf.c  xmake.lua<br><span class="hljs-comment"># 成功运行 </span><br>root@k1:~# ./repo/libbpf-bootstrap/examples/c/bootstrap <br>TIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE<br>15:11:17 EXEC  <span class="hljs-built_in">ls</span>               692     682     /usr/bin/ls<br>15:11:17 EXIT  <span class="hljs-built_in">ls</span>               692     682     [0] (3ms)<br>15:11:23 EXEC  <span class="hljs-built_in">cat</span>              693     682     /usr/bin/cat<br>15:11:26 EXIT  <span class="hljs-built_in">cat</span>              693     682     [0] (3732ms)<br>15:11:33 EXEC  <span class="hljs-built_in">touch</span>            694     682     /usr/bin/touch<br>15:11:33 EXIT  <span class="hljs-built_in">touch</span>            694     682     [0] (2ms)<br>15:11:33 EXEC  <span class="hljs-built_in">ls</span>               695     682     /usr/bin/ls<br>15:11:33 EXIT  <span class="hljs-built_in">ls</span>               695     682     [0] (3ms)<br>15:11:36 EXEC  <span class="hljs-built_in">rm</span>               696     682     /usr/bin/rm<br>15:11:36 EXIT  <span class="hljs-built_in">rm</span>               696     682     [0] (1ms)<br>15:11:37 EXIT  bash             682     681     [0]<br>15:11:38 EXIT  sshd-session     681     671     [255]<br>15:11:38 EXIT  sshd-session     671     669     [255]<br>15:11:38 EXIT  (sd-close)       697     1       [0]<br></code></pre></td></tr></table></figure></li><li><p><strong>BPF helper functions</strong></p></li></ul><table><thead><tr><th>函数</th><th>功能</th><th>用法示例</th></tr></thead><tbody><tr><td><code>bpf_get_current_pid_tgid()</code></td><td>获取当前进程 PID 和 TID</td><td><code>u64 id = bpf_get_current_pid_tgid(); pid = id &gt;&gt; 32; tid = id &amp; 0xFFFFFFFF;</code></td></tr><tr><td><code>bpf_get_current_uid_gid()</code></td><td>当前进程的 UID&#x2F;GID</td><td>用户态安全权限判断</td></tr><tr><td><code>bpf_get_current_comm(char *buf, int size)</code></td><td>获取当前进程名</td><td>用于日志输出或过滤</td></tr><tr><td><code>bpf_ktime_get_ns()</code></td><td>返回内核时间戳（ns）</td><td>用于计算函数耗时</td></tr><tr><td><code>bpf_map_lookup_elem()</code></td><td>访问 BPF map 中的元素</td><td>统计计数&#x2F;缓存数据</td></tr><tr><td><code>bpf_map_update_elem()</code></td><td>更新 map 中的值</td><td>更新计数&#x2F;状态</td></tr><tr><td><code>bpf_map_delete_elem()</code></td><td>删除 map 元素</td><td>清理数据</td></tr><tr><td><code>bpf_probe_read()</code> &#x2F; <code>bpf_probe_read_str()</code></td><td>从内核空间安全读取数据</td><td>读取 struct task_struct 或驱动数据</td></tr><tr><td><code>bpf_perf_event_output()</code></td><td>发送数据到用户态 perf buffer</td><td>用于实时上报事件</td></tr><tr><td><code>bpf_trace_printk()</code></td><td>打印日志到 trace_pipe</td><td>调试 &#x2F; 简单监控</td></tr></tbody></table><h3 id="第一个demo"><a href="#第一个demo" class="headerlink" title="第一个demo"></a>第一个demo</h3><ul><li>早期无CO-RE模式，见此<a href="https://blog.csdn.net/kd_tx22/article/details/149087704?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~PaidSort-1-149087704-blog-125354731.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~PaidSort-1-149087704-blog-125354731.235%5Ev43%5Econtrol&utm_relevant_index=2">博客</a>demo<ul><li>bpf_load.c + libelf + 手动链接 libbpf, 需要手动配置头文件，依赖内核版本源码，使用辅助脚本等</li></ul></li><li>现代<a href="#CO-RE%E6%A8%A1%E5%BC%8F">CO-RE模式</a><ul><li>libbpf 库 + BPF Skeleton (.skel.h), libbpf 库和 bpftool 工具为你处理所有底层的繁琐工作（如ELF解析、map创建、程序加载、挂载）。</li></ul></li><li><strong>CO-RE</strong> (一次编译，到处运行)：通过 vmlinux.h 和 BTF，代码不强依赖特定内核版本，可移植性极高。</li></ul><p><a id="CO-RE模式"></a><br><strong>目的</strong>: 让一个 eBPF 程序只监控加载它自身的那个进程的 write 系统调用。</p><ul><li>minimal_ns.bpf.c: 这是运行在内核中的 eBPF 代码，它会被附加到 write 系统调用的跟踪点上。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause</span><br><span class="hljs-comment">/* Copyright (c) 2023 Hosein Bakhtiari */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bpf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bpf/bpf_helpers.h&gt;</span> <span class="hljs-comment">// BPF 辅助函数库</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sched.h&gt;</span>     <span class="hljs-comment">// 包含任务相关的结构定义</span></span><br><br><span class="hljs-type">char</span> LICENSE[] SEC(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;Dual BSD/GPL&quot;</span>;<br><br><span class="hljs-comment">// --- 全局变量 ---</span><br><span class="hljs-comment">// 这些变量位于 .bss 段，意味着它们是未初始化的全局变量。</span><br><span class="hljs-comment">// libbpf 允许用户态程序在加载 BPF 对象前，修改这些变量的值。</span><br><span class="hljs-type">int</span> my_pid = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> dev;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ino;<br><br><span class="hljs-comment">// --- BPF 程序逻辑 ---</span><br><span class="hljs-comment">// SEC(&quot;tp/syscalls/sys_enter_write&quot;) 表示将此程序附加到</span><br><span class="hljs-comment">// tracepoint &#x27;syscalls:sys_enter_write&#x27;，即任何进程进入 write 系统调用时触发。</span><br>SEC(<span class="hljs-string">&quot;tp/syscalls/sys_enter_write&quot;</span>)<br><span class="hljs-type">int</span> <span class="hljs-title function_">handle_tp</span><span class="hljs-params">(<span class="hljs-type">void</span> *ctx)</span><br>&#123;<br><span class="hljs-comment">// 定义一个结构体来接收 PID 命名空间信息</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_pidns_info</span> <span class="hljs-title">ns</span>;</span><br><br><span class="hljs-comment">// --- 身份识别与过滤 ---</span><br><span class="hljs-comment">// 调用 bpf_get_ns_current_pid_tgid 辅助函数。</span><br><span class="hljs-comment">// 它获取当前进程的 PID，但这个 PID 是相对于 dev 和 ino 所指定的 PID 命名空间而言的。</span><br><span class="hljs-comment">// dev 和 ino 是我们从用户态传递进来的，用于唯一标识一个命名空间。</span><br>bpf_get_ns_current_pid_tgid(dev, ino, &amp;ns, <span class="hljs-keyword">sizeof</span>(ns));<br><br><span class="hljs-comment">// 过滤逻辑：如果当前触发 write 系统调用的进程的 PID</span><br><span class="hljs-comment">// 不等于我们从用户态传递进来的 my_pid，就直接返回，什么也不做。</span><br><span class="hljs-keyword">if</span> (ns.pid != my_pid)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 如果 PID 匹配，就打印一条日志到跟踪管道。</span><br>bpf_printk(<span class="hljs-string">&quot;BPF triggered from PID %d.\n&quot;</span>, ns.pid);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">关键点</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">全局变量 (my_pid, dev, ino)</td><td align="left">这不是普通的全局变量。在 eBPF 中，定义在顶层的变量会被编译器放入 ELF 文件的特定段（如 .data, .bss, .rodata）。libbpf 在加载 BPF 程序时，能够识别这些变量，并允许用户态代码在 bpf_object__load() 之前对它们进行修改。这正是用户态向内核态传递配置的桥梁。</td></tr><tr><td align="left">bpf_get_ns_current_pid_tgid()</td><td align="left">这是一个非常重要的辅助函数。在复杂的容器环境中，一个进程的 PID 在容器内和在宿主机上是不同的。这个函数允许我们查询一个进程在特定PID命名空间中的 PID。它通过设备号（dev）和 inode 号（ino）来唯一确定一个命名空间。</td></tr><tr><td align="left">过滤逻辑</td><td align="left">这是整个 BPF 程序的核心。它确保了只有“目标”进程（即加载它自己的那个用户态程序）的 write 调用才能触发 bpf_printk。所有其他进程的 write 调用都会在 if 判断那里被提前过滤掉。</td></tr></tbody></table><ul><li>minimal_ns.c: 这是运行在用户空间的普通 C 程序，负责加载、设置、附加和销毁 eBPF 程序。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)</span><br><span class="hljs-comment">/* Copyright (c) 2023 Hosein Bakhtiari */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span>    <span class="hljs-comment">// stat()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>      <span class="hljs-comment">// getpid(), sleep()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bpf/libbpf.h&gt;</span>  <span class="hljs-comment">// libbpf 核心库</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;minimal_ns.skel.h&quot;</span> <span class="hljs-comment">// 自动生成的 BPF 骨架文件</span></span><br><br><span class="hljs-comment">// libbpf 的日志打印回调函数，方便调试</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">libbpf_print_fn</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> libbpf_print_level level, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, va_list args)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">vfprintf</span>(<span class="hljs-built_in">stderr</span>, format, args);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">minimal_ns_bpf</span> *<span class="hljs-title">skel</span>;</span> <span class="hljs-comment">// BPF 骨架对象指针</span><br><span class="hljs-type">int</span> err;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">sb</span>;</span> <span class="hljs-comment">// 用于接收 stat() 系统调用的结果</span><br><br>libbpf_set_print(libbpf_print_fn); <span class="hljs-comment">// 设置 libbpf 的日志回调</span><br><br><span class="hljs-comment">// --- BPF 程序生命周期：打开 ---</span><br>skel = minimal_ns_bpf__open();<br><span class="hljs-keyword">if</span> (!skel) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to open BPF skeleton\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// --- 关键部分 4: 获取自身身份信息并传递给 BPF 程序 ---</span><br><span class="hljs-comment">// /proc/self/ns/pid 是一个特殊的文件，它的 dev 和 ino 号唯一标识了当前进程所在的 PID 命名空间。</span><br><span class="hljs-keyword">if</span> (stat(<span class="hljs-string">&quot;/proc/self/ns/pid&quot;</span>, &amp;sb) == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to acquire namespace information&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 通过 skeleton 对象，访问 BPF 程序中的 .bss 全局变量并赋值。</span><br>skel-&gt;bss-&gt;dev = sb.st_dev;      <span class="hljs-comment">// 传递命名空间设备号</span><br>skel-&gt;bss-&gt;ino = sb.st_ino;      <span class="hljs-comment">// 传递命名空间 inode 号</span><br>skel-&gt;bss-&gt;my_pid = getpid();    <span class="hljs-comment">// 传递当前进程的 PID</span><br><br><span class="hljs-comment">// --- BPF 程序生命周期：加载 ---</span><br><span class="hljs-comment">// 此刻，携带了正确配置（PID和命名空间ID）的 BPF 程序被加载到内核中。</span><br>err = minimal_ns_bpf__load(skel);<br><span class="hljs-keyword">if</span> (err) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to load and verify BPF skeleton\n&quot;</span>);<br><span class="hljs-keyword">goto</span> cleanup;<br>&#125;<br><br><span class="hljs-comment">// --- BPF 程序生命周期：附加 ---</span><br><span class="hljs-comment">// 将加载到内核的 BPF 程序附加到它指定的 tracepoint 上。</span><br>err = minimal_ns_bpf__attach(skel);<br><span class="hljs-keyword">if</span> (err) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Failed to attach BPF skeleton\n&quot;</span>);<br><span class="hljs-keyword">goto</span> cleanup;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Successfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe` to see output...\n&quot;</span>);<br><br><span class="hljs-comment">// --- 关键部分 5: 触发 BPF 程序 ---</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">// 通过向 stderr 打印一个字符，来调用 write() 系统调用。</span><br><span class="hljs-comment">// 这个动作会触发我们刚刚附加的 BPF 程序。</span><br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;.&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br><br>cleanup:<br><span class="hljs-comment">// --- BPF 程序生命周期：销毁 ---</span><br><span class="hljs-comment">// 程序退出时，清理并卸载 BPF 程序。</span><br>minimal_ns_bpf__destroy(skel);<br><span class="hljs-keyword">return</span> -err;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">关键点</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">minimal_ns.skel.h</td><td align="left">这是 libbpf-bootstrap 的魔法核心。构建系统会使用 bpftool 工具根据你的 .bpf.c 文件自动生成这个头文件。它包含了 struct minimal_ns_bpf 的定义，以及 __open, __load, __attach, __destroy 等生命周期管理函数。</td></tr><tr><td align="left">skel-&gt;bss-&gt;…</td><td align="left">这就是访问 BPF 全局变量的方式。skel 指向整个 BPF 对象的句柄，skel-&gt;bss 是一个指向 BPF 程序 .bss 段变量的结构体。你可以像访问普通结构体成员一样读写它们。</td></tr><tr><td align="left">stat(“&#x2F;proc&#x2F;self&#x2F;ns&#x2F;pid”, &amp;sb): 这是获取当前进程 PID 命名空间标识符的标准方法。sb.st_dev 和 sb.st_ino 的组合在整个系统中是唯一的。</td><td align="left"></td></tr><tr><td align="left">fprintf(stderr, “.”)</td><td align="left">这行代码不仅仅是为了在终端上显示进度。它的本质是调用 write 系统调用。因为 BPF 程序监控的就是 write，并且只对自己这个 PID 感兴趣，所以这个调用就是触发 BPF 程序执行的“扳机”。</td></tr></tbody></table><p>执行流程：</p><ol><li>用户态程序启动。</li><li>它通过 stat 系统调用获取自己所在的 PID 命名空间标识（dev 和 ino），并通过 getpid() 获取自己的 PID。</li><li>它通过 BPF skeleton (skel-&gt;bss-&gt;…) 将这三个值写入 BPF 程序的全局变量中。</li><li>它调用 __load() 将配置好的 BPF 程序加载进内核。</li><li>它调用 __attach() 将 BPF 程序挂载到 write 系统调用的入口。</li><li>用户态程序进入无限循环，每秒调用一次 fprintf，这会触发 write 系统调用。</li><li>内核中的 BPF 程序被触发，它检查发现是目标进程，于是打印一条日志。</li><li>我们在另一个终端通过 cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace_pipe 就能看到这条日志。</li></ol><p>运行结果:</p><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/ebpf/image-1.png" alt="ebpf-demo"></p><h3 id="相关仓库"><a href="#相关仓库" class="headerlink" title="相关仓库"></a>相关仓库</h3><ul><li><p><code>libbpf-bootstrap</code> (仓库)</p><ul><li><strong>定位</strong>: 一个由 <code>libbpf</code> 官方维护的<strong>最佳实践模板和入门脚手架</strong>。</li><li><strong>价值</strong>: 它展示了如何正确地构建一个现代、基于 <code>libbpf</code> + CO-RE 的 eBPF 程序。它的 <code>Makefile</code> 和示例代码封装了所有复杂的构建细节：<ul><li>如何调用 <code>Clang</code> 将 <code>.bpf.c</code> 编译成 <code>.bpf.o</code>。</li><li>如何使用 <code>bpftool</code> 基于 <code>.o</code> 文件生成骨架头文件 (<code>.skel.h</code>)。</li><li>如何将用户态的 C 程序与 <code>libbpf</code> 库链接起来。</li><li>对于初学者来说，<strong>克隆这个仓库是学习 <code>libbpf</code> 开发最直接、最标准的方式</strong>。</li></ul></li></ul></li><li><p><code>awesome-ebpf</code> (仓库)</p><ul><li><strong>定位</strong>: 一个精心策划的 <strong>eBPF 资源聚合清单</strong>。</li><li><strong>价值</strong>: 如果你想了解 eBPF 生态的全貌，这里是你的起点。它系统地收集和分类了互联网上几乎所有与 eBPF 相关的优秀资源，包括但不限于：<ul><li><strong>入门教程和文档</strong></li><li><strong>知名开源项目 (如 Cilium, Falco)</strong></li><li><strong>实用的开发工具</strong></li><li><strong>深度技术博客和文章</strong></li><li><strong>会议演讲和视频</strong></li></ul></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/">linux</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/">kernel</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/trace/">trace</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/trace/libbpf/">libbpf</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/libbpf/">libbpf</category>
      
      
      <comments>https://goko-son626.github.io/post/ebpf-and-use-libbpf.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>linux内核中qspinlock锁的优缺点分析</title>
      <link>https://goko-son626.github.io/post/qspinlock.html</link>
      <guid>https://goko-son626.github.io/post/qspinlock.html</guid>
      <pubDate>Thu, 03 Apr 2025 01:25:24 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;qspinlock 是一种为现代多核系统设计的先进混合自旋锁。它巧妙地融合了两种经典锁的优点：既继承了票据锁（ticket lock）的公平性，又借鉴了 MCS 锁优异的可扩展性。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>qspinlock 是一种为现代多核系统设计的先进混合自旋锁。它巧妙地融合了两种经典锁的优点：既继承了票据锁（ticket lock）的公平性，又借鉴了 MCS 锁优异的可扩展性。</strong></em></li></ul><span id="more"></span><h4 id="1-传统spinlock："><a href="#1-传统spinlock：" class="headerlink" title="1. 传统spinlock："></a>1. 传统spinlock：</h4><ul><li>多个等待的 CPU 核心中，谁先获得锁并无保证，存在公平性问题，同时缓存一致性开销大（如MESI），CPU核心越大，cache需求越厉害，缺乏可扩展性</li></ul><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-8.png" alt="alt text"></p><h4 id="2-Ticket-spinlock"><a href="#2-Ticket-spinlock" class="headerlink" title="2. Ticket spinlock"></a>2. Ticket spinlock</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TICKET_NEXT16</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    u32 lock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">raw_tickets</span> &#123;</span><br>      <span class="hljs-comment">/* little endian */</span><br>      u16 owner;<br>      u16 next;<br>    &#125; tickets;<br>  &#125;;<br>&#125; <span class="hljs-type">arch_spinlock_t</span>;<br><br>my_ticket = atomic_fetch_inc(&amp;lock-&gt;tickets.next);<br><br><span class="hljs-keyword">while</span> (lock-&gt;tickets.owner != my_ticket)<br>  cpu_relax();<br></code></pre></td></tr></table></figure><ul><li>解决了公平问题，防止某些 CPU 永远得不到锁，但所有核都轮询同一个owner变量，read cache line成热点，限制扩展性</li></ul><h4 id="3-MCS-lock"><a href="#3-MCS-lock" class="headerlink" title="3. MCS lock"></a>3. MCS lock</h4><ul><li>本质上是一种基于链表结构的自旋锁，每个CPU有一个对应的节点(锁的副本)，基于各自不同的副本变量进行等待，锁本身是共享的，但队列节点是线程自己维护的，每个CPU只需要查询自己对应的本地cache line，仅在这个变量发生变化的时候，才需要读取内存和刷新这条cache line, 不像 classic&#x2F;ticket对共享变量进行spin</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-type">int</span> locked; <span class="hljs-comment">/* 1 if lock acquired */</span><br>  <span class="hljs-type">int</span> count;  <span class="hljs-comment">/* nesting count, see qspinlock.c */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mcs_spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mcs_spinlock **lock, <span class="hljs-keyword">struct</span> mcs_spinlock *node)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">prev</span>;</span><br><br>  <span class="hljs-comment">/* Init node */</span><br>  node-&gt;locked = <span class="hljs-number">0</span>;<br>  node-&gt;next   = <span class="hljs-literal">NULL</span>;<br><br>  prev = xchg(lock, node);<br>  <span class="hljs-keyword">if</span> (likely(prev == <span class="hljs-literal">NULL</span>)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  WRITE_ONCE(prev-&gt;next, node);<br><br>  <span class="hljs-comment">/* Wait until the lock holder passes the lock down. */</span><br>  arch_mcs_spin_lock_contended(&amp;node-&gt;locked);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个 CPU 线程创建的node 是独立的，每个线程都有自己的 node 实例。但是结构体中多了一个指针使结构体变大了，导致了“内存开销问题”：MCS 锁把竞争带来的 cache-line 抖动降低了，但牺牲了一些内存和部分结构管理的成本。</li></ul><h4 id="4-qspinlock"><a href="#4-qspinlock" class="headerlink" title="4. qspinlock"></a>4. qspinlock</h4><p><strong>include&#x2F;asm-generic&#x2F;qspinlock_types.h:</strong> 锁数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qspinlock</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-type">atomic_t</span> val;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * By using the whole 2nd least significant byte for the</span><br><span class="hljs-comment">                 * pending bit, we can allow better optimization of the lock</span><br><span class="hljs-comment">                 * acquisition for the pending bit holder.</span><br><span class="hljs-comment">                 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __LITTLE_ENDIAN</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      u8      locked;<br>      u8      pending;<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      u16     locked_pending;<br>      u16     tail;<br>    &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      u16     tail;<br>      u16     locked_pending;<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      u8      reserved[<span class="hljs-number">2</span>];<br>      u8      pending;<br>      u8      locked;<br>    &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  &#125;;<br>&#125; <span class="hljs-type">arch_spinlock_t</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Initializier</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED       &#123; &#123; .val = ATOMIC_INIT(0) &#125; &#125;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Bitfields in the atomic value:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When NR_CPUS &lt; 16K</span><br><span class="hljs-comment"> *  0- 7: locked byte</span><br><span class="hljs-comment"> *     8: pending</span><br><span class="hljs-comment"> *  9-15: not used</span><br><span class="hljs-comment"> * 16-17: tail index</span><br><span class="hljs-comment"> * 18-31: tail cpu (+1)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When NR_CPUS &gt; = 16K</span><br><span class="hljs-comment"> *  0- 7: locked byte</span><br><span class="hljs-comment"> *     8: pending</span><br><span class="hljs-comment"> *  9-10: tail index</span><br><span class="hljs-comment"> * 11-31: tail cpu (+1)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_SET_MASK(type)       (((1U &lt;&lt; _Q_ ## type ## _BITS) - 1)\</span><br><span class="hljs-meta">&lt;&lt; _Q_ ## type ## _OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_LOCKED_OFFSET        0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_LOCKED_BITS          8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_LOCKED_MASK          _Q_SET_MASK(LOCKED)</span><br></code></pre></td></tr></table></figure><p><strong>When NR_CPUS &lt; 16K：</strong><br><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-7.png" alt="alt text"></p><ul><li><code>locked</code>：用来表示这个锁是否被人持有（0：无，1：有）</li><li><code>pending</code>：可以理解为最优先持锁位，即当unlock之后只有这个位的CPU最先持锁，也有1和0</li><li><code>tail</code>：有idx+CPU构成，用来标识等待队列的最后一个节点。</li><li><code>tail_idx</code>：就是index，它作为mcs_nodes数组的下标使用</li><li><code>tail_CPU</code>：用来表示CPU的编号+1，+1因为规定tail为0的时候表示等待队列中没有成员</li></ul><p><strong>kernel&#x2F;locking&#x2F;mcs_spinlock.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-type">int</span> locked; <span class="hljs-comment">/* 1 if lock acquired */</span><br>  <span class="hljs-type">int</span> count;  <span class="hljs-comment">/* nesting count, see qspinlock.c */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>locked = 1</code>:只是说锁传到了当前加节点，但是当前节点还需要主动申请锁(qspinlock -&gt; locked &#x3D; 1)<br><code>count</code>：针对四种上下文用于追踪当前用了第几个 node（即 idx），最大为4,不够用时就fallback不排队直接自旋</p><p><strong>kernel&#x2F;locking&#x2F;qspinlock.c:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODES       4</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qnode</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> <span class="hljs-title">mcs</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PARAVIRT_SPINLOCKS</span><br>  <span class="hljs-type">long</span> reserved[<span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Per-CPU queue node structures; we can never have more than 4 nested</span><br><span class="hljs-comment"> * contexts: task, softirq, hardirq, nmi.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Exactly fits one 64-byte cacheline on a 64-bit architecture.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * PV doubles the storage and uses the second cacheline for PV state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">DEFINE_PER_CPU_ALIGNED</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> qnode, qnodes[MAX_NODES])</span>;<br></code></pre></td></tr></table></figure><ul><li>一个 CPU 上可能嵌套多个锁, <code>qnodes</code>针对四种上下文情况下，例：进程上下文中发生中断后再次获取锁</li><li>PER_CPU的优点是快，可防止抢锁时再mallock或临时分配导致延迟，成本等问题</li></ul><p><strong>申请锁：</strong></p><ol><li>快速申请<br><strong>include&#x2F;asm-generic&#x2F;qspinlock.h</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * queued_spin_lock - acquire a queued spinlock</span><br><span class="hljs-comment"> * @lock: Pointer to queued spinlock structure</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">queued_spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> qspinlock *lock)</span><br>&#123;<br>  <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (likely(atomic_try_cmpxchg_acquire(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL)))<br>    <span class="hljs-keyword">return</span>;<br><br>  queued_spin_lock_slowpath(lock, val);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-9.png" alt="alt text"></p><ol start="2"><li>中速申请</li></ol><ul><li>快速申请失败，queue中为空时，设置锁的pending位</li><li>再次检测（检查中间是否有其它cpu进入）</li><li>一直循环检测locked位</li><li>当locked位为0时，清除pending位获得锁</li></ul><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-11.png" alt="alt text"></p><ol start="3"><li>慢速申请</li></ol><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-12.png" alt="alt text"></p><table><thead><tr><th>申请</th><th>操作</th></tr></thead><tbody><tr><td>快速申请</td><td>这个锁当前没有人持有，直接通过cmpxchg()设置locked域即可获取了锁</td></tr><tr><td>中速申请</td><td>锁已经被人持有，但是MCS链表没有其他人，有且仅有一个人在等待这个锁。设置pending域，表示是第一顺位继承者，自旋等待lock-&gt; locked清0，即锁持有者释放锁</td></tr><tr><td>慢速申请</td><td>进入到queue中自旋等待，若为队列头（队列中没有等待的cpu），说明它已排到最前，可以开始尝试获取锁；否则，它会自旋等待前一个节点释放锁，并通知它可以尝试获取锁了</td></tr></tbody></table><p><strong>end:</strong></p><ul><li><p>如果只有1个或2个CPU试图获取锁，那么只需要一个4字节的qspinlock就可以了，其所占内存的大小和ticket spinlock一样。当有3个以上的CPU试图获取锁，则需要(N-2)个MCS node</p></li><li><p>qspinlock中加入”pending”位域的意义，如果是两个CPU试图获取锁，那么第二个CPU只需要简单地设置”pending”为1，而不用创建一个MCS node</p></li><li><p>试图加锁的CPU数目超过3个，使用ticket spinlock机制就会造成多个CPU的cache line刷新的问题，而qspinlock可以利用MCS node队列来解决这个问题</p></li><li><p>在多核争用严重场景下，qspinlock 让等待者在本地内存区域自旋，减少了锁的缓存抖动和对总线的竞争消耗</p></li><li><p>RISCV_QUEUED_SPINLOCKS 只应在平台(RISC-V)具有 Zabha 或 Ziccrse 时启用，不支持的情况不要选用</p></li><li><p>优先级反转问题，queue会保证了FIFO提高了公平性，但它无法感知任务的优先级，可能因为排在队列前方的低优先级任务未释放锁而发生等待，从而导致 优先级反转</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/">linux</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/">kernel</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/lock/">lock</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/lock/qspinlock/">qspinlock</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/qspinlock/">qspinlock</category>
      
      
      <comments>https://goko-son626.github.io/post/qspinlock.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>libbpf, bcc和bpftrace的结构和关联分析</title>
      <link>https://goko-son626.github.io/post/libbpf-bcc-and-bpftrace.html</link>
      <guid>https://goko-son626.github.io/post/libbpf-bcc-and-bpftrace.html</guid>
      <pubDate>Sun, 02 Mar 2025 08:40:24 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;libbpf bcc 和 bpftrace之间的结构以及和内核的关联&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>libbpf bcc 和 bpftrace之间的结构以及和内核的关联</strong></em></li></ul><span id="more"></span><h3 id="libbpf-bcc-和-bpftrace之关系结构图-仅参考"><a href="#libbpf-bcc-和-bpftrace之关系结构图-仅参考" class="headerlink" title="libbpf bcc 和 bpftrace之关系结构图(仅参考)"></a>libbpf bcc 和 bpftrace之关系结构图(仅参考)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash">+-----------------------------------------------------------------------------+<br>|                             用户空间 (User Space)                           |<br>|-----------------------------------------------------------------------------|<br>|      [高层抽象/工具]                                                        |<br>|                                                                             |<br>|   +-----------------+                                                       |<br>|   |   bpftrace(C++) |                                                       |<br>|   | (诊断与排障语言)|                                                       |<br>|   +-------+---------+                                                       |<br>|           |                                                                 |<br>| 内部解析器解析用户脚本，翻译成C代码                                         |<br>| 将这个C代码实时编译成 eBPF 字节码(Clang/LLVM)                               |<br>| 使用 libbpf 的C API 来加载和管理eBPF程序                                    |<br>|           |                                                                 |<br>|           |                   +----------------+                            |<br>|           |                   |BCC(内部实现C++)|  python/Lua/c++高级语言封装|<br>|           |                   | (快速原型框架) |  header file               |<br>|           |Clang/LLVM         +-------------+--+                            |<br>|           |                                 |                               |<br>|           |                   运行时把c代码编译成eBPF字段，API加载交互      |<br>|           |                   还是写C,只是编译和加载被Python框架封装了      |<br>|           |                                 |     Clang/LLVM                |<br>|  +---------------------------+              ----------------------          |<br>|  |         libbpf(C)         |                                   |          |<br>|  | (是纯C开发库, 提供CO-RE)  |------------------------------------          |<br>|  | 封装bpf()和Maps API)      |                                    |         |<br>|  +-------------+-------------+                                    |         |<br>|                                                                   |         |<br>|                BPF Maps (e.g., RingBuf, Hash)              | System Call    |<br>|     &lt;------------------------------------------------------&gt; (bpf())        |<br>|                (内核与用户空间的数据通道)                  | (控制与加载)   |<br>|                                                            |                |<br>+------------------------------------------------------------+----------------+<br>|                                  内核空间 (Kernel Space)   |                |<br>|-----------------------------------------------------------------------------|<br>|                                                            |                |<br>|       BPF Maps (内核中的键值对存储) &lt;-----------------------------+         |<br>|                                                            |      |         |<br>|   +---------------------------------------------------+&lt;---|      |         |<br>|   |                  eBPF 子系统                      |           |         |<br>|   |                                                   |           |         |<br>|   |  +-----------+     +----------+     +-----------+ |           |         |<br>|   |  | Verifier  | --&gt; |   JIT    | --&gt; |    CPU    | |           |         |<br>|   |  | (安全检查)|     | (编译优化) |   | (原生执行)| |           |         |<br>|   |  +-----------+     +----------+     +-----------+ |           |         |<br>|   |                                                   |           |         |<br>|   |        ebpf 程序 (你的.bpf.c代码)                 |           |         |<br>|   |                                                   |           |         |<br>|   +-----------------------+---------------------------+           |         |<br>|                           ^                                       |         |<br>|                           | (事件触发)                 (读取/写入)|         |<br>|                           |                                       v         |<br>|   +-----------------------+-------------------------------------------+     |<br>|   |                      内核钩子 (kernel hooks)                      |     |<br>|   |                                                                   |     |<br>|   |  ftrace (kprobes, tracepoints), LSM, TC, XDP, Sockets ...         |     |<br>|   |  (BTF - 提供内核元数据, 增强钩子能力)                             |     |<br>|   +-------------------------------------------------------------------+     |<br>|                                                                             |<br>+-----------------------------------------------------------------------------+<br></code></pre></td></tr></table></figure><ul><li><p>BCC (BPF Compiler Collection)</p><ul><li><strong>构成</strong>: BCC 是一个强大的 eBPF 开发工具包和框架。其核心是一个 <strong>C++ 库</strong>，并提供了 <strong>Python、C++、Go 等多种语言的前端封装</strong>，其中 Python 前端最为流行和成熟。</li><li><strong>核心机制</strong>:<ul><li><strong>运行时编译</strong>: BCC 的标志性特点是在程序<strong>运行时</strong>动态编译 eBPF C 代码。开发者在 Python 等脚本中嵌入 C 代码字符串，BCC 框架在后台调用 <strong><code>libclang</code> (Clang 的库版本)</strong> 将其编译成 eBPF 字节码。</li><li><strong>自有的加载器</strong>: BCC 拥有一套<strong>自研的加载器逻辑</strong>，负责处理字节码的加载、Map 创建以及与内核的交互。</li></ul></li><li><strong>与 libbpf 的关系</strong>:<ul><li>BCC 诞生早于 <code>libbpf</code> 的成熟期，因此其核心不依赖 <code>libbpf</code>。</li><li>然而，为了拥抱社区标准和利用 CO-RE 等现代特性，<strong>新版本的 BCC 已经开始逐步集成 <code>libbpf</code></strong>，并提供基于 <code>libbpf</code> 的新工具和 API。</li></ul></li></ul></li><li><p>libbpf</p><ul><li><strong>构成</strong>: <code>libbpf</code> 是一个由内核社区维护的、用于开发 eBPF 应用的<strong>纯 C 语言核心库</strong>。它被认为是构建现代、高性能、可移植 eBPF 程序的<strong>事实标准</strong>。</li><li><strong>核心机制</strong>:<ul><li><strong>预编译 (Ahead-of-Time)</strong>: <code>libbpf</code> 的典型工作流是在开发阶段就将 eBPF C 代码（<code>.bpf.c</code>）编译成包含字节码的 ELF 对象文件（<code>.bpf.o</code>）。</li><li><strong>智能加载</strong>: 用户态程序通过调用 <code>libbpf</code> 的 API，可以智能地解析 <code>.o</code> 文件，并将 eBPF 程序和 Maps 加载到内核。</li><li><strong>CO-RE (一次编译，到处运行)</strong>: 这是 <code>libbpf</code> 的<strong>王牌特性</strong>。它利用 <strong>BTF (BPF Type Format)</strong> 元数据，在加载时动态调整 eBPF 程序，以解决因内核版本不同导致的数据结构差异问题，极大地增强了程序的可移植性。</li></ul></li></ul></li><li><p>bpftrace</p><ul><li><strong>定位与构成</strong>: <code>bpftrace</code> 是一款专为 Linux 设计的<strong>高级动态追踪语言和命令行工具</strong>。它的语法简洁强大，类似 <code>awk</code> 和 <code>DTrace</code>，让使用者能用极少的代码快速排查系统性能问题。</li><li><strong>核心机制</strong>:<ul><li><strong>高级语言到 C 的翻译</strong>: <code>bpftrace</code> 的核心是一个<strong>C++ 程序</strong>，它负责将用户编写的高级脚本<strong>实时翻译</strong>成 eBPF C 代码。</li><li><strong>后端依赖</strong>: 它不直接与内核交互，而是<strong>依赖一个后端引擎</strong>来完成编译和加载。</li></ul></li><li><strong>与 libbpf&#x2F;BCC 的关系</strong>:<ul><li><strong>历史与现在</strong>: 早期 <code>bpftrace</code> 依赖 <code>BCC</code> 作为其后端。为了追求更好的性能、更轻的依赖和 CO-RE 支持，<strong>现代版本的 <code>bpftrace</code> 已经默认切换到使用 <code>libbpf</code> 作为其核心后端</strong>。</li></ul></li></ul></li></ul><h3 id="对比表格：libbpf-vs-BCC-vs-bpftrace"><a href="#对比表格：libbpf-vs-BCC-vs-bpftrace" class="headerlink" title="对比表格：libbpf vs BCC vs bpftrace"></a><strong>对比表格：<code>libbpf</code> vs <code>BCC</code> vs <code>bpftrace</code></strong></h3><table><thead><tr><th align="left">特性</th><th align="left">libbpf</th><th align="left">BCC</th><th align="left">bpftrace</th></tr></thead><tbody><tr><td align="left"><strong>定位</strong></td><td align="left"><strong>核心库 (Core Library)</strong></td><td align="left"><strong>开发框架 (Framework)</strong></td><td align="left"><strong>高级工具&#x2F;语言 (High-level Tool)</strong></td></tr><tr><td align="left"><strong>主要用途</strong></td><td align="left">生产级应用、Agent、底层开发</td><td align="left">快速原型、教学、脚本化开发</td><td align="left">实时排障、命令行即时查询</td></tr><tr><td align="left"><strong>编程接口</strong></td><td align="left"><strong>C&#x2F;C++ API</strong></td><td align="left"><strong>Python&#x2F;C++ API</strong></td><td align="left"><strong>专用脚本语言</strong> (类 <code>awk</code>)</td></tr><tr><td align="left"><strong>编译时机</strong></td><td align="left"><strong>预编译 (开发时)</strong></td><td align="left"><strong>运行时</strong></td><td align="left"><strong>运行时</strong></td></tr><tr><td align="left"><strong>CO-RE 可移植性</strong></td><td align="left"><strong>原生支持 (核心优势)</strong></td><td align="left"><strong>支持有限&#x2F;较弱</strong></td><td align="left"><strong>通过 libbpf 后端获得支持</strong></td></tr><tr><td align="left"><strong>运行时依赖</strong></td><td align="left"><strong>极轻量</strong></td><td align="left"><strong>重量级</strong></td><td align="left"><strong>中量级</strong></td></tr><tr><td align="left">… <strong>需要 <code>libbpf.so</code>?</strong></td><td align="left">是</td><td align="left">否 (但正在集成)</td><td align="left">是 (现代版本)</td></tr><tr><td align="left">… <strong>需要 <code>Clang/LLVM</code>?</strong></td><td align="left"><strong>否</strong></td><td align="left"><strong>是</strong></td><td align="left"><strong>是</strong></td></tr><tr><td align="left">… <strong>需要内核头文件?</strong></td><td align="left"><strong>否</strong></td><td align="left"><strong>是</strong> (传统方式)</td><td align="left"><strong>否</strong></td></tr><tr><td align="left">… <strong>需要 <code>Python</code>?</strong></td><td align="left">否</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left"><strong>部署产物</strong></td><td align="left"><strong>单个二进制文件</strong></td><td align="left">Python脚本 + 运行时环境</td><td align="left"><code>bpftrace</code> 工具 + 运行时环境</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left"><strong>最高</strong> (启动快，无运行时编译开销)</td><td align="left"><strong>中等</strong> (有运行时编译开销)</td><td align="left"><strong>中高</strong> (比BCC快，但仍有运行时开销)</td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left"><strong>最高</strong> (完全控制)</td><td align="left"><strong>高</strong> (动态修改 C 代码方便)</td><td align="left"><strong>中等</strong> (受限于语言特性)</td></tr><tr><td align="left"><strong>易用性</strong></td><td align="left"><strong>低</strong> (最复杂，需手写 C)</td><td align="left"><strong>中等</strong> (Python 封装，较友好)</td><td align="left"><strong>最高</strong> (最简单，一行命令)</td></tr><tr><td align="left"><strong>最适合场景</strong></td><td align="left">需要嵌入到其他程序中的长期监控Agent，如Cilium、Datadog Agent。</td><td align="left">编写一次性的调试脚本，探索内核行为，快速验证想法。</td><td align="left">系统管理员在服务器上快速定位一个具体问题，如”哪个进程在大量读写磁盘？”</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/">linux</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/">kernel</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/trace/">trace</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/trace/ebpf/">ebpf</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/libbpf/">libbpf</category>
      
      <category domain="https://GoKo-Son626.github.io/tags/bpftrace/">bpftrace</category>
      
      <category domain="https://GoKo-Son626.github.io/tags/bcc/">bcc</category>
      
      
      <comments>https://goko-son626.github.io/post/libbpf-bcc-and-bpftrace.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>linux内核启动流程分析2</title>
      <link>https://goko-son626.github.io/post/kernel-1.html</link>
      <guid>https://goko-son626.github.io/post/kernel-1.html</guid>
      <pubDate>Sat, 12 Oct 2024 14:20:39 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;简单分析启动过程中初始化等操作流程&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>简单分析启动过程中初始化等操作流程</strong></em></li></ul><span id="more"></span><ul><li>继续上文的start_kernle()</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c">asmlinkage <span class="hljs-type">void</span> __init <span class="hljs-title function_">start_kernel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> *command_line;<br><br>    <span class="hljs-comment">/*  最早期初始化（调试、安全、CPU信息） */</span><br>    lockdep_init();               <span class="hljs-comment">// 锁依赖检测</span><br>    smp_setup_processor_id();     <span class="hljs-comment">// 设置当前 CPU ID</span><br>    debug_objects_early_init();   <span class="hljs-comment">// 调试对象初始化</span><br>    boot_init_stack_canary();     <span class="hljs-comment">// 栈溢出保护</span><br>    cgroup_init_early();          <span class="hljs-comment">// 控制组（早期阶段）</span><br><br>    <span class="hljs-comment">/*  禁用中断，初始化时钟 &amp; 架构 */</span><br>    local_irq_disable();<br>    early_boot_irqs_disabled = <span class="hljs-literal">true</span>;<br>    tick_init();                  <span class="hljs-comment">// 初始化 tick timer</span><br>    boot_cpu_init();              <span class="hljs-comment">// 标记 boot CPU</span><br>    page_address_init();          <span class="hljs-comment">// 页地址映射表初始化</span><br>    printk(KERN_NOTICE <span class="hljs-string">&quot;%s&quot;</span>, linux_banner); <span class="hljs-comment">// 打印内核 banner</span><br>    setup_arch(&amp;command_line);    <span class="hljs-comment">// **架构相关初始化**（内存、MMU、DTB）</span><br><br>    <span class="hljs-comment">/*  初始化内存管理 */</span><br>    mm_init_owner(&amp;init_mm, &amp;init_task);<br>    mm_init_cpumask(&amp;init_mm);<br>    setup_command_line(command_line); <span class="hljs-comment">// 解析 boot 参数</span><br>    setup_nr_cpu_ids();<br>    setup_per_cpu_areas();<br>    smp_prepare_boot_cpu();           <span class="hljs-comment">// 准备 CPU 数据结构</span><br>    build_all_zonelists(<span class="hljs-literal">NULL</span>);        <span class="hljs-comment">// 建立内存分配区域</span><br>    page_alloc_init();                <span class="hljs-comment">// 页分配器初始化</span><br><br>    <span class="hljs-comment">/*  参数解析 + 基础子系统初始化 */</span><br>    parse_early_param();              <span class="hljs-comment">// 解析 early 参数</span><br>    parse_args(...);                  <span class="hljs-comment">// 解析 boot args</span><br>    setup_log_buf(<span class="hljs-number">0</span>);                 <span class="hljs-comment">// 日志缓冲区</span><br>    trap_init();                      <span class="hljs-comment">// 异常处理</span><br>    mm_init();                        <span class="hljs-comment">// 完整内存初始化</span><br><br>    <span class="hljs-comment">/*  调度器 &amp; 同步机制 */</span><br>    sched_init();                     <span class="hljs-comment">// 调度器初始化</span><br>    preempt_disable();                <span class="hljs-comment">// 禁止抢占</span><br>    rcu_init();                       <span class="hljs-comment">// RCU</span><br>    radix_tree_init();                <span class="hljs-comment">// radix 树</span><br><br>    <span class="hljs-comment">/*  中断和定时器 */</span><br>    early_irq_init();<br>    init_IRQ();                       <span class="hljs-comment">// 完整中断</span><br>    init_timers();                    <span class="hljs-comment">// 普通 timer</span><br>    hrtimers_init();                  <span class="hljs-comment">// 高精度 timer</span><br>    softirq_init();                   <span class="hljs-comment">// 软件中断</span><br>    time_init();                      <span class="hljs-comment">// 时间子系统</span><br><br>    <span class="hljs-comment">/*  启用中断 + 控制台 */</span><br>    local_irq_enable();<br>    console_init();<br><br>    <span class="hljs-comment">/*  剩余初始化 + 创建 init 进程 */</span><br>    security_init();<br>    vfs_caches_init(totalram_pages);  <span class="hljs-comment">// 文件系统缓存</span><br>    signals_init();<br>    rest_init();                      <span class="hljs-comment">// 创建 init/kthreadd</span><br>&#125;<br></code></pre></td></tr></table></figure><p>rest_init() -&gt; rest_init()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> noinline <span class="hljs-type">void</span> __init_refok <span class="hljs-title function_">rest_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> pid;<br>    rcu_scheduler_starting();  <span class="hljs-comment">// **RCU（读-复制-更新）调度器初始化**</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 创建 init 进程（PID 1）</span><br><span class="hljs-comment">     * 调用 kernel_thread() → do_fork()，目标函数是 kernel_init()</span><br><span class="hljs-comment">     */</span><br>    kernel_thread(kernel_init, <span class="hljs-literal">NULL</span>, CLONE_FS | CLONE_SIGHAND);<br>    numa_default_policy();  <span class="hljs-comment">// **设置 NUMA 默认策略**</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 创建 kthreadd 线程（内核线程管理器，负责所有内核线程）</span><br><span class="hljs-comment">     * 它的 PID 通常是 2</span><br><span class="hljs-comment">     */</span><br>    pid = kernel_thread(kthreadd, <span class="hljs-literal">NULL</span>, CLONE_FS | CLONE_FILES);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 通过 PID 查找 kthreadd 的 task_struct，并保存到全局变量</span><br><span class="hljs-comment">     */</span><br>    rcu_read_lock();<br>    kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);<br>    rcu_read_unlock();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 通知 kernel_init()（init 进程）可以继续执行</span><br><span class="hljs-comment">     */</span><br>    complete(&amp;kthreadd_done);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 当前任务是 idle 任务（PID 0）</span><br><span class="hljs-comment">     * 执行 schedule() 一次，启动调度</span><br><span class="hljs-comment">     */</span><br>    init_idle_bootup_task(current);<br>    schedule_preempt_disabled();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 进入 idle 循环（CPU 空闲状态）</span><br><span class="hljs-comment">     * 此后 init 和 kthreadd 运行在用户态，PID 0 进入低功耗空转</span><br><span class="hljs-comment">     */</span><br>    cpu_idle();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>kernel_init</code>: Wait until <code>kthreadd</code> is all set-up: <code>wait_for_completion(&amp;kthreadd_done);</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">kernel_init</span><span class="hljs-params">(<span class="hljs-type">void</span> * unused)</span><br>&#123;<br>    wait_for_completion(&amp;kthreadd_done);  <span class="hljs-comment">// 等待 kthreadd 创建完成（PID 2）</span><br><br>    gfp_allowed_mask = __GFP_BITS_MASK;   <span class="hljs-comment">// 允许内存分配（调度器已准备好，可以阻塞分配）</span><br><br>    set_mems_allowed(node_states[N_HIGH_MEMORY]);  <span class="hljs-comment">// init 进程允许在任意内存节点分配</span><br>    set_cpus_allowed_ptr(current, cpu_all_mask);   <span class="hljs-comment">// init 进程可以在所有 CPU 上运行</span><br><br>    cad_pid = task_pid(current);  <span class="hljs-comment">// 保存 init 进程 PID</span><br><br>    smp_prepare_cpus(setup_max_cpus);  <span class="hljs-comment">// 准备多核 CPU 初始化</span><br><br>    do_pre_smp_initcalls();  <span class="hljs-comment">// 调用 SMP 初始化前的 initcall</span><br>    lockup_detector_init();  <span class="hljs-comment">// 启动死锁检测机制</span><br><br>    smp_init();              <span class="hljs-comment">// 启动其他 CPU（多核）</span><br>    sched_init_smp();        <span class="hljs-comment">// 初始化 SMP 调度器</span><br><br>    do_basic_setup();        <span class="hljs-comment">// 驱动子系统、文件系统等核心初始化</span><br><br>    <span class="hljs-comment">// 打开 /dev/console 作为标准输入输出</span><br>    <span class="hljs-keyword">if</span> (sys_open((<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *) <span class="hljs-string">&quot;/dev/console&quot;</span>, O_RDWR, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br>        printk(KERN_WARNING <span class="hljs-string">&quot;Warning: unable to open an initial console.\n&quot;</span>);<br><br>    (<span class="hljs-type">void</span>) sys_dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 复制文件描述符，stdin → stdout</span><br>    (<span class="hljs-type">void</span>) sys_dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 复制文件描述符，stdin → stderr</span><br><br>    <span class="hljs-comment">// 检查是否有 early userspace init，如果没有，则默认 /init</span><br>    <span class="hljs-keyword">if</span> (!ramdisk_execute_command)<br>        ramdisk_execute_command = <span class="hljs-string">&quot;/init&quot;</span>;<br><br>    <span class="hljs-comment">// 如果 /init 不存在，准备挂载根文件系统</span><br>    <span class="hljs-keyword">if</span> (sys_access((<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *) ramdisk_execute_command, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>) &#123;<br>        ramdisk_execute_command = <span class="hljs-literal">NULL</span>;<br>        prepare_namespace();  <span class="hljs-comment">// 挂载根文件系统</span><br>    &#125;<br><br>    <span class="hljs-comment">// 进入用户空间：释放 __init 段，执行 init 程序</span><br>    init_post();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>kernel_init()</code> -&gt; <code>init_post()</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> noinline <span class="hljs-type">int</span> <span class="hljs-title function_">init_post</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    async_synchronize_full();   <span class="hljs-comment">// 等待所有异步 __init 任务完成</span><br>    free_initmem();             <span class="hljs-comment">// 释放 __init 段内存（只执行一次）</span><br>    mark_rodata_ro();           <span class="hljs-comment">// 将只读数据段标记为只读，防止修改</span><br>    system_state = SYSTEM_RUNNING; <span class="hljs-comment">// 内核状态切换为运行态</span><br>    numa_default_policy();      <span class="hljs-comment">// 设置默认 NUMA 策略</span><br><br>    current-&gt;signal-&gt;flags |= SIGNAL_UNKILLABLE;  <span class="hljs-comment">// init 进程不可被 kill</span><br><br>    <span class="hljs-comment">// 如果 ramdisk_execute_command 存在（initrd/initramfs 提供的 init）</span><br>    <span class="hljs-keyword">if</span> (ramdisk_execute_command) &#123;<br>        run_init_process(ramdisk_execute_command);  <span class="hljs-comment">// 尝试执行 /init</span><br>        printk(KERN_WARNING <span class="hljs-string">&quot;Failed to execute %s\n&quot;</span>,<br>               ramdisk_execute_command);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果uboot中内核参数 init=xxx 指定了 init 程序</span><br>    <span class="hljs-keyword">if</span> (execute_command) &#123;<br>        run_init_process(execute_command);  <span class="hljs-comment">// 执行指定 init</span><br>        printk(KERN_WARNING <span class="hljs-string">&quot;Failed to execute %s. Attempting defaults...\n&quot;</span>,<br>               execute_command);<br>    &#125;<br><br>    <span class="hljs-comment">// 按优先级尝试启动用户空间的 init 进程</span><br>    run_init_process(<span class="hljs-string">&quot;/sbin/init&quot;</span>);<br>    run_init_process(<span class="hljs-string">&quot;/etc/init&quot;</span>);<br>    run_init_process(<span class="hljs-string">&quot;/bin/init&quot;</span>);<br>    run_init_process(<span class="hljs-string">&quot;/bin/sh&quot;</span>);  <span class="hljs-comment">// 最后 fallback 到 shell</span><br><br>    <span class="hljs-comment">// 如果所有都失败，内核 panic</span><br>    panic(<span class="hljs-string">&quot;No init found. Try passing init= option to kernel. &quot;</span><br>          <span class="hljs-string">&quot;See Linux Documentation/init.txt for guidance.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">run_init_process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *init_filename)</span><br>&#123;<br>    argv_init[<span class="hljs-number">0</span>] = init_filename;    <span class="hljs-comment">// 设置 argv[0] 为要执行的 init 程序路径</span><br>    kernel_execve(init_filename, argv_init, envp_init); <br>    <span class="hljs-comment">// 调用 kernel_execve()，在内核态执行 execve 系统调用，加载用户态程序</span><br>    <span class="hljs-comment">// init_filename: 要执行的程序路径（/sbin/init 等）</span><br>    <span class="hljs-comment">// argv_init: 参数数组（至少包含 init_filename）</span><br>    <span class="hljs-comment">// envp_init: 环境变量（初始化时的默认环境变量）</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/">linux</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/">kernel</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/kernel-start/">kernel_start</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/kernel-start/">kernel_start</category>
      
      
      <comments>https://goko-son626.github.io/post/kernel-1.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>linux内核启动流程分析1</title>
      <link>https://goko-son626.github.io/post/kernel.html</link>
      <guid>https://goko-son626.github.io/post/kernel.html</guid>
      <pubDate>Thu, 10 Oct 2024 08:27:49 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;*&lt;em&gt;&lt;strong&gt;简单分析启动过程中的初始化内容&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>*<em><strong>简单分析启动过程中的初始化内容</strong></em></li></ul><span id="more"></span><h4 id="1-寻找执行入口"><a href="#1-寻找执行入口" class="headerlink" title="1. 寻找执行入口"></a>1. 寻找执行入口</h4><ul><li>和之前找uboot的执行入口一样，在编译时查看编译文件的顺序和链接文件发现入口为<code>arch/armc/kernel/head.S</code></li></ul><p>“arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds”<br>…<br>. &#x3D; 0xC0000000 + 0x00008000<br>.head.text : {<br>text &#x3D; .;<br>*(.head.text)<br>}<br>…</p><p>“arch&#x2F;arm&#x2F;kernel&#x2F;head.S”<br>…<br>.arm<br>__HEAD<br>ENTRY(stext)<br>…</p><p>“include&#x2F;linux&#x2F;init.h”<br>…<br>#define __HEAD .section  “.head.text”, “ax”<br>#define __INIT .section  “.init.text”, “ax”<br>#define __FINIT .previous<br>…</p><h4 id="2-head-S"><a href="#2-head-S" class="headerlink" title="2. head.S"></a>2. head.S</h4><ol><li><p>确定 CPU 类型和启动模式（ARM&#x2F;Thumb、SVC 模式）</p></li><li><p>关闭中断</p></li><li><p>检查处理器是否支持必要功能</p></li><li><p>初始化物理地址偏移</p></li><li><p>验证 ATAGs&#x2F;DTB 参数</p></li><li><p>创建初始页表（identity mapping）</p></li><li><p>初始化 CPU 特定功能</p></li><li><p>开启 MMU（启用虚拟地址空间）</p></li><li><p>跳转到 __mmap_switched 进入内核下一阶段</p></li><li><p>段和入口定义</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">.arm<br>__HEAD               <span class="hljs-comment">// 定义在 .head.text 段</span><br>ENTRY(stext)         <span class="hljs-comment">// 内核入口符号 stext</span><br></code></pre></td></tr></table></figure><ul><li>.head.text 段：用于放置启动代码。</li><li>stext 是 ARM Linux 的 第一个执行入口（在物理地址 0xC0008000，即 PAGE_OFFSET + TEXT_OFFSET）。</li></ul><ol start="2"><li>检查 ARM&#x2F;Thumb 模式并切换</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">THUMB( adr r9, BSYM(<span class="hljs-number">1f</span>) )<br>THUMB( bx  r9 )<br>THUMB( .thumb )<br>THUMB(<span class="hljs-number">1</span>: )<br></code></pre></td></tr></table></figure><ul><li>如果内核是 Thumb-2 格式(一种ARM的嵌入式格式)，先跳转并切换到 Thumb 状态。</li><li>否则继续 ARM 模式。</li></ul><ol start="3"><li>设置 CPU 为 SVC 模式，关闭 IRQ&#x2F;FIQ</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">setmode PSR_F_BIT | PSR_I_BIT | SVC_MODE, r9<br></code></pre></td></tr></table></figure><ul><li>PSR_F_BIT：屏蔽 FIQ</li><li>PSR_I_BIT：屏蔽 IRQ</li><li>SVC_MODE：进入管理模式（Supervisor mode）</li></ul><p>保证启动过程不会被中断打断。</p><ol start="4"><li>获取 CPU ID 并匹配处理器类型</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mrc p15, <span class="hljs-number">0</span>, r9, c0, c0     @ 获取 CP15 c0：主 ID 寄存器<br>bl  __lookup_processor_type @ 查找 CPU 类型表，返回 r5=procinfo<br>movs r10, r5               @ 如果 r5=<span class="hljs-number">0</span>，说明不支持该 CPU<br>beq __error_p              @ 出错处理<br></code></pre></td></tr></table></figure><ul><li>读取 CPU ID（ARM 架构寄存器）。</li><li>检查是否在 内核支持的 CPU 列表里。</li></ul><ol start="5"><li>LPAE（ARMv7+）检查</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mrc p15, <span class="hljs-number">0</span>, r3, c0, c1, <span class="hljs-number">4</span>   @ 读取 ID_MMFR0<br>and r3, r3, #<span class="hljs-number">0xf</span><br>cmp r3, #<span class="hljs-number">5</span>                  @ 检查是否支持长描述符页表<br>blo __error_p<br></code></pre></td></tr></table></figure><ul><li>如果是 ARM LPAE 模式，检查是否支持 64-bit 页表。</li></ul><ol start="6"><li>计算 PHYS_OFFSET</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">adr r3, <span class="hljs-number">2f</span><br>ldmia r3, &#123;r4, r8&#125;<br>sub r4, r3, r4<br>add r8, r8, r4<br></code></pre></td></tr></table></figure><ul><li>通过位置无关代码计算 物理偏移量，用于页表映射。</li><li>如果 CONFIG_XIP_KERNEL（执行在闪存），则直接 ldr r8, &#x3D;PHYS_OFFSET。</li></ul><ol start="7"><li>验证传入参数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">bl __vet_atags       @ 检查 ATAGs 或 Device Tree<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP_ON_UP</span><br>bl __fixup_smp       @ 单核系统伪 SMP 修复<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARM_PATCH_PHYS_VIRT</span><br>bl __fixup_pv_table  @ 修正物理/虚拟基址差异<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>检查 启动参数有效性（machine ID, atags&#x2F;dtb）。</li><li>如果是单核系统 + SMP 配置，做补丁。</li><li>修补物理&#x2F;虚拟地址差异。</li></ul><ol start="8"><li>创建启动页表</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">bl __create_page_tables<br></code></pre></td></tr></table></figure><ul><li>这是关键步骤，创建初始页表，映射：<ul><li>identity mapping：物理地址映射到相同的虚拟地址（用于开启 MMU）</li><li>内核虚拟基地址 (0xC0000000) 映射到物理地址</li><li>UART IO 区域（如果开启 DEBUG_LL）</li></ul></li><li>进入 __create_page_tables 的逻辑：<ul><li>分配页表内存 (pgtbl)</li><li>清空页表</li><li>identity map 启动代码区域（__turn_mmu_on）</li><li>映射内核代码区域 [KERNEL_START, KERNEL_END)</li><li>映射 boot 参数区（ATAGs 或 DTB）</li><li>如果 DEBUG_LL：映射 UART 寄存器地址</li><li>返回页表基地址（r4）</li></ul></li></ul><ol start="9"><li>初始化 CPU</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">ldr r13, =__mmap_switched   @ MMU 打开后跳转地址<br>adr lr, BSYM(<span class="hljs-number">1f</span>)            @ 返回地址<br>mov r8, r4                  @ 设置页表基地址<br>ARM( add pc, r10, #PROCINFO_INITFUNC )<br></code></pre></td></tr></table></figure><ul><li>调用 CPU 特定初始化代码（在 arch&#x2F;arm&#x2F;mm&#x2F;proc-*.S）。</li><li>初始化完成后返回，准备打开 MMU。</li></ul><ol start="10"><li>打开 MMU</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">b __enable_mmu<br></code></pre></td></tr></table></figure><ul><li>__enable_mmu：<ul><li>配置 域访问控制寄存器（domain access control）</li><li>设置页表基地址（TTBR）</li><li>修改 CP15 控制寄存器（r0），打开 MMU（bit 0），可能还打开缓存。</li></ul></li></ul><p>然后执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">b __turn_mmu_on<br></code></pre></td></tr></table></figure><ul><li>__turn_mmu_on：<ul><li>写 CP15 控制寄存器，开启 MMU</li><li>切换 PC 到 __mmap_switched（位于高地址 0xC0000000 区域）</li><li>从此开始，虚拟地址生效。</li></ul></li></ul><ol start="11"><li>__mmap_switched（MMU 打开后的第一步）</li></ol><ul><li>这个在 arch&#x2F;arm&#x2F;kernel&#x2F;head-common.S，作用：<ul><li>它完成从低级引导环境到C 语言内核环境的最后过渡，设置栈指针到内核栈, 清空 .bss, 确保内存布局、栈和关键变量正确，然后跳转到 start_kernel()。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * __mmap_switched:</span><br><span class="hljs-comment"> *  - MMU 已开启后执行的第一段代码</span><br><span class="hljs-comment"> *  - 作用：完成 .data 段拷贝、.bss 清零、设置栈、保存启动参数，然后跳到 start_kernel()</span><br><span class="hljs-comment"> */</span><br>__mmap_switched:<br>    adr     r3, __mmap_switched_data        @ r3 &lt;- __mmap_switched_data 表虚拟地址<br><br>    <span class="hljs-comment">/* ---------------------------------------------------------</span><br><span class="hljs-comment">     * 1. 复制 .data 段（如果物理地址 != 虚拟地址）</span><br><span class="hljs-comment">     * 从 r3 中加载 4 个地址：__data_loc, _sdata, __bss_start, _end</span><br><span class="hljs-comment">     * --------------------------------------------------------- */</span><br>    ldmia   r3!, &#123;r4, r5, r6, r7&#125;           @ r4=__data_loc, r5=_sdata, r6=__bss_start, r7=_end<br>    cmp     r4, r5                          @ 比较 __data_loc 和 _sdata<br><span class="hljs-number">1</span>:  cmpne   r5, r6                          @ 如果 .data 还没拷贝完并且不等于 .bss 开始<br>    ldrne   fp, [r4], #<span class="hljs-number">4</span>                    @ 从源地址(r4)加载一个字（递增<span class="hljs-number">4</span>）<br>    strne   fp, [r5], #<span class="hljs-number">4</span>                    @ 存到目标地址(r5)，并递增<br>    bne     <span class="hljs-number">1b</span>                              @ 如果还没结束，继续循环<br><br>    <span class="hljs-comment">/* ---------------------------------------------------------</span><br><span class="hljs-comment">     * 2. 清零 .bss 段（__bss_start 到 _end）</span><br><span class="hljs-comment">     * --------------------------------------------------------- */</span><br>    mov     fp, #<span class="hljs-number">0</span>                          @ fp 清零，用于写入<br><span class="hljs-number">1</span>:  cmp     r6, r7                          @ 比较当前位置和 _end<br>    strcc   fp, [r6],#<span class="hljs-number">4</span>                     @ 如果 r6 &lt; r7，则写 <span class="hljs-number">0</span> 并递增<br>    bcc     <span class="hljs-number">1b</span>                              @ 继续循环直到 r6 &gt;= r7<br><br>    <span class="hljs-comment">/* ---------------------------------------------------------</span><br><span class="hljs-comment">     * 3. 加载全局变量地址 + 设置栈</span><br><span class="hljs-comment">     * 从表中再加载 5 个值：processor_id, machine_arch_type, atags_pointer, cr_alignment, sp</span><br><span class="hljs-comment">     * --------------------------------------------------------- */</span><br>ARM(    ldmia   r3, &#123;r4, r5, r6, r7, sp&#125;    )   @ ARM 模式直接加载<span class="hljs-number">5</span>个寄存器<br>THUMB(  ldmia   r3, &#123;r4, r5, r6, r7&#125;        )   @ Thumb 模式先加载<span class="hljs-number">4</span>个<br>THUMB(  ldr     sp, [r3, #<span class="hljs-number">16</span>]               )   @ Thumb 再单独加载栈指针<br><br>    <span class="hljs-comment">/* ---------------------------------------------------------</span><br><span class="hljs-comment">     * 4. 保存启动参数到全局变量</span><br><span class="hljs-comment">     * r9=CPU ID, r1=Machine ID, r2=atags/dtb 指针</span><br><span class="hljs-comment">     * --------------------------------------------------------- */</span><br>    str     r9, [r4]                        @ 保存 processor_id<br>    str     r1, [r5]                        @ 保存 machine_arch_type<br>    str     r2, [r6]                        @ 保存 atags/dtb pointer<br><br>    <span class="hljs-comment">/* ---------------------------------------------------------</span><br><span class="hljs-comment">     * 5. 保存 CP15 控制寄存器值</span><br><span class="hljs-comment">     * r0 中存的是 CP15 控制寄存器（MMU 等）</span><br><span class="hljs-comment">     * CR_A 位是 Alignment fault enable，通常清掉</span><br><span class="hljs-comment">     * --------------------------------------------------------- */</span><br>    bic     r4, r0, #CR_A                   @ r4 = r0 去掉 Alignment 位<br>    stmia   r7, &#123;r0, r4&#125;                    @ 保存 r0 和 r4 到 cr_alignment 区<br><br>    <span class="hljs-comment">/* ---------------------------------------------------------</span><br><span class="hljs-comment">     * 6. 跳转到 C 语言内核入口</span><br><span class="hljs-comment">     * --------------------------------------------------------- */</span><br>    b       start_kernel                    @ 进入 start_kernel() （init/main.c）<br>ENDPROC(__mmap_switched)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * __mmap_switched_data 表：</span><br><span class="hljs-comment"> * 提供初始化所需的虚拟地址（因为 MMU 已开启）</span><br><span class="hljs-comment"> */</span><br>__mmap_switched_data:<br>    .<span class="hljs-type">long</span>   __data_loc                      @ r4：物理 .data 起始地址<br>    .<span class="hljs-type">long</span>   _sdata                          @ r5：虚拟 .data 起始地址<br>    .<span class="hljs-type">long</span>   __bss_start                     @ r6：.bss 起始地址<br>    .<span class="hljs-type">long</span>   _end                            @ r7：内核结束地址<br>    .<span class="hljs-type">long</span>   processor_id                    @ 保存 CPU ID 的地址<br>    .<span class="hljs-type">long</span>   __machine_arch_type             @ 保存机器 ID 的地址<br>    .<span class="hljs-type">long</span>   __atags_pointer                 @ 保存 atags/dtb 指针的地址<br>    .<span class="hljs-type">long</span>   cr_alignment                    @ 保存 CP15 控制寄存器值的地址<br>    .<span class="hljs-type">long</span>   init_thread_union + THREAD_START_SP @ 栈指针地址<br>    .size   __mmap_switched_data, . - __mmap_switched_data<br></code></pre></td></tr></table></figure><ol><li>进入 __mmap_switched</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__mmap_switched:<br>    adr r3, __mmap_switched_data<br></code></pre></td></tr></table></figure><ul><li>adr r3, __mmap_switched_data：获取 __mmap_switched_data 表的虚拟地址（因为 MMU 已开启，现在是虚拟地址访问）。</li></ul><ol start="2"><li>复制 .data 段</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">ldmia   r3!, &#123;r4, r5, r6, r7&#125;   <span class="hljs-comment">// 从表中读取4个值：__data_loc, _sdata, __bss_start, _end</span><br>cmp     r4, r5                  <span class="hljs-comment">// 比较 __data_loc 和 _sdata</span><br><span class="hljs-number">1</span>:  cmpne   r5, r6<br>    ldrne   fp, [r4], #<span class="hljs-number">4</span><br>    strne   fp, [r5], #<span class="hljs-number">4</span><br>    bne     <span class="hljs-number">1b</span><br></code></pre></td></tr></table></figure><p>含义：</p><ul><li>r4 &#x3D; __data_loc：物理内存中 .data 的位置</li><li>r5 &#x3D; _sdata：虚拟地址 .data 段起始位置</li><li>r6 &#x3D; __bss_start：.bss 段开始</li><li>r7 &#x3D; _end：内核镜像结束位置</li></ul><p>循环：如果 .data 的物理位置和虚拟位置不同（XIP 或 relocate），复制 .data 段内容到正确位置。</p><ol start="3"><li>清零 BSS</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mov fp, #<span class="hljs-number">0</span>              @ 清零寄存器 fp<br><span class="hljs-number">1</span>:  cmp r6, r7<br>    strcc fp, [r6],#<span class="hljs-number">4</span><br>    bcc <span class="hljs-number">1b</span><br></code></pre></td></tr></table></figure><ul><li>把 .bss 段清零（即 __bss_start 到 _end）。<ul><li>原因：C 语言要求未初始化全局变量为 0。</li></ul></li></ul><ol start="4"><li>加载保存关键变量的地址</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">ARM(   ldmia  r3, &#123;r4, r5, r6, r7, sp&#125;)<br>THUMB( ldmia  r3, &#123;r4, r5, r6, r7&#125; )<br>THUMB( ldr    sp, [r3, #<span class="hljs-number">16</span>] )<br></code></pre></td></tr></table></figure><ul><li>现在 r3 指向 __mmap_switched_data 的剩余部分：<ul><li>r4 &#x3D; processor_id 地址</li><li>r5 &#x3D; __machine_arch_type 地址</li><li>r6 &#x3D; __atags_pointer 地址</li><li>r7 &#x3D; cr_alignment 地址</li><li>sp &#x3D; init_thread_union + THREAD_START_SP（设置栈指针）</li></ul></li></ul><ol start="5"><li>保存启动参数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">str r9, [r4]    @ processor_id = r9<br>str r1, [r5]    @ machine_arch_type = r1<br>str r2, [r6]    @ atags/dtb pointer = r2<br></code></pre></td></tr></table></figure><ul><li>把早期保存的 CPU ID（r9）、机器类型（r1）、atags&#x2F;dtb 地址（r2）存到全局变量。</li><li>这样 start_kernel() 就可以用这些数据。</li></ul><ol start="6"><li>保存控制寄存器值</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">bic r4, r0, #CR_A<br>stmia r7, &#123;r0, r4&#125;      @ 保存 CP15 control <span class="hljs-keyword">register</span> 值<br></code></pre></td></tr></table></figure><p>r0 是 CP15 控制寄存器值（MMU、Cache 状态）。<br>清掉 CR_A（Alignment fault enable），保存两个版本：<br>r0 原始值<br>r4 去掉 Alignment bit 的值</p><ol start="7"><li>跳转到 C 语言世界</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">b start_kernel<br></code></pre></td></tr></table></figure><ul><li><p>直接跳到 start_kernel()（init&#x2F;main.c），进入 Linux C 初始化。</p></li><li><p><code>__mmap_switched_data</code>表</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__mmap_switched_data:<br>    .<span class="hljs-type">long</span>   __data_loc          @ r4<br>    .<span class="hljs-type">long</span>   _sdata              @ r5<br>    .<span class="hljs-type">long</span>   __bss_start         @ r6<br>    .<span class="hljs-type">long</span>   _end                @ r7<br>    .<span class="hljs-type">long</span>   processor_id        @ 保存 CPU ID 的地址<br>    .<span class="hljs-type">long</span>   __machine_arch_type @ 保存机器 ID<br>    .<span class="hljs-type">long</span>   __atags_pointer     @ 保存启动参数地址<br>    .<span class="hljs-type">long</span>   cr_alignment        @ 保存 CP15 控制寄存器值<br>    .<span class="hljs-type">long</span>   init_thread_union + THREAD_START_SP @ sp<br></code></pre></td></tr></table></figure><ul><li>这个表提供了所有初始化需要的虚拟地址，因为现在 MMU 打开了，可以直接使用虚拟地址。</li></ul><p><strong>总结</strong>：__mmap_switched 主要干的事<br>✔ 复制 .data 段（如果需要）<br>✔ 清零 .bss 段<br>✔ 设置栈指针（SP）<br>✔ 保存 CPU ID、Machine ID、ATAGS&#x2F;DTB 地址到全局变量<br>✔ 保存 CP15 控制寄存器值<br>✔ 跳转到 start_kernel() 进入 C 世界</p>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/">linux</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/">kernel</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/kernel-start/">kernel_start</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/kernel-start/">kernel_start</category>
      
      
      <comments>https://goko-son626.github.io/post/kernel.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>U-boot 移植及源码分析( ARM )</title>
      <link>https://goko-son626.github.io/post/u-boot.html</link>
      <guid>https://goko-son626.github.io/post/u-boot.html</guid>
      <pubDate>Mon, 30 Sep 2024 05:25:09 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;在s5p6818上移植uboot并分析其启动过程&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>在s5p6818上移植uboot并分析其启动过程</strong></em></li></ul><span id="more"></span><h3 id="1-系统移植"><a href="#1-系统移植" class="headerlink" title="1. 系统移植"></a>1. 系统移植</h3><h4 id="1-嵌入式Linux构成与移植概述"><a href="#1-嵌入式Linux构成与移植概述" class="headerlink" title="1. 嵌入式Linux构成与移植概述"></a>1. 嵌入式Linux构成与移植概述</h4><ul><li><strong>嵌入式Linux移植定义</strong>: 移植就是将Bootloader的源代码、Linux内核源代码、文件系统中用户态程序代码根据硬件做少量修改，使其能够在目标硬件平台上运行起来的过程。</li><li><strong>Linux内核功能及本质</strong>:<ul><li><strong>功能</strong>: 进程管理、文件系统、内存管理、网络协议。</li></ul></li></ul><h4 id="2-Bootloader定义及重要性"><a href="#2-Bootloader定义及重要性" class="headerlink" title="2. Bootloader定义及重要性"></a>2. Bootloader定义及重要性</h4><ul><li><strong>定义</strong>: Bootloader是在操作系统内核运行之前运行，初始化硬件设备、建立内存空间映射，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。</li><li><strong>为什么需要Bootloader</strong>:<ul><li>在嵌入式系统中，Bootloader是一段短小的启动程序，因为没有BIOS那样的固件程序，因此整个系统的加载启动任务就完全由Bootloader来完成。</li><li>使Linux内核可以在系统主存中跑起来，系统必须符合Linux内核启动的必要条件。</li></ul></li></ul><h4 id="3-Bootloader、Kernel、应用程序之间的关系"><a href="#3-Bootloader、Kernel、应用程序之间的关系" class="headerlink" title="3. Bootloader、Kernel、应用程序之间的关系"></a>3. Bootloader、Kernel、应用程序之间的关系</h4><ul><li><strong>Bootloader</strong>:<ul><li>硬件上电后跳到固定位置执行相应代码</li><li>初始化相应的硬件设备</li><li>加载操作系统内核代码到内存</li><li>跳到内核代码起始位置执行</li></ul></li><li><strong>Kernel (uImage)</strong>:<ul><li>内核自解压 (uImage)</li><li>初始化相应的硬件设备</li><li>初始化静态编译进内核的驱动模块</li><li>挂载根文件系统</li><li>直接执行第一个用户空间程序</li></ul></li><li><strong>第一个用户空间程序</strong>: 配置用户环境和执行服务进程</li></ul><h3 id="2-开发板烧写并启动-先对emmc进行分区-了解整个系统在emmc上的启动过程"><a href="#2-开发板烧写并启动-先对emmc进行分区-了解整个系统在emmc上的启动过程" class="headerlink" title="2. 开发板烧写并启动(先对emmc进行分区,了解整个系统在emmc上的启动过程)"></a>2. 开发板烧写并启动(先对emmc进行分区,了解整个系统在emmc上的启动过程)</h3><h4 id="1-emmc分区布局"><a href="#1-emmc分区布局" class="headerlink" title="1. emmc分区布局"></a>1. emmc分区布局</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">0M   -   1M(0x80)      : Bootloader (U-Boot)<br>1M   -   65M(0x20800)  : Kernel (uImage + dtb)<br>65M  -   819M          : RootFS (ext4)<br>819M -   末尾          : 其他数据<br></code></pre></td></tr></table></figure><h4 id="2-假设当前通过软件烧录uboot后启动在uboot中，-uboot支持emmc操作"><a href="#2-假设当前通过软件烧录uboot后启动在uboot中，-uboot支持emmc操作" class="headerlink" title="2. 假设当前通过软件烧录uboot后启动在uboot中，(uboot支持emmc操作)"></a>2. 假设当前通过软件烧录uboot后启动在uboot中，(uboot支持emmc操作)</h4><ul><li>查看emmc信息<ul><li><code>mmc list / mmc dev 0 / mmc info</code></li></ul></li><li>按需擦除数据<ul><li><code>mmc erase 0 1000000</code></li></ul></li><li>分区(help fdisk)<ul><li>fdisk <dev no> [part table counts] <a href="start:length">start:length</a><xxx>….<ul><li><code>fdisk 2 3 0x100000:0x4000000 0x4100000:2f200000 0x33300000:0</code>      &#x2F;&#x2F; 从bootloader地址之后开始分区的话</li></ul></xxx></dev></li></ul></li><li>通过uboot中的 loadaddr 和 bdinfo 查看DRAM信息, 然后重新<strong>烧写uboot</strong><ul><li><code>tftp 0x48000000 ubootpak.bin</code><ul><li>Bytes transferred &#x3D; 342960 (53bb0 hex)</li></ul></li><li><code>update_mmc 2 2ndboot 0x48000000 0x200 53bb0</code></li></ul></li><li>重启进入uboot<ul><li>re</li></ul></li><li><strong>Linux内核烧写</strong><ul><li><code>tftp 48000000 uImage</code></li><li><code>mmc write 48000000 0x800 0x3000</code> (写入的扇区位置和数量)</li></ul></li></ul><h4 id="3-配置NFS服务器"><a href="#3-配置NFS服务器" class="headerlink" title="3. 配置NFS服务器"></a>3. 配置NFS服务器</h4><ul><li><p>rootfs一般都是从网络启动和挂载，因为方便调试，主机需要配置NFS服务器。</p><ul><li><p>服务端配置</p><ul><li><strong>编辑<code>/etc/exports</code>文件</strong>: <code>sudo vi /etc/exports</code></li><li><strong>添加NFS共享目录配置</strong>: <code>/opt/rootfs *(rw,sync,no_root_squash)</code><ul><li><code>rw</code>: 读写权限。</li><li><code>sync</code>: 数据同步写入磁盘。</li><li><code>no_root_squash</code>: 客户端以root身份访问文件。</li></ul></li><li><strong>重启NFS服务使配置生效</strong>: <code>sudo /etc/init.d/nfs-kernel-server restart</code></li></ul></li><li><p>客户端配置 (U-boot环境变量)</p><ul><li><strong>设置<code>bootargs</code></strong>:<br><code>setenv bootargs root=/dev/nfs nfsroot=192.168.1.8:/opt/rootfs ip=192.168.1.6:192.168.1.8:192.168.1.255:255.0 console=ttySAC0 maxcpus=1 lcd=wy070ml tp=gslx680-linux</code><ul><li><code>root=/dev/nfs</code>: 指定根文件系统类型为NFS。</li><li><code>nfsroot=192.168.1.8:/opt/rootfs</code>: NFS服务器IP地址和共享目录。</li><li><code>ip=...</code>: 开发板的IP地址配置。</li><li><code>console=ttySAC0</code>: 指定控制台输出设备。</li></ul></li></ul></li></ul></li></ul><h3 id="3-U-boot源码分析"><a href="#3-U-boot源码分析" class="headerlink" title="3. U-boot源码分析"></a>3. U-boot源码分析</h3><h4 id="1-U-boot"><a href="#1-U-boot" class="headerlink" title="1. U-boot"></a>1. U-boot</h4><ul><li>U-Boot（Universal Boot Loader）是一个开源、跨平台的 Bootloader，主要用于嵌入式系统启动。它独立于操作系统，运行在裸机环境，支持多种 CPU 架构（ARM、PowerPC、MIPS、x86 等）和操作系统（Linux、VxWorks 等）。</li><li>特点：模块化设计，易于移植；支持多种存储、外设和网络协议；提供丰富的命令行操作。</li></ul><h4 id="2-U-boot编译"><a href="#2-U-boot编译" class="headerlink" title="2. U-boot编译"></a>2. U-boot编译</h4><ul><li>清理环境（防止残留配置）：<ul><li>make distclean</li></ul></li><li>加载目标板默认配置：<ul><li>make <board>_defconfig<ul><li>示例：make x6818_defconfig</li></ul></board></li></ul></li><li>可选修改配置（菜单界面）：<ul><li>make menuconfig</li></ul></li><li>编译（指定交叉编译器）：<ul><li>make CROSS_COMPILE&#x3D;arm-linux-gnueabihf- -j$(nproc)</li></ul></li><li>查看产物：<ul><li>u-boot：ELF 格式，可调试,为可执行的ELF格式文件。</li><li><code>ubootpak.bin</code>为<code>u-boot</code>通过<code>objcopy</code>转换得到的二进制文件（用于烧写）。</li><li>u-boot-dtb.bin：带设备树版本（部分平台）。</li></ul></li></ul><h4 id="3-入口点文件分析"><a href="#3-入口点文件分析" class="headerlink" title="3. 入口点文件分析"></a>3. 入口点文件分析</h4><h5 id="编译链接过程-make-V-1"><a href="#编译链接过程-make-V-1" class="headerlink" title="编译链接过程 (make V&#x3D;1)"></a>编译链接过程 (make V&#x3D;1)</h5><p>当执行 <code>make V=1</code> 时，可以看到详细的编译链接过程。例如：<br><code>make -f scripts/Makefile.build obj=examples/standalone arm-cortex_a9-linux-gnueabi-ld -pte --gc-sections -Bstatic -Ttext 0x43C0000 -o u-boot u-boot.lds arch/arm/cpu/slsiap/start.o --start-group arch/arm/cpu/slsiap/built-in.o arch/arm/cpu/slsiap/s5p6818/built-in.o arch/arm/cpu/slsiap/s5</code></p><p>这里关键的是 <code>-Ttext 0x43C0000 -o u-boot u-boot.lds</code>，它指定了U-boot的起始地址和链接脚本。</p><h5 id="u-boot-lds-链接脚本"><a href="#u-boot-lds-链接脚本" class="headerlink" title="u-boot.lds 链接脚本"></a><code>u-boot.lds</code> 链接脚本</h5><p>链接脚本定义了U-boot各段在内存中的布局。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lds">. = 0x00000000;<br>. = ALIGN(4);<br>.rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata))) &#125;<br>.data : &#123; &#125;<br>.text :<br>&#123;<br>    *(.__image_copy_start)<br>    arch/arm/cpu/slsiap/s5p6818/start.o (.text*)<br>    arch/arm/cpu/slsiap/s5p6818/vectors.o (.text*)<br>    *(.text*)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>. = 0x00000000;</code>: 指定代码的加载起始地址为0x00000000 (通常是内存或Flash的起始地址)。</li><li><code>arch/arm/cpu/slsiap/s5p6818/start.o (.text*)</code>: 这表明<code>start.o</code>文件中的<code>.text</code>段（代码段）是U-boot的第一个执行部分。</li></ul><h5 id="start-S-入口点汇编文件"><a href="#start-S-入口点汇编文件" class="headerlink" title="start.S (入口点汇编文件)"></a><code>start.S</code> (入口点汇编文件)</h5><p><code>start.o</code>是由<code>start.S</code>汇编文件编译而来，其中包含了U-boot的真正入口点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl _start<br>_start:<br>    b reset              // 跳转到reset函数<br>    ldr pc, _undefined_instruction<br>    ldr pc, _software_interrupt<br>    ldr pc, _prefetch_abort<br>    ldr pc, _data_abort<br>    ldr pc, _not_used<br>    ldr pc, _irq<br>    ldr pc, _fiq<br></code></pre></td></tr></table></figure><ul><li><code>_start</code>: 这是U-boot的入口点符号。</li><li><code>b reset</code>: 上电后CPU执行的第一个指令，直接跳转到<code>reset</code>函数。<code>reset</code>函数是U-boot初始化过程的起点。</li></ul><h4 id="4-U-boot启动过程"><a href="#4-U-boot启动过程" class="headerlink" title="4. U-boot启动过程"></a>4. U-boot启动过程</h4><ul><li>U-boot启动分为两个主要阶段：</li></ul><h5 id="阶段一-最底层初始化-汇编代码"><a href="#阶段一-最底层初始化-汇编代码" class="headerlink" title="阶段一: 最底层初始化 (汇编代码)"></a>阶段一: 最底层初始化 (汇编代码)</h5><p>U-Boot 启动的第一阶段：从复位到 C 运行环境</p><ul><li>异常向量表设置</li><li>CPU 模式切换</li><li>缓存与 MMU 初始化</li><li>代码重定位</li><li>BSS 段清零</li><li>栈和全局数据结构（gd）初始化</li><li><strong>跳转到 board_init_f()（进入 C 语言环境）</strong></li></ul><p><strong>start.S主要代码分析:</strong></p><ol><li>异常向量表设置</li></ol><p>ARM 处理器上电后，从 0x00000000 开始取指（或由 VBAR 指定的基地址），所以必须先建立异常向量表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl _stext<br>_stext:<br>    b  reset                       @ 复位时跳到 reset<br>    ldr pc, _undefined_instruction<br>    ldr pc, _software_interrupt<br>    ldr pc, _prefetch_abort<br>    ldr pc, _data_abort<br>    ldr pc, _not_used<br>    ldr pc, _irq<br>    ldr pc, _fiq<br></code></pre></td></tr></table></figure><ul><li><p>定义 _stext 作为代码的起始地址</p></li><li><p>ARM 异常类型：reset, undefined, SWI, prefetch abort, data abort, IRQ, FIQ</p><ul><li>通过 ldr pc, xxx 跳转到对应处理函数地址</li><li>这一步的目的：保证 CPU 出现异常不会直接崩溃，有跳转入口。</li><li>ARM 架构规定，当某种异常发生时，硬件会自动做两件事：<ul><li>切换到对应的异常模式（如 Supervisor、IRQ、FIQ）。</li><li>把 PC 设置到异常向量表的固定偏移地址（通常是 0x00000000 或者 VBAR 里的值）。<ul><li>例如：<ul><li>发生 Reset → PC &#x3D; 0x00000000 → 执行 b reset</li><li>发生 Undefined → PC &#x3D; 0x00000004 → 执行 ldr pc, _undefined_instruction</li><li>发生 IRQ → PC &#x3D; 0x00000018 → 执行 ldr pc, _irq</li></ul></li></ul></li></ul></li></ul></li><li><p>b handler 是 相对跳转，需要 handler 在当前 32MB 范围内。</p></li><li><p>ldr pc, _xxx 是 绝对跳转，通过取一个常量地址，可以跳到 U-Boot 任意地方。</p></li><li><p>这样设计是为了灵活，后面如果重定位代码，这个表不用改，直接改 _xxx 变量的值。</p></li></ul><ol start="2"><li>reset：从复位到基本初始化</li></ol><p>reset 是启动的第一个执行函数，主要工作：</p><ul><li>保存启动参数</li><li>切换到 SVC 模式</li><li>关闭看门狗</li><li>初始化 CPU 关键寄存器</li><li>如果需要，跳到低级硬件初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">reset:<br>    bl  save_boot_params        @ 保存启动参数（调用 save_boot_params 函数，保存启动时的参数）<br>    <br>    /* 切换到 SVC32 模式 */<br>    mrs r0, cpsr                @ 读取当前的 CPSR（Current Program Status Register，当前程序状态寄存器）<br>    bic r0, r0, #0x1f           @ 清除 CPSR 中的模式字段（低 5 位）以准备切换模式<br>    orr r0, r0, #0xd3           @ 设置 CPSR 的模式为 SVC 模式 (SVC32)，并禁用所有中断<br>    msr cpsr, r0                @ 将修改后的 CPSR 写回，切换到 SVC 模式并禁用中断<br><br>    /* 禁用看门狗 */<br>    ldr r0, =0xC0019000         @ 加载看门狗控制寄存器的地址（地址是 0xC0019000）<br>    mov r1, #0                  @ 将寄存器 r1 设置为 0，表示禁用看门狗<br>    str r1, [r0]                @ 将 r1 的值（0）存储到看门狗控制寄存器，禁用看门狗<br><br>#ifndef CONFIG_SKIP_LOWLEVEL_INIT<br>    bl cpu_init_cp15            @ 调用 cpu_init_cp15 函数，关闭 MMU、清除缓存等<br>    bl cpu_init_crit            @ 调用 cpu_init_crit 函数，执行板级低级初始化，如 PLL 和 DDR 配置<br>#endif<br></code></pre></td></tr></table></figure><p>关键点：</p><ul><li>cpsr 切换 CPU 模式为 SVC（超级用户模式），同时关中断</li><li>关闭看门狗，避免启动过程中被复位</li><li>cpu_init_cp15：处理 CP15 寄存器，关闭 MMU，invalidate I&#x2F;D cache</li><li>cpu_init_crit：执行板级初始化（比如 DRAM 控制器），确保后面可以使用内存</li></ul><ol start="3"><li>代码重定位（Relocation）-&gt; 如果平台 开启 <strong>CONFIG_RELOC_TO_TEXT_BASE</strong></li></ol><p>很多 ARM 平台启动时，U-Boot 最初加载在 NOR Flash 或 SRAM，执行地址并不是最终运行地址。<br>为了能正确访问全局变量、函数指针，必须把 U-Boot 拷贝到 DRAM 的 TEXT_BASE。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">relocate_to_text:<br>    adr r0, _stext              @ 获取当前代码位置（即 _stext 地址），并将其存入寄存器 r0<br>    ldr r1, TEXT_BASE           @ 加载目标地址（TEXT_BASE，即代码重定位后存放的位置）<br>    cmp r0, r1                  @ 比较当前代码地址（r0）与目标地址（r1）<br>    beq clear_bss               @ 如果当前地址已经是目标地址，则跳转到 clear_bss，避免重复搬迁<br><br>    ldr r2, _bss_start_ofs      @ 加载 BSS 段起始地址的偏移量（_bss_start_ofs）<br>    add r2, r0, r2              @ 计算拷贝结束地址（当前地址 + BSS 段的偏移量）<br><br>copy_loop_text:<br>    ldmia r0!, &#123;r3-r10&#125;         @ 从 r0（当前代码地址）加载 8 个寄存器的内容，并将 r0 地址增加 8 字节<br>    stmia r1!, &#123;r3-r10&#125;         @ 将加载的寄存器内容存储到 r1（目标地址），并将 r1 地址增加 8 字节<br>    cmp r0, r2                  @ 比较当前地址（r0）与拷贝结束地址（r2）<br>    ble copy_loop_text          @ 如果 r0 小于等于 r2，说明还没有到达结束地址，继续拷贝<br><br>    ldr r1, TEXT_BASE           @ 重新加载目标地址 TEXT_BASE<br>    mov pc, r1                  @ 跳转到 DRAM 中的 TEXT_BASE 继续执行<br></code></pre></td></tr></table></figure><ul><li>比较当前执行地址和目标地址（TEXT_BASE）</li><li>如果不一样，循环拷贝整个 U-Boot 代码段</li><li>最后 mov pc, r1，跳转到 DRAM 里的代码继续执行</li></ul><ol start="4"><li>清空 BSS 段</li></ol><p>BSS 段用于存放未初始化的全局变量，必须清零。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">clear_bss:<br>    ldr r0, _bss_start_ofs      @ 加载 BSS 段的起始偏移地址<br>    ldr r1, _bss_end_ofs        @ 加载 BSS 段的结束偏移地址<br>    ldr r4, TEXT_BASE           @ 加载 TEXT_BASE 地址<br>    add r0, r0, r4              @ 计算实际的 BSS 段起始地址（BSS 起始地址 + TEXT_BASE）<br>    add r1, r1, r4              @ 计算实际的 BSS 段结束地址（BSS 结束地址 + TEXT_BASE）<br>    mov r2, #0                  @ 设置 r2 为 0，准备清空 BSS 段<br><br>clbss_l:<br>    str r2, [r0]                @ 将 0 存储到 BSS 段中的当前地址<br>    add r0, r0, #4              @ 移动到下一个 4 字节地址（每次清 4 字节）<br>    cmp r0, r1                  @ 比较当前地址（r0）与 BSS 结束地址（r1）<br>    bne clbss_l                 @ 如果没有到达结束地址，继续清空 BSS 段<br></code></pre></td></tr></table></figure><ul><li>把 BSS 段所有字节清 0</li><li>避免后面 C 代码访问到脏数据</li></ul><ol start="5"><li>初始化栈和 GD（global data）结构</li></ol><p>C 代码需要栈，U-Boot 还需要 gd_t 全局数据结构保存运行状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ldr sp, =(CONFIG_SYS_INIT_SP_ADDR)   @ 设置栈指针 sp 为初始化的栈地址（CONFIG_SYS_INIT_SP_ADDR）<br>bic sp, sp, #7                 @ 确保栈指针 sp 8 字节对齐，清除 sp 的最低三位<br>sub sp, #GD_SIZE               @ 给全局数据（GD）预留空间，调整栈指针，分配 GD 所需的内存<br>bic sp, sp, #7                 @ 再次确保栈指针 8 字节对齐<br>mov r9, sp                     @ 将栈指针保存到 r9，r9 将作为全局数据（GD）的基地址<br></code></pre></td></tr></table></figure><ul><li>CONFIG_SYS_INIT_SP_ADDR：通常是 DRAM 高地址（安全）</li><li>GD_SIZE：U-Boot 的全局数据结构</li><li>r9（IP 寄存器）专门存放 gd 指针</li></ul><ol start="6"><li>board_init_f函数执行，跳转到 board_init_f 所在的board_f.c 文件中</li></ol><ul><li><p>board_init_f 阶段</p><ul><li>运行位置：Flash 或 SRAM（未 relocation 前）</li><li>作用：<ul><li>初始化 PLL&#x2F;时钟。</li><li>初始化 DDR 控制器（重点）。</li><li>初始化 串口（用于输出 early log）。</li><li>计算 relocation 参数：<ul><li>gd-&gt;relocaddr：U-Boot 在 DRAM 的目标地址。</li><li>gd-&gt;start_addr_sp：新的栈顶地址（在 DRAM）。</li><li>gd-&gt;new_gd：新全局数据区域（DRAM）。</li></ul></li><li>调用 jump_to_copy() → relocate_code()。</li></ul></li></ul></li><li><p>relocate_code 阶段</p><ul><li>运行位置：仍然在 Flash&#x2F;SRAM（搬家前）。</li><li>作用：<ul><li>将 .text、.data 从 当前位置 复制到 gd-&gt;relocaddr（DRAM）。</li><li>清空 .bss 段（DRAM）。</li><li>切换栈到 DRAM（sp &#x3D; gd-&gt;start_addr_sp）。</li><li>跳转到 board_init_r 的地址（现在在 DRAM 中）。</li></ul></li></ul></li></ul><p>这一步才是真正把 U-Boot 搬到 DRAM 并切换执行位置。</p><ol start="7"><li>board_init_r函数执行，跳转到 board_init_r 所在的board_r.c 文件中</li></ol><ul><li><p>运行位置：DRAM（relocation 完成）。</p></li><li><p>作用：</p><ul><li><code>cif (initcall_run_list(init_sequence_r)) hang();</code><ul><li>初始化全局变量。</li><li>初始化设备驱动（I2C、SPI、USB、存储设备）。</li><li>初始化环境变量（env）。</li><li>初始化控制台。</li><li>调用 run_main_loop() 进入命令行。<ul><li><code>for (;;) main_loop(); // to common/Main.c</code></li></ul></li></ul></li></ul></li><li><p>common&#x2F;main.c</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">main_loop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s;<br><br>modem_init();<br><br>cli_init();<br><br>run_preboot_environment_command();<br><br><span class="hljs-comment">// get bootdelay of uboot and store it in a global variable: stored_bootdelay</span><br><span class="hljs-comment">// return bootcmd through: getenv(&quot;bootcmd&quot;)</span><br>s = bootdelay_process();<br><br>  <span class="hljs-comment">// abortboot(stored_bootdelay)进行倒计时</span><br>  <span class="hljs-comment">// 未打断：run_command_list(s, -1, 0); 启动内核</span><br>  <span class="hljs-comment">// 打断： 返回</span><br>autoboot_command(s);<br><br>  <span class="hljs-comment">// 调用cli_simple_loop(): for(;;) cli_readline(CONFIG_SYS_PROMPT);// 接受用户端命令:common/cli_readline.c</span><br>  <span class="hljs-comment">// ... run_command_repeatable(lastcommand, flag); // 执行用户端命令</span><br>  cli_loop();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>cli_loop时执行输入命令的核心函数(详解)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cli_simple_run_command</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmd, <span class="hljs-type">int</span> flag)</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个缓冲区，用来存放传入的命令字符串的副本。</span><br>    <span class="hljs-comment">// 不能直接操作 cmd，因为 getenv() 返回的环境变量字符串可能在执行过程中被修改。</span><br>    <span class="hljs-type">char</span> cmdbuf[CONFIG_SYS_CBSIZE];<span class="hljs-comment">/* working copy of cmd*/</span><br>    <span class="hljs-comment">// token 指向当前解析的命令起始位置。</span><br>    <span class="hljs-type">char</span> *token;<span class="hljs-comment">/* start of token in cmdbuf*/</span><br>    <span class="hljs-comment">// sep 用于找到命令分隔符（比如 &#x27;;&#x27;）的位置。</span><br>    <span class="hljs-type">char</span> *sep;<span class="hljs-comment">/* end of token (separator) in cmdbuf */</span><br>    <span class="hljs-comment">// finaltoken 存放替换宏后的命令（比如把 $bootcmd 替换为实际值）。</span><br>    <span class="hljs-type">char</span> finaltoken[CONFIG_SYS_CBSIZE];<br>    <span class="hljs-comment">// str 是解析循环中当前处理位置的指针。</span><br>    <span class="hljs-type">char</span> *str = cmdbuf;<br>    <span class="hljs-comment">// argv 保存分解后的参数列表，argv[0] 是命令名，argv[1..n] 是参数。</span><br>    <span class="hljs-type">char</span> *argv[CONFIG_SYS_MAXARGS + <span class="hljs-number">1</span>];<span class="hljs-comment">/* NULL terminated*/</span><br><br>    <span class="hljs-type">int</span> argc, inquotes;<br>    <span class="hljs-type">int</span> repeatable = <span class="hljs-number">1</span>;<span class="hljs-comment">// 标记命令是否可以重复执行（大多数命令是可以的）。</span><br>    <span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;<span class="hljs-comment">// 返回值，默认成功。</span><br><br>    debug_parser(<span class="hljs-string">&quot;[RUN_COMMAND] cmd[%p]=\&quot;&quot;</span>, cmd);<br>    <span class="hljs-keyword">if</span> (DEBUG_PARSER) &#123;<br>        <span class="hljs-comment">/* 打印调试信息，显示传入的命令内容 */</span><br>        <span class="hljs-built_in">puts</span>(cmd ? cmd : <span class="hljs-string">&quot;NULL&quot;</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 清除 Ctrl-C 标志，防止上一次命令中断状态影响当前命令。</span><br>    clear_ctrlc();<span class="hljs-comment">/* forget any previous Control C */</span><br><br>    <span class="hljs-comment">// 如果命令为空或是空字符串，直接返回 -1。</span><br>    <span class="hljs-keyword">if</span> (!cmd || !*cmd)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">/* empty command */</span><br><br>    <span class="hljs-comment">// 检查命令长度是否超出缓冲区大小。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(cmd) &gt;= CONFIG_SYS_CBSIZE) &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;## Command too long!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 把命令复制到 cmdbuf 中，后续操作基于这个副本。</span><br>    <span class="hljs-built_in">strcpy</span>(cmdbuf, cmd);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 主循环，处理命令分隔符 &#x27;;&#x27;，即一行命令可以包含多个子命令。</span><br><span class="hljs-comment">     * 比如： &quot;setenv bootargs console=ttyS0; bootm 0x80007fc0&quot;</span><br><span class="hljs-comment">     */</span><br>    debug_parser(<span class="hljs-string">&quot;[PROCESS_SEPARATORS] %s\n&quot;</span>, cmd);<br>    <span class="hljs-keyword">while</span> (*str) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 查找命令分隔符 &#x27;;&#x27;，如果命令中有引号，要忽略引号中的 &#x27;;&#x27;</span><br><span class="hljs-comment">         * 允许用 &quot;\;&quot; 转义分号。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span> (inquotes = <span class="hljs-number">0</span>, sep = str; *sep; sep++) &#123;<br>            <span class="hljs-keyword">if</span> ((*sep == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>) &amp;&amp;<br>                (*(sep - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;\\&#x27;</span>))<br>                inquotes = !inquotes;<br><br>            <span class="hljs-keyword">if</span> (!inquotes &amp;&amp;<br>                (*sep == <span class="hljs-string">&#x27;;&#x27;</span>) &amp;&amp;<span class="hljs-comment">/* 找到分隔符 */</span><br>                (sep != str) &amp;&amp;<span class="hljs-comment">/* 确保不是第一个字符 */</span><br>                (*(sep - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;\\&#x27;</span>))<span class="hljs-comment">/* 并且没有被转义 */</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * token = 当前命令字符串（不包括 &#x27;;&#x27;）</span><br><span class="hljs-comment">         */</span><br>        token = str;<br>        <span class="hljs-keyword">if</span> (*sep) &#123;<br>            <span class="hljs-comment">// 如果找到 &#x27;;&#x27;，终止当前命令，并移动 str 到下一个命令起始位置。</span><br>            str = sep + <span class="hljs-number">1</span>;<span class="hljs-comment">/* start of command for next pass */</span><br>            *sep = <span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-comment">/* 把 &#x27;;&#x27; 替换成 &#x27;\0&#x27;，形成单独的字符串 */</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果没有 &#x27;;&#x27;，说明这是最后一个命令。</span><br>            str = sep;<span class="hljs-comment">/* no more commands for next pass */</span><br>        &#125;<br>        debug_parser(<span class="hljs-string">&quot;token: \&quot;%s\&quot;\n&quot;</span>, token);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 处理宏替换，比如 $bootcmd 替换成 &quot;bootm 0x80007fc0&quot;。</span><br><span class="hljs-comment">         */</span><br>        process_macros(token, finaltoken);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 把替换后的命令按空格切分成 argv[]。</span><br><span class="hljs-comment">         * 例如：&quot;bootm 0x80007fc0&quot; → argv[0]=&quot;bootm&quot;, argv[1]=&quot;0x80007fc0&quot;</span><br><span class="hljs-comment">         */</span><br>        argc = cli_simple_parse_line(finaltoken, argv);<br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">0</span>) &#123;<br>            rc = <span class="hljs-number">-1</span>;<span class="hljs-comment">/* 没有有效命令 */</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 调用命令处理函数：</span><br><span class="hljs-comment">         * - 根据 argv[0] 查找命令表 cmd_tbl_t</span><br><span class="hljs-comment">         * - 找到后调用对应的执行函数，比如 do_bootm()</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (cmd_process(flag, argc, argv, &amp;repeatable, <span class="hljs-literal">NULL</span>))<br>            rc = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 如果用户按了 Ctrl-C，立即中止，不再执行后续命令。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (had_ctrlc())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">/* if stopped then not repeatable */</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 返回 rc，如果 rc 为 0，则返回 repeatable，表示该命令是否可以重复执行。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> rc ? rc : repeatable;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>核心为：</p><ul><li>调用命令处理函数：根据 argv[0] 查找命令表 cmd_tbl_t, 找到后调用对应的执行函数，比如 do_bootm()</li><li>cmd_process(flag, argc, argv, &amp;repeatable, NULL)<ul><li><h2 id="cmdtp-find-cmd-argv-0-Look-up-command-in-command-table"><a href="#cmdtp-find-cmd-argv-0-Look-up-command-in-command-table" class="headerlink" title="cmdtp &#x3D; find_cmd(argv[0]); &#x2F;* Look up command in command table *&#x2F; "></a>cmdtp &#x3D; find_cmd(argv[0]); &#x2F;* Look up command in command table *&#x2F; </h2><pre><code>for (cmdtp = table;     cmdtp != table + table_len;     cmdtp++) &#123;    if (strncmp (cmd, cmdtp-&gt;name, len) == 0) &#123;        if (len == strlen (cmdtp-&gt;name))            return cmdtp;    /* full match */        cmdtp_temp = cmdtp;    /* abbreviated command ? */        n_found++;    &#125;&#125;</code></pre></li><li>if (argc &gt; cmdtp-&gt;maxargs) &#x2F;* found - check max args *&#x2F;</li><li>rc &#x3D; cmd_call(cmdtp, flag, argc, argv); &#x2F;* If OK so far, then do the command *&#x2F;<ul><li>&#x2F;&#x2F; 直接调用命令函数指针，相当于执行 do_bootm(cmdtp, flag, argc, argv)</li><li>result &#x3D; (cmdtp-&gt;cmd)(cmdtp, flag, argc, argv);</li></ul></li></ul></li></ul></li><li><p><strong>U-Boot bootm 命令流程解析</strong></p></li></ul><p>bootm 命令是 U-Boot 用来启动 Linux 内核或其他操作系统映像的入口命令。内部核心是 do_bootm()，它会依次执行几个状态，每个状态对应不同的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">do_bootm()<br>└─&gt; do_bootm_states()<br>      ├─ BOOTM_STATE_START<br>      ├─ BOOTM_STATE_FINDOS<br>      ├─ BOOTM_STATE_FINDOTHER<br>      ├─ BOOTM_STATE_LOADOS<br>      └─ BOOTM_STATE_OS_GO<br></code></pre></td></tr></table></figure><ol><li>BOOTM_STATE_START → bootm_start()</li></ol><ul><li>初始化启动上下文 (bootm_headers 等结构体)。</li><li>检查镜像类型（uImage、FIT、Legacy 等）。</li><li>验证镜像合法性（如 magic number、checksum）。</li><li>确定后续加载流程是否需要解压。</li></ul><p>关键点：</p><ul><li>这里是整个 bootm 流程的“起点”，决定后续镜像解析路径。</li><li>如果启动 FIT 镜像，还会解析 FIT 描述符。</li></ul><ol start="2"><li>BOOTM_STATE_FINDOS → bootm_find_os() → boot_get_kernel()</li></ol><ul><li>找到操作系统内核镜像在内存中的位置。</li><li>设置内核映像地址（image-&gt;load）和类型。</li><li>对不同内核格式（zImage、uImage）做处理：<ul><li>uImage：提取 header，获取 load address。</li><li>zImage：直接获取 load 地址，通常包含自解压代码。</li></ul></li></ul><p>关键点：</p><ul><li>这个阶段不执行实际加载，只是确定内核在哪，大小是多少。</li><li>对于 FIT 镜像，会解析 kernel 节点及其 load 地址。</li></ul><ol start="3"><li>BOOTM_STATE_FINDOTHER → bootm_find_other()</li></ol><ul><li>查找其他启动必需镜像：<ul><li>ramdisk（initrd&#x2F;initramfs）</li><li>FDT（Device Tree Blob，硬件描述）</li></ul></li><li>根据镜像类型和配置设置内存地址。</li><li>为内核启动准备参数。</li></ul><p>关键点：</p><ul><li>确保内核启动时能够找到根文件系统和硬件信息。</li><li>FIT 镜像会在这里解析 DTB 节点、ramdisk 节点。</li></ul><ol start="4"><li>BOOTM_STATE_LOADOS → bootm_load_os() → decomp_image()</li></ol><ul><li>将内核镜像从存储介质（flash、SD、TFTP 等）加载到内存。</li><li>如果内核是压缩的（如 gzip&#x2F;zImage&#x2F;uImage），调用 decomp_image() 解压到目标地址。</li><li>同时加载 ramdisk 和 FDT 到内存指定位置。</li></ul><p>关键点：</p><ul><li>这里是真正把内核和相关资源搬到内存执行区的步骤。</li><li>decomp_image() 内部处理压缩算法和解压回调。</li></ul><ol start="5"><li>BOOTM_STATE_OS_GO → bootm_os_get_boot_func() → 跳转内核</li></ol><ul><li>获取内核启动入口（kernel_entry）。</li><li>根据内核类型和架构，设置启动参数（如 ATAGs、FDT 指针、ramdisk 地址）。</li><li>调用函数指针，真正跳转到内核执行。</li></ul><p>关键点：</p><ul><li>U-Boot 在这里退出，CPU 权限切换到内核环境。</li><li>后续流程由内核接管。</li></ul><ul><li><strong>初始化本阶段要使用的硬件设备</strong>。</li><li><strong>检测系统内存映射</strong>。</li><li><strong>将内核映像和根文件系统映像从Flash读到RAM空间</strong>。</li><li><strong>为内核设置启动参数</strong>。</li><li><strong>调用内核</strong>。</li></ul><p><strong>系统上电后的完整流程 (示意)</strong>:<br><code>系统上电</code> -&gt; <code>设置为SVC工作模式</code> -&gt; <code>关闭看门狗</code> -&gt; <code>清空CACHE</code> -&gt; <code>禁止MMU</code> -&gt; <code>清空BSS段</code> -&gt; <code>一系列硬件的初始化</code> -&gt; <code>执行bootcmd中的命令 (加载linux内核)</code> -&gt; <code>设置为SVC工作模式</code> -&gt; <code>检查CPUid是否支持</code> -&gt; <code>创建页表</code> -&gt; <code>开启MMU</code> -&gt; <code>创建子线程</code> -&gt; <code>子线程中挂载指定的根文件系统</code> -&gt; <code>启动用户空间1号进程</code> -&gt; <code>开启后续用户空间进程</code> -&gt; <code>启动一个shell</code> -&gt; <code>用户可以输入命令</code></p><p><strong>imx6ull Uboot 启动详细函数调用流程</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs javascript">u-<span class="hljs-attr">boot</span>:启动详细的代码调用流程<br>u-boot.<span class="hljs-property">lds</span>:(arch/arm/cpu/u-boot.<span class="hljs-property">lds</span>)<br>    |--&gt;<span class="hljs-attr">_start</span>:(arch/arm/lib/vectors.<span class="hljs-property">S</span>)<br>        |--&gt;<span class="hljs-title function_">reset</span>(arch/arm/cpu/armv7/start.<span class="hljs-property">S</span>)    <br>            |--&gt;<span class="hljs-title function_">save_boot_params</span>(arch/arm/cpu/armv7/start.<span class="hljs-property">S</span>)<span class="hljs-comment">/*厂商自定义，将引导参数保存到内存中*/</span><br>                  |--&gt;<span class="hljs-title function_">save_boot_params_ret</span>(arch/arm/cpu/armv7/start.<span class="hljs-property">S</span>)<span class="hljs-comment">/* 根据reset的运行地址和链接地址进行计算偏移量，遍历.rel.dyn 执行重定位(在flash/  SRAM上的重定位)。同时检查CPU模式，关闭中断，设置中断向量表*/</span><br>                    |--&gt;<span class="hljs-title function_">cpu_init_cp15</span>(arch/arm/cpu/armv7/start.<span class="hljs-property">S</span>)<span class="hljs-comment">/*初始化CPU: 失效 L1 I/D Cache,配置CP15协处理器(MMU/catch相关寄存器)*/</span><br>                    |--&gt;<span class="hljs-title function_">cpu_init_crit</span>(arch/arm/cpu/armv7/start.<span class="hljs-property">S</span>)<br>                        |--&gt;<span class="hljs-title function_">lowlevel_init</span>(arch/arm/cpu/armv7/lowlevel_init.<span class="hljs-property">S</span>)<span class="hljs-comment">/* 设置临时栈,设置r9(gd:始终频率/内存基址/设备树指针..) */</span><br>                    |--&gt;<span class="hljs-title function_">_main</span>(arch/arm/lib/crt0.<span class="hljs-property">S</span>)<br>                        |--&gt;<span class="hljs-title function_">board_init_f_alloc_reserve</span>(common/init/board_init.<span class="hljs-property">c</span>)<span class="hljs-comment">/*为u-boot的gd结构体分配空间*/</span><br>                        |--&gt;<span class="hljs-title function_">board_init_f_init_reserve</span>(common/init/board_init.<span class="hljs-property">c</span>)    <span class="hljs-comment">/*将gd结构体清零*/</span><br>                        |--&gt;<span class="hljs-title function_">board_init_f</span>(common/board_f.<span class="hljs-property">c</span>)<br>                            |--&gt;<span class="hljs-title function_">initcall_run_list</span>(include/initcall.<span class="hljs-property">h</span>)    <span class="hljs-comment">/*初始化序列函数*/</span><br>                                |--&gt;init_sequence_f[](common/board_f.<span class="hljs-property">c</span>)    <span class="hljs-comment">/* 初始化序列函数数组 */</span><br>                                    |--&gt;<span class="hljs-title function_">board_early_init_f</span>(board/freescale/mx6ull_toto/mx6ull_toto.<span class="hljs-property">c</span>)<span class="hljs-comment">/*初始化串口的IO配置*/</span><br>                                    |--&gt;<span class="hljs-title function_">timer_init</span>(arch/arm/imx-common/timer.<span class="hljs-property">c</span>)    <span class="hljs-comment">/*初始化内核定时器，为uboot提供时钟节拍*/</span><br>                                    |--&gt;<span class="hljs-title function_">init_baud_rate</span>(common/board_f.<span class="hljs-property">c</span>)        <span class="hljs-comment">/*初始化波特率*/</span><br>                                    |--&gt;<span class="hljs-title function_">serial_init</span>(drivers/serial/serial.<span class="hljs-property">c</span>)    <span class="hljs-comment">/*初始化串口通信设置*/</span><br>                                    |--&gt;<span class="hljs-title function_">console_init_f</span>(common/<span class="hljs-variable language_">console</span>.<span class="hljs-property">c</span>)        <span class="hljs-comment">/*初始化控制台*/</span><br>                                    |--&gt;...<br>                        |--&gt;<span class="hljs-title function_">relocate_code</span>(arch/arm/lib/relocate.<span class="hljs-property">S</span>)    <span class="hljs-comment">/*主要完成镜像拷贝和重定位*/</span><br>                        |--&gt;<span class="hljs-title function_">relocate_vectors</span>(arch/arm/lib/relocate.<span class="hljs-property">S</span>)<span class="hljs-comment">/*重定位向量表*/</span><br>                        |--&gt;<span class="hljs-title function_">board_init_r</span>(common/board_r.<span class="hljs-property">c</span>)<span class="hljs-comment">/*板级初始化*/</span><br>                            |--&gt;<span class="hljs-title function_">initcall_run_list</span>(include/initcall.<span class="hljs-property">h</span>)<span class="hljs-comment">/*初始化序列函数*/</span><br>                                |--&gt;init_sequence_r[](common/board_f.<span class="hljs-property">c</span>)<span class="hljs-comment">/*序列函数*/</span><br>                                    |--&gt;<span class="hljs-title function_">initr_reloc</span>(common/board_r.<span class="hljs-property">c</span>)    <span class="hljs-comment">/*设置 gd-&gt;flags,标记重定位完成*/</span><br>                                    |--&gt;<span class="hljs-title function_">serial_initialize</span>(drivers/serial/serial-uclass.<span class="hljs-property">c</span>)<span class="hljs-comment">/*初始化串口*/</span><br>                                        |--&gt;<span class="hljs-title function_">serial_init</span>(drivers/serial/serial-uclass.<span class="hljs-property">c</span>)     <span class="hljs-comment">/*初始化串口*/</span><br>                                    |--&gt;<span class="hljs-title function_">initr_mmc</span>(common/board_r.<span class="hljs-property">c</span>)                         <span class="hljs-comment">/*初始化emmc*/</span><br>                                        |--&gt;<span class="hljs-title function_">mmc_initialize</span>(drivers/mmc/mmc.<span class="hljs-property">c</span>)<br>                                            |--&gt;<span class="hljs-title function_">mmc_do_preinit</span>(drivers/mmc/mmc.<span class="hljs-property">c</span>)<br>                                                |--&gt;<span class="hljs-title function_">mmc_start_init</span>(drivers/mmc/mmc.<span class="hljs-property">c</span>)<br>                                    |--&gt;<span class="hljs-title function_">console_init_r</span>(common/<span class="hljs-variable language_">console</span>.<span class="hljs-property">c</span>)                <span class="hljs-comment">/*初始化控制台*/</span><br>                                    |--&gt;<span class="hljs-title function_">interrupt_init</span>(arch/arm/lib/interrupts.<span class="hljs-property">c</span>)        <span class="hljs-comment">/*初始化中断*/</span><br>                                    |--&gt;<span class="hljs-title function_">initr_net</span>(common/board_r.<span class="hljs-property">c</span>)                        <span class="hljs-comment">/*初始化网络设备*/</span><br>                                        |--&gt;<span class="hljs-title function_">eth_initialize</span>(net/eth-uclass.<span class="hljs-property">c</span>)<br>                                            |--&gt;<span class="hljs-title function_">eth_common_init</span>(net/eth_common.<span class="hljs-property">c</span>)<br>                                                |--&gt;<span class="hljs-title function_">phy_init</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                            |--&gt;<span class="hljs-title function_">uclass_first_device_check</span>(drivers/core/uclass.<span class="hljs-property">c</span>)<br>                                                |--&gt;<span class="hljs-title function_">uclass_find_first_device</span>(drivers/core/uclass.<span class="hljs-property">c</span>)<br>                                                |--&gt;<span class="hljs-title function_">device_probe</span>(drivers/core/device.<span class="hljs-property">c</span>)<br>                                                    |--&gt;<span class="hljs-title function_">device_of_to_plat</span>(drivers/core/device.<span class="hljs-property">c</span>)<br>                                                        |--&gt;drv-&gt;of_to_plat<br>                                                            |--&gt;<span class="hljs-title function_">fecmxc_of_to_plat</span>(drivers/net/fec_mxc.<span class="hljs-property">c</span>)<span class="hljs-comment">/*解析设备树信息*/</span><br>                                                    |--&gt;<span class="hljs-title function_">device_get_uclass_id</span>(drivers/core/device.<span class="hljs-property">c</span>)<br>                                                    |--&gt;<span class="hljs-title function_">uclass_pre_probe_device</span>(drivers/core/uclass.<span class="hljs-property">c</span>)<br>                                                    |--&gt;drv-&gt;<span class="hljs-title function_">probe</span>(dev)<br>                                                        <span class="hljs-comment">/*drivers/net/fec_mxc.c*/</span><br>                                                        <span class="hljs-title function_">U_BOOT_DRIVER</span>(fecmxc_gem) = &#123;<br>                                                            .<span class="hljs-property">name</span>    = <span class="hljs-string">&quot;fecmxc&quot;</span>,<br>                                                            .<span class="hljs-property">id</span>    = <span class="hljs-variable constant_">UCLASS_ETH</span>,<br>                                                            .<span class="hljs-property">of_match</span> = fecmxc_ids,<br>                                                            .<span class="hljs-property">of_to_plat</span> = fecmxc_of_to_plat,<br>                                                            .<span class="hljs-property">probe</span>    = fecmxc_probe,<br>                                                            .<span class="hljs-property">remove</span>    = fecmxc_remove,<br>                                                            .<span class="hljs-property">ops</span>    = &amp;fecmxc_ops,<br>                                                            .<span class="hljs-property">priv_auto</span>    = <span class="hljs-title function_">sizeof</span>(struct fec_priv),<br>                                                            .<span class="hljs-property">plat_auto</span>    = <span class="hljs-title function_">sizeof</span>(struct eth_pdata),<br>                                                        &#125;;<br>                                                        |--&gt;<span class="hljs-title function_">fecmxc_probe</span>(drivers/net/fec_mxc.<span class="hljs-property">c</span>)<span class="hljs-comment">/*探测和初始化*/</span><br>                                                            |--&gt;<span class="hljs-title function_">fec_get_miibus</span>(drivers/net/fec_mxc.<span class="hljs-property">c</span>)<br>                                                                |--&gt;<span class="hljs-title function_">mdio_alloc</span>(drivers/net/fec_mxc.<span class="hljs-property">c</span>)<br>                                                                |--&gt;bus-&gt;read = fec_phy_read;<br>                                                                |--&gt;bus-&gt;write = fec_phy_write;<br>                                                                |--&gt;<span class="hljs-title function_">mdio_register</span>(common/miiphyutil.<span class="hljs-property">c</span>)<br>                                                                |--&gt;<span class="hljs-title function_">fec_mii_setspeed</span>(drivers/net/fec_mxc.<span class="hljs-property">c</span>)<br>                                                            |--&gt;<span class="hljs-title function_">fec_phy_init</span>(drivers/net/fec_mxc.<span class="hljs-property">c</span>)<br>                                                                |--&gt;<span class="hljs-title function_">device_get_phy_addr</span>(drivers/net/fec_mxc.<span class="hljs-property">c</span>)<br>                                                                |--&gt;<span class="hljs-title function_">phy_connect</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                    |--&gt;<span class="hljs-title function_">phy_find_by_mask</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                        |--&gt;bus-&gt;<span class="hljs-title function_">reset</span>(bus)<br>                                                                        |--&gt;<span class="hljs-title function_">get_phy_device_by_mask</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                            |--&gt;<span class="hljs-title function_">create_phy_by_mask</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                                |--&gt;<span class="hljs-title function_">phy_device_create</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                                    |--&gt;<span class="hljs-title function_">phy_probe</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                    |--&gt;<span class="hljs-title function_">phy_connect_dev</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                        |--&gt;<span class="hljs-title function_">phy_reset</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                |--&gt;<span class="hljs-title function_">phy_config</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                    |--&gt;<span class="hljs-title function_">board_phy_config</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                        |--&gt;phydev-&gt;drv-&gt;<span class="hljs-title function_">config</span>(phydev)<br>                                                                            <span class="hljs-comment">/*drivers/net/phy/smsc.c*/</span><br>                                                                            <span class="hljs-keyword">static</span> struct phy_driver lan8710_driver = &#123;<br>                                                                                .<span class="hljs-property">name</span> = <span class="hljs-string">&quot;SMSC LAN8710/LAN8720&quot;</span>,<br>                                                                                .<span class="hljs-property">uid</span> = <span class="hljs-number">0x0007c0f0</span>,<br>                                                                                .<span class="hljs-property">mask</span> = <span class="hljs-number">0xffff0</span>,<br>                                                                                .<span class="hljs-property">features</span> = <span class="hljs-variable constant_">PHY_BASIC_FEATURES</span>,<br>                                                                                .<span class="hljs-property">config</span> = &amp;genphy_config_aneg,<br>                                                                                .<span class="hljs-property">startup</span> = &amp;genphy_startup,<br>                                                                                .<span class="hljs-property">shutdown</span> = &amp;genphy_shutdown,<br>                                                                            &#125;;<br>                                                                            |--&gt;<span class="hljs-title function_">genphy_config_aneg</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                                |--&gt;<span class="hljs-title function_">phy_reset</span>(需要手动调用)(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                                |--&gt;<span class="hljs-title function_">genphy_setup_forced</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                                |--&gt;<span class="hljs-title function_">genphy_config_advert</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                                                |--&gt;<span class="hljs-title function_">genphy_restart_aneg</span>(drivers/net/phy/phy.<span class="hljs-property">c</span>)<br>                                                    |--&gt;<span class="hljs-title function_">uclass_post_probe_device</span>(drivers/core/uclass.<span class="hljs-property">c</span>)<br>                                                        |--&gt;uc_drv-&gt;<span class="hljs-title function_">post_probe</span>(drivers/core/uclass.<span class="hljs-property">c</span>)<br>                                                            <span class="hljs-comment">/*net/eth-uclass.c*/</span><br>                                                            <span class="hljs-title function_">UCLASS_DRIVER</span>(ethernet) = &#123;<br>                                                                .<span class="hljs-property">name</span>        = <span class="hljs-string">&quot;ethernet&quot;</span>,<br>                                                                .<span class="hljs-property">id</span>        = <span class="hljs-variable constant_">UCLASS_ETH</span>,<br>                                                                .<span class="hljs-property">post_bind</span>    = eth_post_bind,<br>                                                                .<span class="hljs-property">pre_unbind</span>    = eth_pre_unbind,<br>                                                                .<span class="hljs-property">post_probe</span>    = eth_post_probe,<br>                                                                .<span class="hljs-property">pre_remove</span>    = eth_pre_remove,<br>                                                                .<span class="hljs-property">priv_auto</span>    = <span class="hljs-title function_">sizeof</span>(struct eth_uclass_priv),<br>                                                                .<span class="hljs-property">per_device_auto</span>    = <span class="hljs-title function_">sizeof</span>(struct eth_device_priv),<br>                                                                .<span class="hljs-property">flags</span>        = <span class="hljs-variable constant_">DM_UC_FLAG_SEQ_ALIAS</span>,<br>                                                            &#125;;<br>                                                            |--&gt;<span class="hljs-title function_">eth_post_probe</span>(net/eth-uclass.<span class="hljs-property">c</span>)<br>                                                                |--&gt;<span class="hljs-title function_">eth_write_hwaddr</span>(drivers/core/uclass.<span class="hljs-property">c</span>)<br>                                    |--&gt;...<br>                                    |--&gt;<span class="hljs-title function_">run_main_loop</span>(common/board_r.<span class="hljs-property">c</span>)<span class="hljs-comment">/*主循环，处理命令*/</span><br>                                        |--&gt;<span class="hljs-title function_">main_loop</span>(common/main.<span class="hljs-property">c</span>)<br>                                            |--&gt;<span class="hljs-title function_">bootdelay_process</span>(common/autoboot.<span class="hljs-property">c</span>)    <span class="hljs-comment">/*读取环境变量bootdelay和bootcmd的内容*/</span><br>                                            |--&gt;<span class="hljs-title function_">autoboot_command</span>(common/autoboot.<span class="hljs-property">c</span>)        <span class="hljs-comment">/*倒计时按下执行，没有操作执行bootcmd的参数*/</span><br>                                                |--&gt;<span class="hljs-title function_">abortboot</span>(common/autoboot.<span class="hljs-property">c</span>)<br>                                                    |--&gt;<span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Hit any key to stop autoboot: %2d &quot;</span>, bootdelay);<br>                                                    <span class="hljs-comment">/*到这里就是我们看到uboot延时3s启动内核的地方*/</span><br>                                            |--&gt;<span class="hljs-title function_">cli_loop</span>(common/cli.<span class="hljs-property">c</span>)    <span class="hljs-comment">/*倒计时按下space键,执行用户输入命令*/</span><br></code></pre></td></tr></table></figure><p><strong>图示</strong><br><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/u-boot/image-0.png" alt="alt text"></p>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/">linux</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/uboot/">uboot</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/uboot/uboot-start/">uboot_start</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/uboot-start/">uboot_start</category>
      
      
      <comments>https://goko-son626.github.io/post/u-boot.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>平台总线的结构及框架分析</title>
      <link>https://goko-son626.github.io/post/Platform-bus.html</link>
      <guid>https://goko-son626.github.io/post/Platform-bus.html</guid>
      <pubDate>Fri, 07 Jun 2024 03:33:21 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;平台总线是linux系统虚拟出来的一种总线,是一个内核子系统，负责管理 platform_device（硬件描述）和 platform_driver（驱动代码）,使它们先分离.后搭档&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>平台总线是linux系统虚拟出来的一种总线,是一个内核子系统，负责管理 platform_device（硬件描述）和 platform_driver（驱动代码）,使它们先分离.后搭档</strong></em></li></ul><span id="more"></span><h3 id="平台总线-Platform-Bus-总线控制器信息和控制器驱动之间"><a href="#平台总线-Platform-Bus-总线控制器信息和控制器驱动之间" class="headerlink" title="平台总线(Platform Bus)(总线控制器信息和控制器驱动之间)"></a>平台总线(Platform Bus)(总线控制器信息和控制器驱动之间)</h3><ul><li>平台总线（Platform Bus）是内核的一条“虚拟”总线。它不像 PCI、USB 那样是物理上存在的总线，而是为了解决一类特殊设备的驱动问题而设计的 <strong>软件机制</strong>。这类设备通常是 <strong>SoC (System on Chip) 芯片内部集成的、不可被自动识别的外设</strong>，比如 I2C 控制器、SPI 控制器、GPIO 控制器、LCD 控制器等。</li></ul><ul><li><strong>原理：设备与驱动的分离与匹配 (Separation and Matching)</strong><ul><li><p><strong>问题：</strong> 对于 PCI 或 USB 设备，设备自身带有 ID 信息（Vendor ID, Product ID）。驱动可以根据这些 ID “认领” 设备。但 SoC 上的那些外设，它们的寄存器地址、中断号都是固定的，写死在芯片里了，没法自动发现。</p></li><li><p><strong>解决：</strong> 把 <strong>设备信息</strong> 和 <strong>驱动代码</strong> 分开！”</p><ol><li><strong>平台设备 (<code>platform_device</code>)：</strong> 这是一块纯粹的“数据”，用来描述硬件资源。它告诉内核：“在物理地址 <code>0x12345678</code> 有个设备，它使用中断号 <code>5</code>，它的名字叫 <code>my-i2c-controller</code>”。这些信息通常写在 <strong>设备树 (Device Tree, <code>.dts</code> 文件)</strong> 中，或者早期的板级配置文件 (<code>board-xxx.c</code>)里。</li><li><strong>平台驱动 (<code>platform_driver</code>)：</strong> 真正的驱动代码。注册时告诉内核：是一个驱动，我能处理名字叫 <code>my-i2c-controller</code> 的设备。</li><li><strong>匹配 (<code>Match</code>)：</strong> 当一个 <code>platform_device</code> 和一个 <code>platform_driver</code> 被注册到内核时，平台总线核心会进行匹配。最常见的匹配方式就是看 <strong>名字</strong> 是否一样。</li><li><strong>探测 (<code>Probe</code>)：</strong> 一旦匹配成功，总线核心就会调用平台驱动的 <code>.probe</code> 函数。在这个函数里，驱动程序会通过相关的API函数从 <code>platform_device</code> 结构体中获取到设备的硬件资源（如内存地址、中断号），然后用这些信息去初始化硬件，完成驱动的加载。</li></ol></li><li><p><strong>流程：</strong></p><ul><li>系统启动，内核解析设备树。</li><li>内核在设备树里读到一段描述 I2C 控制器硬件的节点（包含了寄存器地址、中断号，以及最重要的 compatible &#x3D; “vendor,i2c-controller-v1”;）。</li><li>内核根据这个节点，创建并注册一个 platform_device 到平台总线。</li><li>I2C 控制器驱动（platform_driver）在加载时，会告诉平台总线：“我能处理 compatible 是 “vendor,i2c-controller-v1” 的设备”。</li><li>平台总线看到两者匹配，于是调用 I2C 控制器驱动的 .probe 函数。<ul><li>在 I2C 控制器驱动的 .probe 函数中，驱动程序会执行一系列初始化操作，其中最重要的一步是调用 i2c_add_adapter() 或 i2c_add_numbered_adapter()。这个函数调用，才是在内核中“建立”或“注册”了一条 I2C 总线（即一个 i2c_adapter）。这条逻辑上的总线就代表了那条物理的 I2C 总线。内核里的 i2c_adapter 就是物理 I2C 总线在软件层面的抽象。</li></ul></li><li><strong>设备间交互</strong>：<ul><li>“其他设备驱动”（比如 I2C 温度传感器驱动）不直接调用 I2C 控制器驱动里的 ops。这是一个分层概念。</li><li>正确的交互方式：<ul><li>I2C 控制器驱动把它实现底层 I&#x2F;O 操作的 ops（struct i2c_algorithm）注册给了 I2C 总线核心。</li><li>I2C 温度传感器驱动想通信时，它调用的是 I2C 总线核心提供的标准、统一的 API，如 i2c_master_send() 和 i2c_master_recv()。</li><li>I2C 总线核心在收到这些 API 调用后，会找到对应的 i2c_adapter，然后去调用这个 adapter 在注册时提供的 ops 里的具体函数，最终由 I2C 控制器驱动的代码来操作硬件。</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="platform-bus-设备和驱动"><a href="#platform-bus-设备和驱动" class="headerlink" title="platform bus 设备和驱动"></a>platform bus 设备和驱动</h3><h4 id="1-platform-device结构体"><a href="#1-platform-device结构体" class="headerlink" title="1. platform_device结构体"></a>1. platform_device结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>*name;  <span class="hljs-comment">// 显示在/sys/bus/platform/devices/name.id(.auto)</span><br>  <span class="hljs-type">int</span>id;           <span class="hljs-comment">// 用来区分不同设备：name.id, id = -1: 没有后缀</span><br>  <span class="hljs-type">bool</span>id_auto;    <span class="hljs-comment">// 自动设置id：name.id.auto</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span><span class="hljs-title">dev</span>;</span>  <span class="hljs-comment">// 设备的通用属性部分</span><br>  u64platform_dma_mask;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_dma_parameters</span> <span class="hljs-title">dma_parms</span>;</span><br>  u32num_resources;        <span class="hljs-comment">// 存储的资源的个数</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span>*<span class="hljs-title">resource</span>;</span>  <span class="hljs-comment">// 存储资源</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span>*<span class="hljs-title">id_entry</span>;</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * Driver name to force a match.  Do not set directly, because core</span><br><span class="hljs-comment">   * frees it.  Use driver_set_override() to set or clear it.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *driver_override;<br><br>  <span class="hljs-comment">/* MFD cell pointer */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mfd_cell</span> *<span class="hljs-title">mfd_cell</span>;</span><br><br>  <span class="hljs-comment">/* arch specific additions */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pdev_archdata</span><span class="hljs-title">archdata</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>成员结构体:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span>*<span class="hljs-title">parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_private</span>*<span class="hljs-title">p</span>;</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>*init_name; <span class="hljs-comment">/* initial name of the device */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_type</span> *<span class="hljs-title">type</span>;</span><br><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span>*<span class="hljs-title">bus</span>;</span><span class="hljs-comment">/* type of bus device is on */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> *<span class="hljs-title">driver</span>;</span><span class="hljs-comment">/* which driver has allocated this</span><br><span class="hljs-comment">   device */</span><br><span class="hljs-type">void</span>*platform_data;<span class="hljs-comment">/* Platform specific data, device</span><br><span class="hljs-comment">   core doesn&#x27;t touch it */</span><br><span class="hljs-type">void</span>*driver_data;<span class="hljs-comment">/* Driver data, set and get with</span><br><span class="hljs-comment">   dev_set_drvdata/dev_get_drvdata */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span><span class="hljs-title">mutex</span>;</span><span class="hljs-comment">/* mutex to synchronize calls to</span><br><span class="hljs-comment"> * its driver.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_links_info</span><span class="hljs-title">links</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_info</span><span class="hljs-title">power</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_domain</span>*<span class="hljs-title">pm_domain</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ENERGY_MODEL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">em_perf_domain</span>*<span class="hljs-title">em_pd</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PINCTRL</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pin_info</span>*<span class="hljs-title">pins</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_msi_info</span><span class="hljs-title">msi</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_ARCH_HAS_DMA_OPS</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_map_ops</span> *<span class="hljs-title">dma_ops</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>u64*dma_mask;<span class="hljs-comment">/* dma mask (if dma&#x27;able device) */</span><br>u64coherent_dma_mask;<span class="hljs-comment">/* Like dma_mask, but for</span><br><span class="hljs-comment">     alloc_coherent mappings as</span><br><span class="hljs-comment">     not all hardware supports</span><br><span class="hljs-comment">     64 bit addresses for consistent</span><br><span class="hljs-comment">     allocations such descriptors. */</span><br>u64bus_dma_limit;<span class="hljs-comment">/* upstream dma constraint */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_dma_region</span> *<span class="hljs-title">dma_range_map</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_dma_parameters</span> *<span class="hljs-title">dma_parms</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">dma_pools</span>;</span><span class="hljs-comment">/* dma pools (if dma&#x27;ble) */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DMA_DECLARE_COHERENT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dma_coherent_mem</span>*<span class="hljs-title">dma_mem</span>;</span> <span class="hljs-comment">/* internal for coherent mem</span><br><span class="hljs-comment">     override */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DMA_CMA</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cma</span> *<span class="hljs-title">cma_area</span>;</span><span class="hljs-comment">/* contiguous memory area for dma</span><br><span class="hljs-comment">   allocations */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SWIOTLB</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_tlb_mem</span> *<span class="hljs-title">dma_io_tlb_mem</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SWIOTLB_DYNAMIC</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">dma_io_tlb_pools</span>;</span><br><span class="hljs-type">spinlock_t</span> dma_io_tlb_lock;<br><span class="hljs-type">bool</span> dma_uses_io_tlb;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* arch specific additions */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_archdata</span><span class="hljs-title">archdata</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span>*<span class="hljs-title">of_node</span>;</span> <span class="hljs-comment">/* associated device tree node */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fwnode_handle</span>*<span class="hljs-title">fwnode</span>;</span> <span class="hljs-comment">/* firmware device node */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br><span class="hljs-type">int</span>numa_node;<span class="hljs-comment">/* NUMA node this device is close to */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">dev_t</span>devt;<span class="hljs-comment">/* dev_t, creates the sysfs &quot;dev&quot; */</span><br>u32id;<span class="hljs-comment">/* device instance */</span><br><br><span class="hljs-type">spinlock_t</span>devres_lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">devres_head</span>;</span><br><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span>*<span class="hljs-keyword">class</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute_group</span> **<span class="hljs-title">groups</span>;</span><span class="hljs-comment">/* optional groups */</span><br><br><span class="hljs-type">void</span>(*release)(<span class="hljs-keyword">struct</span> device *dev);      <span class="hljs-comment">// 必须编写，不然驱动编译不过去</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iommu_group</span>*<span class="hljs-title">iommu_group</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_iommu</span>*<span class="hljs-title">iommu</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_physical_location</span> *<span class="hljs-title">physical_location</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">device_removable</span><span class="hljs-title">removable</span>;</span><br><br><span class="hljs-type">bool</span>offline_disabled:<span class="hljs-number">1</span>;<br><span class="hljs-type">bool</span>offline:<span class="hljs-number">1</span>;<br><span class="hljs-type">bool</span>of_node_reused:<span class="hljs-number">1</span>;<br><span class="hljs-type">bool</span>state_synced:<span class="hljs-number">1</span>;<br><span class="hljs-type">bool</span>can_match:<span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \</span><br><span class="hljs-meta">    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \</span><br><span class="hljs-meta">    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)</span><br><span class="hljs-type">bool</span>dma_coherent:<span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DMA_OPS_BYPASS</span><br><span class="hljs-type">bool</span>dma_ops_bypass : <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DMA_NEED_SYNC</span><br><span class="hljs-type">bool</span>dma_skip_sync:<span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_IOMMU_DMA</span><br><span class="hljs-type">bool</span>dma_iommu:<span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Resources are tree-like, allowing</span><br><span class="hljs-comment"> * nesting etc..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> &#123;</span><br><span class="hljs-type">resource_size_t</span> start;  <span class="hljs-comment">// 资源的起始信息和终止信息</span><br><span class="hljs-type">resource_size_t</span> end;    <span class="hljs-comment">// etc：中断的起始地址和终止地址</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;       <span class="hljs-comment">// 存储信息名称：etc：中断-irq</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;    <span class="hljs-comment">// 存储资源类型：etc: IORESOURCE_IO/MEM/REG/IRQ/DMA/BUS...</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> desc;     <span class="hljs-comment">// 描述信息</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">parent</span>, *<span class="hljs-title">sibling</span>, *<span class="hljs-title">child</span>;</span> <span class="hljs-comment">// 节点相关</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-简单的platform-device"><a href="#2-简单的platform-device" class="headerlink" title="2. 简单的platform_device"></a>2. 简单的platform_device</h4><ul><li>insmod注册成功：ls &#x2F;sys&#x2F;bus&#x2F;platform&#x2F;devices&#x2F;mydevice</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> <span class="hljs-title">mydevice_resource</span>[] =</span> &#123;<br>  [<span class="hljs-number">0</span>] = &#123;<br>    .start = <span class="hljs-number">0xFDD60000</span>,<br>    .end = <span class="hljs-number">0xFDD50004</span>,<br>    .flags = IORESOURCE_IO,<br>  &#125;,<br>  [<span class="hljs-number">1</span>] = &#123;<br>    .start = <span class="hljs-number">13</span>,<br>    .end = <span class="hljs-number">13</span>,<br>    .flags = IORESOURCE_IRQ,<br>  &#125;,<br>&#125;<br><br><span class="hljs-type">void</span> mydevice_release(<span class="hljs-keyword">struct</span> device *dev)<br>&#123;<br>  printk(<span class="hljs-string">&quot;This is mydevice_release\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">static</span> platform_device platform_device_test = &#123;<br>  .name = <span class="hljs-string">&quot;mydevice&quot;</span>,<br>  .id = <span class="hljs-number">-1</span>,<br>  .resource = mydevice_resource,<br>  .num_resources = ARRAY_SIZE(mydevice_resource),<br>  .dev = &#123;<br>    .release = mydevice_release,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">platform_device_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  platform_device_register(&amp;platform_device_test);<br><br>  printk(<span class="hljs-string">&quot;platform_device init\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">platform_device_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  platform_device_unregister(&amp;platform_device_test);<br><br>  printk(<span class="hljs-string">&quot;platform_device exit\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>module <span class="hljs-title function_">init</span><span class="hljs-params">(platform_device_init)</span>;<br>module <span class="hljs-title function_">exit</span><span class="hljs-params">(platform_device_exit)</span>;<br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;goko&quot;</span>);<br>MODULE_VERSION(<span class="hljs-string">&quot;V1.0&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="3-platform-driver结构体"><a href="#3-platform-driver结构体" class="headerlink" title="3. platform_driver结构体"></a>3. platform_driver结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> &#123;</span><br><span class="hljs-type">int</span> (*probe)(<span class="hljs-keyword">struct</span> platform_device *);     <span class="hljs-comment">// 匹配成功之后执行</span><br><span class="hljs-type">void</span> (*remove)(<span class="hljs-keyword">struct</span> platform_device *);   <span class="hljs-comment">// 设备移除时执行</span><br><span class="hljs-type">void</span> (*shutdown)(<span class="hljs-keyword">struct</span> platform_device *); <span class="hljs-comment">// 设备关闭时执行dy</span><br><span class="hljs-type">int</span> (*suspend)(<span class="hljs-keyword">struct</span> platform_device *, <span class="hljs-type">pm_message_t</span> state); <span class="hljs-comment">// 设备挂起时执行dy</span><br><span class="hljs-type">int</span> (*resume)(<span class="hljs-keyword">struct</span> platform_device *);    <span class="hljs-comment">// 设备恢复时执行dy</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> <span class="hljs-title">driver</span>;</span>                <span class="hljs-comment">// 设备公用的一些属性</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> *<span class="hljs-title">id_table</span>;</span>  <span class="hljs-comment">// 设备id表</span><br><span class="hljs-type">bool</span> prevent_deferred_probe;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * For most device drivers, no need to care about this flag as long as</span><br><span class="hljs-comment"> * all DMAs are handled through the kernel DMA API. For some special</span><br><span class="hljs-comment"> * ones, for example VFIO drivers, they know how to manage the DMA</span><br><span class="hljs-comment"> * themselves and set this flag so that the IOMMU layer will allow them</span><br><span class="hljs-comment"> * to setup and manage their own I/O address space.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> driver_managed_dma;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-简单的platform-driver"><a href="#4-简单的platform-driver" class="headerlink" title="4. 简单的platform_driver"></a>4. 简单的platform_driver</h4><ul><li>insmod注册成功：ls &#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;mydevice</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span>      <span class="hljs-comment">// 所有模块都需要</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span>        <span class="hljs-comment">// __init 和 __exit 宏</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span>          <span class="hljs-comment">// file_operations 结构体和文件系统相关函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span>        <span class="hljs-comment">// cdev 结构体和相关函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span>     <span class="hljs-comment">// copy_to_user, copy_from_user</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span>      <span class="hljs-comment">// class_create, device_create</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/io.h&gt;</span>          <span class="hljs-comment">// ioremap, iounmap</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span> <span class="hljs-comment">// platform_driver 和 platform_device</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span>          <span class="hljs-comment">// of_match_ptr, 设备树相关（如果使用设备树匹配）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span>        <span class="hljs-comment">// kzalloc, kfree</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DRIVER_NAME <span class="hljs-string">&quot;my_platform_device&quot;</span> <span class="hljs-comment">// 定义驱动名称</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVICE_COUNT 1                   <span class="hljs-comment">// 定义设备数量</span></span><br><br><span class="hljs-comment">// 驱动的私有数据结构体，用于存储设备相关的所有信息</span><br><span class="hljs-comment">// 这个结构体整合了你截图中`struct device_test`的所有成员</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mydevice_dev</span> &#123;</span><br>    <span class="hljs-type">dev_t</span> dev_num;             <span class="hljs-comment">// 设备号 (主设备号 + 次设备号)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev_test</span>;</span>     <span class="hljs-comment">// 字符设备结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span>       <span class="hljs-comment">// 设备类，用于在/sys/class/下创建条目</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span>     <span class="hljs-comment">// 设备实例，用于在/dev/下创建设备文件</span><br>    <span class="hljs-type">char</span> kbuf[<span class="hljs-number">32</span>];             <span class="hljs-comment">// 内核缓冲区，用于与用户空间交换数据</span><br>    <span class="hljs-type">void</span> __iomem *vir_gpio_dr;  <span class="hljs-comment">// 经过ioremap映射后的虚拟地址</span><br>&#125;;<br><br><span class="hljs-comment">// 全局指针，指向我们的私有数据结构体</span><br><span class="hljs-comment">// 在probe中分配，在remove中释放</span><br><span class="hljs-comment">// 注意：更好的做法是通过 platform_set_drvdata/platform_get_drvdata 来管理，这里为了清晰展示，先用一个全局指针</span><br><span class="hljs-comment">// 稍后会展示更标准的做法</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mydevice_dev</span> *<span class="hljs-title">global_mydev</span>;</span> <br><br><span class="hljs-comment">// --- 文件操作函数集 (file_operations) ---</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mydevice_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *file)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mydevice_dev</span> *<span class="hljs-title">dev</span>;</span><br><br>    printk(KERN_INFO <span class="hljs-string">&quot;mydevice: device opened\n&quot;</span>);<br><br>    <span class="hljs-comment">// 通过 inode 中的 cdev 指针，找到包含它的父结构体 mydevice_dev</span><br>    <span class="hljs-comment">// 这是内核中非常常见和重要的技巧</span><br>    dev = container_of(inode-&gt;i_cdev, <span class="hljs-keyword">struct</span> mydevice_dev, cdev_test);<br><br>    <span class="hljs-comment">// 将设备私有结构体的指针存放在 file-&gt;private_data 中</span><br>    <span class="hljs-comment">// 这样，在后续的 read/write/release 操作中，就可以直接从 file 中获取，无需再次查找</span><br>    file-&gt;private_data = dev; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mydevice_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *file)</span><br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;mydevice: device closed\n&quot;</span>);<br>    <span class="hljs-comment">// 这里不需要释放 file-&gt;private_data，因为它指向的是在 probe 中分配的内存</span><br>    <span class="hljs-comment">// 该内存的生命周期与驱动绑定，而不是与文件的打开/关闭绑定</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">mydevice_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *off)</span><br>&#123;<br>    <span class="hljs-comment">// 从 file-&gt;private_data 中获取设备私有结构体指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mydevice_dev</span> *<span class="hljs-title">dev</span> =</span> file-&gt;private_data;<br>    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(dev-&gt;kbuf);<br>    <span class="hljs-type">int</span> ret;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;mydevice: reading data: %s\n&quot;</span>, dev-&gt;kbuf);<br><br>    <span class="hljs-keyword">if</span> (size &gt; len) &#123;<br>        size = len;<br>    &#125;<br><br>    <span class="hljs-comment">// 将内核空间的数据 (dev-&gt;kbuf) 拷贝到用户空间 (buf)</span><br>    ret = copy_to_user(buf, dev-&gt;kbuf, size);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;mydevice: copy_to_user failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -EFAULT; <span class="hljs-comment">// 返回一个标准的错误码</span><br>    &#125;<br><br>    <span class="hljs-comment">// 在这里，一个简单的实现是每次读取后返回已读取的字节数</span><br>    <span class="hljs-comment">// 一个更完整的实现需要处理 *off，以支持多次读取文件的不同部分</span><br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">mydevice_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *off)</span><br>&#123;<br>    <span class="hljs-comment">// 从 file-&gt;private_data 中获取设备私有结构体指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mydevice_dev</span> *<span class="hljs-title">dev</span> =</span> file-&gt;private_data;<br>    <span class="hljs-type">int</span> ret;<br><br>    <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-keyword">sizeof</span>(dev-&gt;kbuf)) &#123;<br>        printk(KERN_WARNING <span class="hljs-string">&quot;mydevice: write size is too large\n&quot;</span>);<br>        <span class="hljs-comment">// 截断写入的数据，防止缓冲区溢出</span><br>        size = <span class="hljs-keyword">sizeof</span>(dev-&gt;kbuf) - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将用户空间的数据 (buf) 拷贝到内核空间 (dev-&gt;kbuf)</span><br>    ret = copy_from_user(dev-&gt;kbuf, buf, size);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;mydevice: copy_from_user failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -EFAULT;<br>    &#125;<br><br>    <span class="hljs-comment">// 给内核缓冲区加上字符串结束符</span><br>    dev-&gt;kbuf[size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;mydevice: written data: %s\n&quot;</span>, dev-&gt;kbuf);<br>    <br>    <span class="hljs-comment">// 在一个真实的GPIO驱动中，这里会解析 kbuf 中的命令（如&quot;on&quot;或&quot;off&quot;）</span><br>    <span class="hljs-comment">// 然后通过 dev-&gt;vir_gpio_dr 指针向硬件寄存器写入值</span><br>    <span class="hljs-comment">// 例如：iowrite32(1, dev-&gt;vir_gpio_dr);</span><br><br>    <span class="hljs-keyword">return</span> size; <span class="hljs-comment">// 返回成功写入的字节数</span><br>&#125;<br><br><span class="hljs-comment">// 定义 file_operations 结构体，并将我们的函数与之关联</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">mydevice_fops</span> =</span> &#123;<br>    .owner   = THIS_MODULE,<br>    .open    = mydevice_open,<br>    .release = mydevice_release,<br>    .read    = mydevice_read,<br>    .write   = mydevice_write,<br>&#125;;<br><br><br><span class="hljs-comment">// --- Platform 驱动核心函数 ---</span><br><br><span class="hljs-comment">// 当内核匹配到同名的 platform_device 时，会调用此 probe 函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mydriver_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span><br>&#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">mem_res</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mydevice_dev</span> *<span class="hljs-title">dev</span>;</span><br><br>    printk(KERN_INFO <span class="hljs-string">&quot;mydriver_probe: device probed!\n&quot;</span>);<br><br>    <span class="hljs-comment">// 1. 分配私有数据结构体内存</span><br>    <span class="hljs-comment">// 使用 devm_kzalloc, &quot;devm_&quot; 开头的函数是受设备管理的，当设备卸载时会自动释放资源，非常方便</span><br>    dev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> mydevice_dev), GFP_KERNEL);<br>    <span class="hljs-keyword">if</span> (!dev) &#123;<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br>    &#125;<br>    global_mydev = dev; <span class="hljs-comment">// 赋值给全局指针（仅为示例）</span><br><br>    <span class="hljs-comment">// 2. 从 platform_device 获取资源 (这里以内存资源为例)</span><br>    <span class="hljs-comment">// 参数: platform_device指针, 资源类型, 索引(第0个内存资源)</span><br>    mem_res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!mem_res) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;mydriver: failed to get memory resource\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -EINVAL;<br>    &#125;<br>    printk(KERN_INFO <span class="hljs-string">&quot;mydriver: mem resource start: 0x%pa, size: %lld\n&quot;</span>, &amp;mem_res-&gt;start, resource_size(mem_res));<br>    <br>    <span class="hljs-comment">// 3. 将物理地址映射到内核虚拟地址空间</span><br>    <span class="hljs-comment">// devm_ioremap_resource 会自动处理 ioremap 和 iounmap，非常推荐使用</span><br>    dev-&gt;vir_gpio_dr = devm_ioremap_resource(&amp;pdev-&gt;dev, mem_res);<br>    <span class="hljs-keyword">if</span> (IS_ERR(dev-&gt;vir_gpio_dr)) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;mydriver: failed to ioremap memory resource\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> PTR_ERR(dev-&gt;vir_gpio_dr);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ======== 以下是字符设备创建的标准流程 (来自你的截图逻辑) ========</span><br><br>    <span class="hljs-comment">// 4. 动态申请设备号</span><br>    ret = alloc_chrdev_region(&amp;dev-&gt;dev_num, <span class="hljs-number">0</span>, DEVICE_COUNT, DRIVER_NAME);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;mydriver: failed to allocate chrdev region\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    printk(KERN_INFO <span class="hljs-string">&quot;mydriver: allocated major=%d, minor=%d\n&quot;</span>, MAJOR(dev-&gt;dev_num), MINOR(dev-&gt;dev_num));<br><br>    <span class="hljs-comment">// 5. 初始化 cdev 结构体，并绑定 file_operations</span><br>    cdev_init(&amp;dev-&gt;cdev_test, &amp;mydevice_fops);<br>    dev-&gt;cdev_test.owner = THIS_MODULE;<br><br>    <span class="hljs-comment">// 6. 将 cdev 添加到内核中</span><br>    ret = cdev_add(&amp;dev-&gt;cdev_test, dev-&gt;dev_num, DEVICE_COUNT);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;mydriver: failed to add cdev\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_unregister_chrdev;<br>    &#125;<br><br>    <span class="hljs-comment">// 7. 创建设备类 /sys/class/my_platform_device</span><br>    dev-&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> =</span> class_create(THIS_MODULE, DRIVER_NAME);<br>    <span class="hljs-keyword">if</span> (IS_ERR(dev-&gt;class)) &#123;<br>        ret = PTR_ERR(dev-&gt;class);<br>        printk(KERN_ERR <span class="hljs-string">&quot;mydriver: failed to create class\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_cdev_del;<br>    &#125;<br><br>    <span class="hljs-comment">// 8. 创建设备文件 /dev/my_platform_device</span><br>    dev-&gt;device = device_create(dev-&gt;class, <span class="hljs-literal">NULL</span>, dev-&gt;dev_num, <span class="hljs-literal">NULL</span>, DRIVER_NAME);<br>    <span class="hljs-keyword">if</span> (IS_ERR(dev-&gt;device)) &#123;<br>        ret = PTR_ERR(dev-&gt;device);<br>        printk(KERN_ERR <span class="hljs-string">&quot;mydriver: failed to create device\n&quot;</span>);<br>        <span class="hljs-keyword">goto</span> err_class_destroy;<br>    &#125;<br><br>    <span class="hljs-comment">// 9. 将私有数据结构体指针与 platform_device 关联</span><br>    <span class="hljs-comment">// 这样在 remove 函数中就可以通过 platform_get_drvdata 获取它</span><br>    platform_set_drvdata(pdev, dev);<br><br>    <span class="hljs-comment">// 初始化内核缓冲区</span><br>    <span class="hljs-built_in">strcpy</span>(dev-&gt;kbuf, <span class="hljs-string">&quot;Hello from kernel!&quot;</span>);<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;mydriver: probe successful, device created at /dev/%s\n&quot;</span>, DRIVER_NAME);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 错误处理：按相反的顺序释放已申请的资源</span><br>err_class_destroy:<br>    class_destroy(dev-&gt;class);<br>err_cdev_del:<br>    cdev_del(&amp;dev-&gt;cdev_test);<br>err_unregister_chrdev:<br>    unregister_chrdev_region(dev-&gt;dev_num, DEVICE_COUNT);<br>    <span class="hljs-comment">// devm_kzalloc 和 devm_ioremap_resource 分配的资源会自动释放，无需手动处理</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 当驱动被卸载或设备被移除时，调用此 remove 函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mydriver_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span><br>&#123;<br>    <span class="hljs-comment">// 通过 platform_get_drvdata 获取在 probe 中设置的私有数据</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mydevice_dev</span> *<span class="hljs-title">dev</span> =</span> platform_get_drvdata(pdev);<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;mydriver_remove: removing device\n&quot;</span>);<br><br>    <span class="hljs-comment">// 按照与 probe 相反的顺序销毁和释放资源</span><br>    <span class="hljs-comment">// 注意：devm_ 家族函数管理的资源（内存、ioremap）不需要在这里手动释放！</span><br>    <span class="hljs-comment">// 驱动核心会在这个函数返回后自动清理它们。</span><br><br>    <span class="hljs-comment">// 销毁设备文件 /dev/my_platform_device</span><br>    device_destroy(dev-&gt;class, dev-&gt;dev_num);<br>    <span class="hljs-comment">// 销毁设备类 /sys/class/my_platform_device</span><br>    class_destroy(dev-&gt;class);<br>    <span class="hljs-comment">// 从内核中删除 cdev</span><br>    cdev_del(&amp;dev-&gt;cdev_test);<br>    <span class="hljs-comment">// 注销设备号</span><br>    unregister_chrdev_region(dev-&gt;dev_num, DEVICE_COUNT);<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;mydriver_remove: remove successful\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// ID 表，用于匹配 platform_device</span><br><span class="hljs-comment">// 当一个 platform_device 的 .name 字段与这里的 .name 匹配时，probe 就会被调用</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_device_id</span> <span class="hljs-title">mydriver_id_table</span>[] =</span> &#123;<br>    &#123; .name = <span class="hljs-string">&quot;my-platform-device-example&quot;</span> &#125;, <span class="hljs-comment">// 这个名字需要与 platform_device 注册时使用的名字完全一致</span><br>    &#123; <span class="hljs-comment">/* sentinel */</span> &#125;, <span class="hljs-comment">// 结尾的空条目，表示列表结束</span><br>&#125;;<br>MODULE_DEVICE_TABLE(platform, mydriver_id_table); <span class="hljs-comment">// 将id_table导出，让内核和用户空间知道</span><br><br><span class="hljs-comment">// 定义 platform_driver 结构体</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">my_platform_driver</span> =</span> &#123;<br>    .probe  = mydriver_probe,<br>    .remove = mydriver_remove,<br>    .driver = &#123;<br>        .name  = <span class="hljs-string">&quot;my-platform-device-example&quot;</span>, <span class="hljs-comment">// 驱动的名字</span><br>        .owner = THIS_MODULE,<br>    &#125;,<br>    .id_table = mydriver_id_table, <span class="hljs-comment">// 关联ID匹配表</span><br>&#125;;<br><br><span class="hljs-comment">// 模块加载函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">my_driver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;my_driver_init: Registering platform driver\n&quot;</span>);<br>    <span class="hljs-comment">// 注册 platform_driver 到内核</span><br>    <span class="hljs-keyword">return</span> platform_driver_register(&amp;my_platform_driver);<br>&#125;<br><br><span class="hljs-comment">// 模块卸载函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">my_driver_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;my_driver_exit: Unregistering platform driver\n&quot;</span>);<br>    <span class="hljs-comment">// 从内核中注销 platform_driver</span><br>    platform_driver_unregister(&amp;my_platform_driver);<br>&#125;<br><br><span class="hljs-comment">// 注册模块加载和卸载函数</span><br>module_init(my_driver_init);<br>module_exit(my_driver_exit);<br><br><span class="hljs-comment">// 模块许可和信息</span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;Your Name&quot;</span>);<br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;A complete platform device driver example&quot;</span>);<br>MODULE_VERSION(<span class="hljs-string">&quot;1.0&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="平台总线和设备驱动"><a href="#平台总线和设备驱动" class="headerlink" title="平台总线和设备驱动"></a>平台总线和设备驱动</h3><ol><li><p><strong>启动与准备 (第 0 步):</strong></p><ul><li>内核启动，解析设备树。</li><li>它看到一个描述 I2C 控制器的节点，于是创建了一个 <code>platform_device</code>。</li><li>它看到 I2C 控制器节点下还有一个描述温度传感器的子节点，于是为它创建了一个 <code>i2c_client</code> 的描述信息（但此时还未注册，因为 I2C 总线还不存在）。</li></ul></li><li><p><strong>第一层匹配 (平台总线):</strong></p><ul><li>你加载了 <strong>I2C 控制器驱动</strong> (<code>platform_driver</code>)。</li><li><strong>平台总线</strong>发现这个驱动和之前创建的 <code>platform_device</code> 匹配。</li><li>平台总线调用 <strong>I2C 控制器驱动</strong> 的 <code>.probe()</code> 函数。</li></ul></li><li><p><strong>桥梁搭建 (控制器驱动的工作):</strong></p><ul><li>在 <strong>I2C 控制器驱动</strong> 的 <code>.probe()</code> 函数中，驱动初始化了硬件，然后调用 <code>i2c_add_adapter()</code>。</li><li><strong>这个调用是关键！</strong> 它在内核里创建并注册了一条功能完备的 <strong>I2C 总线</strong>。</li></ul></li><li><p><strong>第二层匹配 (I2C 总线):</strong></p><ul><li>新的 I2C 总线被注册后，内核的 I2C 核心会把之前为温度传感器准备的 <code>i2c_client</code> 描述信息，正式注册到这条新的 I2C 总线上。</li><li>现在，你加载了<strong>温度传感器驱动</strong> (<code>i2c_driver</code>)。</li><li><strong>I2C 总线</strong>发现这个驱动和刚刚注册的 <code>i2c_client</code> 匹配。</li><li>I2C 总线调用<strong>温度传感器驱动</strong>的 <code>.probe()</code> 函数。</li></ul></li><li><p><strong>最终通信 (设备驱动的工作):</strong></p><ul><li>在<strong>温度传感器驱动</strong>的 <code>.probe()</code> 或其他函数里，它想读取温度。</li><li>它调用一个标准的、与硬件无关的函数 <code>i2c_master_recv()</code>。</li><li>I2C 核心收到调用，查找该设备挂在哪条 I2C 总线上。</li><li>它找到了由<strong>I2C 控制器驱动</strong>注册的那条总线，然后调用了<strong>该控制器驱动</strong>提供的底层传输函数。</li><li><strong>I2C 控制器驱动</strong>的代码开始执行，通过操作寄存器来命令<strong>物理 I2C 控制器</strong>去和<strong>物理温度传感器</strong>通信，并取回数据。</li></ul></li></ol>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/">linux</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/">kernel</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/driver/">driver</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/driver/platform-bus/">platform_bus</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/platform-bus/">platform_bus</category>
      
      
      <comments>https://goko-son626.github.io/post/Platform-bus.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>三种常见的 linux 设备的驱动介绍及框架</title>
      <link>https://goko-son626.github.io/post/the-Three-Basic-Linux-Driver-Models.html</link>
      <guid>https://goko-son626.github.io/post/the-Three-Basic-Linux-Driver-Models.html</guid>
      <pubDate>Tue, 05 Mar 2024 08:48:55 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;按照读写存储数据方式，我们可以把设备分为以下几种：字符设备、块设备和网络设备。而Linux三大驱动就是指对这些设备的驱动，即字符设备、块设备驱动和网络设备驱动。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>按照读写存储数据方式，我们可以把设备分为以下几种：字符设备、块设备和网络设备。而Linux三大驱动就是指对这些设备的驱动，即字符设备、块设备驱动和网络设备驱动。</strong></em></li></ul><span id="more"></span><h3 id="1-字符设备-Character-Devices"><a href="#1-字符设备-Character-Devices" class="headerlink" title="1. 字符设备 (Character Devices)"></a>1. 字符设备 (Character Devices)</h3><ul><li><strong>字符设备是一种按字节流（character stream）进行访问的设备，不可寻址，没有缓冲。你请求 5 个字节，它就给你 5 个字节（如果设备里有的话）。它不支持随机访问，数据只能顺序读写。</strong></li></ul><ul><li><p><strong>原理</strong></p><ul><li><strong>核心：</strong> <code>file_operations</code> 结构体。里面定义了当用户空间程序对设备文件调用 <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>ioctl()</code> 等系统调用时，内核应该执行的对应驱动函数。</li><li><strong>VFS (虚拟文件系统)：</strong> 当 <code>open(&quot;/dev/mydevice&quot;, ...)</code> 时，VFS 会根据路径找到对应的 inode（索引节点），inode 中包含了设备号（主设备号和次设备号）。</li><li><strong>驱动注册：</strong> 驱动在加载时，会通过 <code>register_chrdev()</code> 或 <code>alloc_chrdev_region()</code> + <code>cdev_add()</code> 来告诉内核能处理主设备号为 X 的设备，操作函数菜单是<code>file_operations</code> 结构体。</li><li><strong>连接：</strong> VFS 通过主设备号找到驱动和 <code>file_operations</code>，然后调用实现的 <code>my_open()</code>, <code>my_read()</code> 等函数，从而将用户空间的操作连接到了驱动代码上。</li></ul></li><li><p><strong>典型例子：</strong> </p><ul><li>串口 (<code>/dev/ttyS*</code>)、控制台 (<code>/dev/console</code>)、鼠标 (<code>/dev/input/mouse0</code>)、键盘 <code>(/dev/input/event*)</code>。</li><li>I2C&#x2F;SPI 设备： 虽然挂在特定总线上，但最终给用户提供的接口往往是字符设备，如一个 I2C 接口的温湿度传感器，可能会表现为 <code>/dev/i2c-1</code> 或通过 <code>sysfs</code> 访问。</li><li>裸设备驱动： 各种自定义的、简单的控制类设备</li></ul></li><li><p><strong>代码示例</strong></p><ul><li><a href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87">CLICK</a></li></ul></li></ul><hr><h3 id="2-块设备-Block-Devices"><a href="#2-块设备-Block-Devices" class="headerlink" title="2. 块设备 (Block Devices)"></a>2. 块设备 (Block Devices)</h3><ul><li>块设备是按“块”（Block）为单位进行数据访问的设备，块是固定大小的（如 512 字节、4KB）。与字符设备最大的不同是： <strong>支持随机寻址</strong>它可以随机访问（直接读写第 N 个块），并且 <strong>有内核I&#x2F;O缓冲区</strong>。</li></ul><ul><li><p><strong>原理</strong></p><ul><li><strong>核心：</strong> <code>block_device_operations</code> 结构体和 <strong>请求队列 (Request Queue)</strong>。</li><li><strong>I&#x2F;O 调度器：</strong> 当用户程序请求读写数据时，请求不会立即发送给硬件。而是被分解成一个个对“块”的操作请求（<code>struct request</code>），放入一个请求队列中。内核的 <strong>I&#x2F;O 调度器</strong> 会对队列里的请求进行合并、排序，以提高磁盘寻道效率（比如把对相邻块的请求放在一起处理）。</li><li><strong>缓冲&#x2F;缓存 (Buffer Cache)：</strong> 内核会把频繁访问的块设备数据缓存在内存中（Page Cache&#x2F;Buffer Cache）。当用户请求读取数据时，如果缓存里有，就直接从内存返回，速度极快，根本不需要访问物理设备。写操作也可能先写入缓存，稍后再“刷”到磁盘上。</li><li><strong>驱动的角色：</strong> 块设备驱动的主要工作不是直接处理 <code>read/write</code>，而是从请求队列中取出已经由 I&#x2F;O 调度器优化好的 <code>request</code>，然后根据 <code>request</code> 里的信息（起始块号、块数量、方向），操作硬件来完成真正的数据传输。</li><li><strong>使用：</strong> 通常不直接用 <code>read/write</code> 对 <code>/dev/sda</code> 这样的裸设备进行操作（虽然也可以）。但更常见的用法是：在块设备上创建文件系统（<code>mkfs.ext4 /dev/sda1</code>），然后 <code>mount</code> 到一个目录上。之后，用户和程序就通过文件系统来访问，享受到了文件系统和块设备层共同带来的高效和便利。</li></ul></li><li><p><strong>典型例子：</strong> 硬盘 (HDD&#x2F;SSD)(<code>/dev/sda</code>)、U盘 (<code>/dev/sdb</code>)、SD卡 (<code>/dev/mmcblk0</code>)、RAM disk（内存模拟的块设备）、Flash 存储 (通过 MTD): NAND&#x2F;NOR Flash 在 MTD 层之上也可以表现为块设备。</p></li><li><p><strong>代码示例</strong></p><ul><li><a href="#%E5%9D%97%E8%AE%BE%E5%A4%87">CLICK</a></li></ul></li></ul><hr><h3 id="3-网络设备-Network-Devices"><a href="#3-网络设备-Network-Devices" class="headerlink" title="3. 网络设备 (Network Devices)"></a>3. 网络设备 (Network Devices)</h3><ul><li>网络设备是用于收发数据包（Packet）的设备。它和其他两类设备有本质区别，<strong>它不对应 <code>/dev</code> 目录下的文件节点</strong>。而是通过单独的网络接口来代表。</li></ul><ul><li><p><strong>原理</strong></p><ul><li><strong>核心：</strong> <code>net_device_ops</code> 结构体和 <strong><code>sk_buff</code> (Socket Buffer)</strong>。<ul><li><strong>接口而非文件：</strong> 网络设备在内核中被抽象成一个接口（Interface），如 <code>eth0</code>, <code>wlan0</code>。用户空间程序通过 <strong>Socket API</strong>（<code>socket()</code>, <code>bind()</code>, <code>sendto()</code>, <code>recvfrom()</code>）等内核协议栈来与内核的 TCP&#x2F;IP 协议栈交互，而不是操作设备文件。</li><li><strong>数据流：</strong><ul><li><strong>发送：</strong> 用户数据通过 Socket API 进入内核协议栈，被层层打包（加上 TCP&#x2F;UDP 头、IP 头等），最终形成一个 <code>sk_buff</code> 结构体。这个 <code>sk_buff</code> 被交给网络设备驱动。驱动的 <code>ndo_start_xmit</code> 函数（定义在 <code>net_device_ops</code> 中）负责将 <code>sk_buff</code> 里的数据包通过物理网卡发送出去。</li><li><strong>接收：</strong> 网卡收到一个数据包，产生硬件中断。驱动的中断处理程序把数据从硬件接收到内存，封装成一个新的 <code>sk_buff</code>，然后把它交给内核网络协议栈。协议栈逐层解包，最后通过 Socket 将数据送达正确的应用程序。</li></ul></li><li><strong>驱动的角色：</strong> 网络设备驱动是硬件和内核协议栈之间的“搬运工”，主要负责：初始化网卡、启动&#x2F;停止数据收发、在 <code>sk_buff</code> 和硬件之间传递数据包。</li></ul></li></ul></li><li><p><strong>典型例子：</strong> 有线网卡 (<code>eth0</code>, <code>enp3s0</code>)、无线网卡 (<code>wlan0</code>)虚拟网络接口、 CAN总线设备、 USB网络适配器。</p></li><li><p><strong>代码示例</strong></p><ul><li><a href="#%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87">CLICK</a></li></ul></li></ul><hr><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th align="left">特性</th><th align="left">字符设备 (Char)</th><th align="left">块设备 (Block)</th><th align="left">网络设备 (Net)</th><th align="left">平台驱动 (Platform)</th></tr></thead><tbody><tr><td align="left"><strong>数据单位</strong></td><td align="left">字节流 (Stream)</td><td align="left">数据块 (Block)</td><td align="left">数据包 (Packet)</td><td align="left">不直接处理数据流</td></tr><tr><td align="left"><strong>访问方式</strong></td><td align="left">顺序访问</td><td align="left">随机访问</td><td align="left">Socket API</td><td align="left">N&#x2F;A</td></tr><tr><td align="left"><strong>I&#x2F;O 缓冲</strong></td><td align="left">无 (或很简单)</td><td align="left">有内核缓冲&#x2F;缓存和I&#x2F;O调度</td><td align="left">有 Socket 缓冲</td><td align="left">N&#x2F;A</td></tr><tr><td align="left"><strong>用户接口</strong></td><td align="left"><code>/dev</code> 文件节点</td><td align="left"><code>/dev</code> 文件节点, 文件系统</td><td align="left">Socket 接口, <code>ifconfig</code></td><td align="left">通常是为其他驱动提供服务</td></tr><tr><td align="left"><strong>核心结构体</strong></td><td align="left"><code>file_operations</code></td><td align="left"><code>block_device_operations</code></td><td align="left"><code>net_device_ops</code></td><td align="left"><code>platform_driver</code></td></tr><tr><td align="left"><strong>核心机制</strong></td><td align="left">VFS 文件操作映射</td><td align="left">请求队列和I&#x2F;O调度</td><td align="left">协议栈和<code>sk_buff</code></td><td align="left">设备与驱动的分离、匹配、探测</td></tr><tr><td align="left"><strong>主要用途</strong></td><td align="left">简单、串行 I&#x2F;O 设备</td><td align="left">存储设备</td><td align="left">网络通信</td><td align="left">SoC 内部集成外设的管理框架</td></tr></tbody></table><h4 id="字符设备代码示例"><a href="#字符设备代码示例" class="headerlink" title="字符设备代码示例"></a>字符设备代码示例</h4><p><a id="字符设备"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span>       <span class="hljs-comment">// 包含 file_operations 结构体</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span>     <span class="hljs-comment">// 包含 cdev 结构体和相关函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span>   <span class="hljs-comment">// 包含 class_create 和 device_create</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span>  <span class="hljs-comment">// 包含 copy_to_user 和 copy_from_user</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span>     <span class="hljs-comment">// 包含 kmalloc 和 kfree</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVICE_NAME <span class="hljs-string">&quot;mymem_char&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLASS_NAME  <span class="hljs-string">&quot;mymem_class&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_BUFFER_SIZE 1024</span><br><br><span class="hljs-comment">// --- 驱动核心数据结构 ---</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major_number;                <span class="hljs-comment">// 主设备号</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *kernel_buffer;             <span class="hljs-comment">// 内核数据缓冲区</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span>* <span class="hljs-title">my_class</span> =</span> <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 设备类</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">my_cdev</span>;</span>             <span class="hljs-comment">// 字符设备结构</span><br><br><span class="hljs-comment">// --- file_operations 函数实现 ---</span><br><br><span class="hljs-comment">// open 函数：当设备文件被打开时调用</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">my_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *file)</span><br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;MyCharDev: Device opened.\n&quot;</span>);<br>    <span class="hljs-comment">// 通常可以在这里为每个打开实例分配私有数据</span><br>    <span class="hljs-comment">// file-&gt;private_data = ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// release 函数：当设备文件被关闭时调用</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">my_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *file)</span><br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;MyCharDev: Device closed.\n&quot;</span>);<br>    <span class="hljs-comment">// 清理 open 时分配的私有数据</span><br>    <span class="hljs-comment">// kfree(file-&gt;private_data);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// read 函数：从设备读取数据</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">my_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *user_buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">loff_t</span> *offset)</span><br>&#123;<br>    <span class="hljs-type">int</span> bytes_to_read;<br><br>    <span class="hljs-comment">// 检查读取长度是否有效</span><br>    <span class="hljs-keyword">if</span> (*offset &gt;= MAX_BUFFER_SIZE)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// End of file</span><br>    <span class="hljs-keyword">if</span> (*offset + len &gt; MAX_BUFFER_SIZE)<br>        len = MAX_BUFFER_SIZE - *offset;<br><br>    bytes_to_read = len;<br>    <br>    <span class="hljs-comment">// 使用 copy_to_user 将内核数据拷贝到用户空间</span><br>    <span class="hljs-keyword">if</span> (copy_to_user(user_buf, kernel_buffer + *offset, bytes_to_read) != <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;MyCharDev: Failed to copy data to user.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -EFAULT;<br>    &#125;<br><br>    *offset += bytes_to_read; <span class="hljs-comment">// 更新文件偏移</span><br>    printk(KERN_INFO <span class="hljs-string">&quot;MyCharDev: Read %d bytes.\n&quot;</span>, bytes_to_read);<br>    <span class="hljs-keyword">return</span> bytes_to_read;<br>&#125;<br><br><span class="hljs-comment">// write 函数：向设备写入数据</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">my_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *user_buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">loff_t</span> *offset)</span><br>&#123;<br>    <span class="hljs-type">int</span> bytes_to_write;<br><br>    <span class="hljs-comment">// 检查写入位置是否有效</span><br>    <span class="hljs-keyword">if</span> (*offset &gt;= MAX_BUFFER_SIZE) &#123;<br>        printk(KERN_WARNING <span class="hljs-string">&quot;MyCharDev: No space left on device.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -ENOSPC; <span class="hljs-comment">// No space left on device</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (*offset + len &gt; MAX_BUFFER_SIZE)<br>        len = MAX_BUFFER_SIZE - *offset;<br><br>    bytes_to_write = len;<br><br>    <span class="hljs-comment">// 使用 copy_from_user 将用户数据拷贝到内核空间</span><br>    <span class="hljs-keyword">if</span> (copy_from_user(kernel_buffer + *offset, user_buf, bytes_to_write) != <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;MyCharDev: Failed to copy data from user.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -EFAULT;<br>    &#125;<br><br>    *offset += bytes_to_write; <span class="hljs-comment">// 更新文件偏移</span><br>    printk(KERN_INFO <span class="hljs-string">&quot;MyCharDev: Wrote %d bytes.\n&quot;</span>, bytes_to_write);<br>    <span class="hljs-keyword">return</span> bytes_to_write;<br>&#125;<br><br><span class="hljs-comment">// --- file_operations 结构体定义 ---</span><br><span class="hljs-comment">// 将实现的函数与标准文件操作关联起来</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">fops</span> =</span> &#123;<br>    .owner   = THIS_MODULE,<br>    .open    = my_open,<br>    .release = my_release,<br>    .read    = my_read,<br>    .write   = my_write,<br>&#125;;<br><br><span class="hljs-comment">// --- 模块初始化函数 ---</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">memchar_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">dev_t</span> dev_num;<br><br>    <span class="hljs-comment">// 1. 分配内核缓冲区</span><br>    kernel_buffer = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);<br>    <span class="hljs-keyword">if</span> (!kernel_buffer) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;MyCharDev: Failed to allocate kernel buffer.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 动态分配主设备号</span><br>    <span class="hljs-keyword">if</span> (alloc_chrdev_region(&amp;dev_num, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, DEVICE_NAME) &lt; <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;MyCharDev: Failed to allocate major number.\n&quot;</span>);<br>        kfree(kernel_buffer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    major_number = MAJOR(dev_num);<br>    printk(KERN_INFO <span class="hljs-string">&quot;MyCharDev: Major number allocated: %d\n&quot;</span>, major_number);<br><br>    <span class="hljs-comment">// 3. 初始化 cdev 结构体，并与 file_operations 关联</span><br>    cdev_init(&amp;my_cdev, &amp;fops);<br>    my_cdev.owner = THIS_MODULE;<br><br>    <span class="hljs-comment">// 4. 将 cdev 添加到内核</span><br>    <span class="hljs-keyword">if</span> (cdev_add(&amp;my_cdev, dev_num, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;MyCharDev: Failed to add cdev to the kernel.\n&quot;</span>);<br>        unregister_chrdev_region(dev_num, <span class="hljs-number">1</span>);<br>        kfree(kernel_buffer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 创建设备类</span><br>    my_class = class_create(THIS_MODULE, CLASS_NAME);<br>    <span class="hljs-keyword">if</span> (IS_ERR(my_class)) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;MyCharDev: Failed to create device class.\n&quot;</span>);<br>        cdev_del(&amp;my_cdev);<br>        unregister_chrdev_region(dev_num, <span class="hljs-number">1</span>);<br>        kfree(kernel_buffer);<br>        <span class="hljs-keyword">return</span> PTR_ERR(my_class);<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 创建设备文件 (/dev/mymem_char)</span><br>    <span class="hljs-keyword">if</span> (device_create(my_class, <span class="hljs-literal">NULL</span>, dev_num, <span class="hljs-literal">NULL</span>, DEVICE_NAME) == <span class="hljs-literal">NULL</span>) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;MyCharDev: Failed to create device file.\n&quot;</span>);<br>        class_destroy(my_class);<br>        cdev_del(&amp;my_cdev);<br>        unregister_chrdev_region(dev_num, <span class="hljs-number">1</span>);<br>        kfree(kernel_buffer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;MyCharDev: Driver loaded successfully.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// --- 模块卸载函数 ---</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">memchar_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">dev_t</span> dev_num = MKDEV(major_number, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 逆序清理资源</span><br>    device_destroy(my_class, dev_num);      <span class="hljs-comment">// 销毁设备文件</span><br>    class_destroy(my_class);                <span class="hljs-comment">// 销毁设备类</span><br>    cdev_del(&amp;my_cdev);                     <span class="hljs-comment">// 从内核移除 cdev</span><br>    unregister_chrdev_region(dev_num, <span class="hljs-number">1</span>);   <span class="hljs-comment">// 释放设备号</span><br>    kfree(kernel_buffer);                   <span class="hljs-comment">// 释放内核缓冲区</span><br><br>    printk(KERN_INFO <span class="hljs-string">&quot;MyCharDev: Driver unloaded.\n&quot;</span>);<br>&#125;<br><br>module_init(memchar_init);<br>module_exit(memchar_exit);<br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;Your Name&quot;</span>);<br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;A simple character device driver for memory simulation.&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="块设备代码示例"><a href="#块设备代码示例" class="headerlink" title="块设备代码示例"></a>块设备代码示例</h4><p><a id="块设备"></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;linux/module.h&gt;</span><br><span class="hljs-comment">#include &lt;linux/kernel.h&gt;</span><br><span class="hljs-comment">#include &lt;linux/init.h&gt;</span><br><span class="hljs-comment">#include &lt;linux/genhd.h&gt;        // 包含 gendisk</span><br><span class="hljs-comment">#include &lt;linux/fs.h&gt;           // 包含 block_device_operations</span><br><span class="hljs-comment">#include &lt;linux/blkdev.h&gt;       // 包含请求队列相关函数</span><br><span class="hljs-comment">#include &lt;linux/vmalloc.h&gt;      // 使用 vmalloc 分配大块内存</span><br><br><span class="hljs-comment">#define DEVICE_NAME &quot;myram_block&quot;</span><br><span class="hljs-comment">#define SECTOR_SIZE 512</span><br><span class="hljs-comment">#define DEVICE_SECTORS 20480 // 10MB (20480 * 512 bytes)</span><br><br>// --- 驱动核心数据结构 ---<br>static int major_number;                // 主设备号<br>static u8 *device_data;                 // 模拟磁盘的内存区域<br>static struct gendisk *my_disk;         // gendisk 结构，代表一个独立的磁盘<br>static struct request_queue *my_queue;  // 请求队列<br>static spinlock_t lock;                 // 用于保护请求队列的自旋锁<br><br>// --- 请求处理函数 ---<br>// 这是块设备驱动的核心，处理来自I/O调度器的请求<br>static void my_request_fn(struct request_queue *q)<br>&#123;<br>    struct request *req;<br><br>    // 循环处理队列中的所有请求<br>    <span class="hljs-keyword">while</span> ((req = blk_fetch_request(q)) != NULL) &#123;<br>        // 检查请求是否合法（这里简化处理，只检查读写请求）<br>        <span class="hljs-keyword">if</span> (req == NULL || (rq_data_dir(req) != READ &amp;&amp; rq_data_dir(req) != WRITE)) &#123;<br>            printk(KERN_NOTICE <span class="hljs-string">&quot;MyRamBlock: Skipping non-RW request\n&quot;</span>);<br>            __blk_end_request_all(req, -EIO);<br>            <span class="hljs-built_in">continue</span>;<br>        &#125;<br><br>        // 计算物理地址和大小<br>        // blk_rq_pos(req) 返回起始扇区号<br>        // blk_rq_cur_bytes(req) 返回请求的总字节数<br>        unsigned long offset = blk_rq_pos(req) * SECTOR_SIZE;<br>        unsigned long num_bytes = blk_rq_cur_bytes(req);<br><br>        // 模拟数据传输<br>        <span class="hljs-keyword">if</span> (rq_data_dir(req) == WRITE) &#123;<br>            // bio_for_each_segment 遍历请求中的所有段 (segment)<br>            // 将请求缓冲区中的数据拷贝到我们的模拟磁盘内存<br>            memcpy(device_data + offset, bio_data(req-&gt;bio), num_bytes);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // 将模拟磁盘内存中的数据拷贝到请求缓冲区<br>            memcpy(bio_data(req-&gt;bio), device_data + offset, num_bytes);<br>        &#125;<br><br>        // 标记请求完成<br>        __blk_end_request_all(req, 0); // 0 表示成功<br>    &#125;<br>&#125;<br><br>// --- block_device_operations ---<br>// 对于简单的驱动，这个结构体可以为空<br>static struct block_device_operations my_bops = &#123;<br>    .owner = THIS_MODULE,<br>&#125;;<br><br>// --- 模块初始化函数 ---<br>static int __init ramblock_init(void)<br>&#123;<br>    // 1. 分配模拟磁盘的内存<br>    device_data = vmalloc(DEVICE_SECTORS * SECTOR_SIZE);<br>    <span class="hljs-keyword">if</span> (!device_data) &#123;<br>        <span class="hljs-built_in">return</span> -ENOMEM;<br>    &#125;<br><br>    // 2. 注册块设备，获取主设备号<br>    major_number = register_blkdev(0, DEVICE_NAME);<br>    <span class="hljs-keyword">if</span> (major_number &lt; 0) &#123;<br>        vfree(device_data);<br>        <span class="hljs-built_in">return</span> major_number;<br>    &#125;<br><br>    // 3. 初始化自旋锁和请求队列<br>    spin_lock_init(&amp;lock);<br>    my_queue = blk_init_queue(my_request_fn, &amp;lock);<br>    <span class="hljs-keyword">if</span> (!my_queue) &#123;<br>        unregister_blkdev(major_number, DEVICE_NAME);<br>        vfree(device_data);<br>        <span class="hljs-built_in">return</span> -ENOMEM;<br>    &#125;<br><br>    // 4. 分配和初始化 gendisk 结构<br>    my_disk = alloc_disk(1); // 1个次设备 (分区)<br>    <span class="hljs-keyword">if</span> (!my_disk) &#123;<br>        blk_cleanup_queue(my_queue);<br>        unregister_blkdev(major_number, DEVICE_NAME);<br>        vfree(device_data);<br>        <span class="hljs-built_in">return</span> -ENOMEM;<br>    &#125;<br><br>    // 5. 填充 gendisk 信息<br>    my_disk-&gt;major = major_number;<br>    my_disk-&gt;first_minor = 0;<br>    my_disk-&gt;fops = &amp;my_bops;<br>    my_disk-&gt;queue = my_queue;<br>    snprintf(my_disk-&gt;disk_name, 32, DEVICE_NAME);<br>    set_capacity(my_disk, DEVICE_SECTORS); // 设置磁盘容量（以扇区为单位）<br><br>    // 6. 将 gendisk 添加到系统，使其可见<br>    add_disk(my_disk);<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;MyRamBlock: Driver loaded. Major: %d\n&quot;</span>, major_number);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br><br>// --- 模块卸载函数 ---<br>static void __exit ramblock_exit(void)<br>&#123;<br>    del_gendisk(my_disk);           // 从系统移除 gendisk<br>    put_disk(my_disk);              // 释放 gendisk 引用<br>    blk_cleanup_queue(my_queue);    // 清理请求队列<br>    unregister_blkdev(major_number, DEVICE_NAME); // 注销块设备<br>    vfree(device_data);             // 释放内存<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;MyRamBlock: Driver unloaded.\n&quot;</span>);<br>&#125;<br><br>module_init(ramblock_init);<br>module_exit(ramblock_exit);<br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;Your Name&quot;</span>);<br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;A simple RAM-based block device driver.&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="网络设备代码示例"><a href="#网络设备代码示例" class="headerlink" title="网络设备代码示例"></a>网络设备代码示例</h4><p><a id="网络设备"></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;linux/module.h&gt;</span><br><span class="hljs-comment">#include &lt;linux/kernel.h&gt;</span><br><span class="hljs-comment">#include &lt;linux/init.h&gt;</span><br><span class="hljs-comment">#include &lt;linux/netdevice.h&gt;    // 包含 net_device 和相关函数</span><br><span class="hljs-comment">#include &lt;linux/etherdevice.h&gt;  // 包含 alloc_etherdev</span><br><br><span class="hljs-comment">#define DEVICE_NAME &quot;mynet&quot;</span><br><br>// --- 驱动核心数据结构 ---<br>// 我们将自定义的统计信息和设备指针放在一个结构体中<br>struct mynet_priv &#123;<br>    struct net_device_stats stats;<br>    struct net_device *dev;<br>&#125;;<br><br>static struct net_device *my_net_dev;<br><br>// --- net_device_ops 函数实现 ---<br><br>// open 函数：当接口被 <span class="hljs-string">&quot;ifconfig up&quot;</span> 启动时调用<br>static int mynet_open(struct net_device *dev)<br>&#123;<br>    // 启动传输队列<br>    netif_start_queue(dev);<br>    printk(KERN_INFO <span class="hljs-string">&quot;%s: Device opened.\n&quot;</span>, dev-&gt;name);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br><br>// stop 函数：当接口被 <span class="hljs-string">&quot;ifconfig down&quot;</span> 关闭时调用<br>static int mynet_stop(struct net_device *dev)<br>&#123;<br>    // 停止传输队列<br>    netif_stop_queue(dev);<br>    printk(KERN_INFO <span class="hljs-string">&quot;%s: Device stopped.\n&quot;</span>, dev-&gt;name);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br><br>// 发包函数：这是网络驱动的核心，负责发送数据包<br>static netdev_tx_t mynet_start_xmit(struct sk_buff *skb, struct net_device *dev)<br>&#123;<br>    struct mynet_priv *priv = netdev_priv(dev);<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;%s: Transmitting packet (len: %u)\n&quot;</span>, dev-&gt;name, skb-&gt;len);<br>    <br>    // 更新统计信息<br>    priv-&gt;stats.tx_packets++;<br>    priv-&gt;stats.tx_bytes += skb-&gt;len;<br><br>    // --- 模拟环回 ---<br>    // 正常驱动会在这里把 skb 的数据通过 DMA 发送到硬件<br>    // 我们直接将 skb 重新送回收包路径<br>    skb-&gt;protocol = eth_type_trans(skb, dev); // 设置协议类型<br>    skb-&gt;dev = dev;<br>    netif_rx(skb); // 将 skb 传递给内核协议栈的接收部分<br><br>    // 告诉内核数据包已发送，可以释放 skb<br>    // dev_kfree_skb(skb); // 真实驱动中发送完会释放 skb<br>    // 但因为我们环回了，协议栈会负责释放它<br><br>    <span class="hljs-built_in">return</span> NETDEV_TX_OK; // 返回 OK 表示发送成功<br>&#125;<br><br>// 获取统计信息函数<br>static struct net_device_stats *mynet_get_stats(struct net_device *dev)<br>&#123;<br>    struct mynet_priv *priv = netdev_priv(dev);<br>    <span class="hljs-built_in">return</span> &amp;priv-&gt;stats;<br>&#125;<br><br>// --- net_device_ops 结构体定义 ---<br>static const struct net_device_ops mynet_ops = &#123;<br>    .ndo_open       = mynet_open,<br>    .ndo_stop       = mynet_stop,<br>    .ndo_start_xmit = mynet_start_xmit,<br>    .ndo_get_stats  = mynet_get_stats,<br>&#125;;<br><br>// --- setup 函数，用于初始化设备 ---<br>void mynet_setup(struct net_device *dev)<br>&#123;<br>    // 设置为以太网设备<br>    ether_setup(dev);<br><br>    // 关联我们的操作函数<br>    dev-&gt;netdev_ops = &amp;mynet_ops;<br><br>    // 分配一个随机的 MAC 地址<br>    eth_hw_addr_random(dev);<br><br>    // 其他设备特性标志<br>    dev-&gt;flags |= IFF_NOARP;<br>&#125;<br><br>// --- 模块初始化函数 ---<br>static int __init netloop_init(void)<br>&#123;<br>    struct mynet_priv *priv;<br><br>    // 1. 分配 net_device 结构体，并为私有数据分配空间<br>    my_net_dev = alloc_netdev(sizeof(struct mynet_priv), DEVICE_NAME, NET_NAME_UNKNOWN, mynet_setup);<br>    <span class="hljs-keyword">if</span> (!my_net_dev) &#123;<br>        <span class="hljs-built_in">return</span> -ENOMEM;<br>    &#125;<br><br>    // 获取私有数据指针<br>    priv = netdev_priv(my_net_dev);<br>    priv-&gt;dev = my_net_dev;<br><br>    // 2. 注册网络设备到内核<br>    <span class="hljs-keyword">if</span> (register_netdev(my_net_dev)) &#123;<br>        printk(KERN_ERR <span class="hljs-string">&quot;Failed to register net device\n&quot;</span>);<br>        free_netdev(my_net_dev);<br>        <span class="hljs-built_in">return</span> -1;<br>    &#125;<br><br>    printk(KERN_INFO <span class="hljs-string">&quot;%s: Driver loaded.\n&quot;</span>, my_net_dev-&gt;name);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br><br>// --- 模块卸载函数 ---<br>static void __exit netloop_exit(void)<br>&#123;<br>    printk(KERN_INFO <span class="hljs-string">&quot;%s: Unloading driver.\n&quot;</span>, my_net_dev-&gt;name);<br>    unregister_netdev(my_net_dev); // 从内核注销<br>    free_netdev(my_net_dev);       // 释放 net_device<br>&#125;<br><br>module_init(netloop_init);<br>module_exit(netloop_exit);<br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;Your Name&quot;</span>);<br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;A simple loopback network device driver.&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/">linux</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/">kernel</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/driver/">driver</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/linux/kernel/driver/three-driver-struct/">three_driver_struct</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/driver-struct/">driver_struct</category>
      
      
      <comments>https://goko-son626.github.io/post/the-Three-Basic-Linux-Driver-Models.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>riscv 工具链的了解和使用</title>
      <link>https://goko-son626.github.io/post/riscv-toolchains.html</link>
      <guid>https://goko-son626.github.io/post/riscv-toolchains.html</guid>
      <pubDate>Thu, 18 Jan 2024 08:30:56 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;在 RISC-V 开发中, 交叉编译工具链允许我们在一个平台（如 x86 主机）上，为另一个平台（如RISC-V 开发板）生成可执行代码。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>在 RISC-V 开发中, 交叉编译工具链允许我们在一个平台（如 x86 主机）上，为另一个平台（如RISC-V 开发板）生成可执行代码。</strong></em></li></ul><span id="more"></span><h3 id="1-核心概念：工具链的“三元组”-Triplet"><a href="#1-核心概念：工具链的“三元组”-Triplet" class="headerlink" title="1. 核心概念：工具链的“三元组” (Triplet)"></a>1. 核心概念：工具链的“三元组” (Triplet)</h3><p>你经常会看到像 <code>riscv64-unknown-linux-gnu-</code> 这样的名称，这就是工具链的“三元组”，其标准格式为：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;<span class="hljs-built_in">arch</span>&gt;-&lt;vendor&gt;-&lt;os&gt;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;arch&gt;</code> (架构)：指定目标 CPU 架构，例如 <code>riscv64</code> 或 <code>riscv32</code>。</li><li><code>&lt;vendor&gt;</code> (供应商)：通常是 <code>unknown</code> 或公司名。</li><li><code>&lt;os&gt;</code> (操作系统&#x2F;环境)：这是<strong>最关键</strong>的部分，它决定了工具链的目标环境和使用的 C 标准库 (libc)。最常见的两个是：<ul><li><code>elf</code>: 面向<strong>裸机 (Bare-metal)</strong> 或<strong>嵌入式实时操作系统 (RTOS)</strong>。</li><li><code>linux-gnu</code>: 面向<strong>完整的 GNU&#x2F;Linux 操作系统</strong>。</li></ul></li></ul><h3 id="2-两大主流工具链详解"><a href="#2-两大主流工具链详解" class="headerlink" title="2. 两大主流工具链详解"></a>2. 两大主流工具链详解</h3><h4 id="1-riscv64-unknown-elf"><a href="#1-riscv64-unknown-elf" class="headerlink" title="1. riscv64-unknown-elf"></a>1. <code>riscv64-unknown-elf</code></h4><p>用于<strong>裸机和嵌入式</strong>开发的标准工具链。</p><ul><li><strong>目标系统</strong>: 没有任何操作系统的环境（裸机），或者使用了轻量级实时操作系统（如 FreeRTOS, RT-Thread）的环境。</li><li><strong>C 标准库 (Libc)</strong>: 使用 <strong>Newlib</strong>。<ul><li><strong>Newlib</strong> 是一个轻量级的 C 库，专为嵌入式系统设计。它只提供最基础的 C 语言函数（如 <code>strcpy</code>, <code>printf</code>），并且不依赖任何操作系统的系统调用（Syscall）。如果需要文件操作或内存管理，需要实现底层的“桩函数”(stubs)。</li></ul></li><li><strong>应用场景</strong>:<ul><li>编写 Bootloader（如 U-Boot）。</li><li>开发 RISC-V 的“特权二进制接口”固件（如 OpenSBI）。</li><li>为微控制器 (MCU) 编写固件。</li><li>开发简单的操作系统内核。</li></ul></li></ul><h4 id="2-riscv64-linux-gnu"><a href="#2-riscv64-linux-gnu" class="headerlink" title="2. riscv64-linux-gnu"></a>2. <code>riscv64-linux-gnu</code></h4><p>用于<strong>在 RISC-V 平台上开发 Linux 应用</strong>的工具链。</p><ul><li><strong>目标系统</strong>: 运行完整 Linux 内核的系统。</li><li><strong>C 标准库 (Libc)</strong>: 使用 <strong>glibc</strong> (GNU C Library)。<ul><li><strong>glibc</strong> 是功能完备的标准 C 库，提供了丰富的 POSIX API 支持（如 <code>fork</code>, <code>pthread</code>, 文件系统操作等）。它深度依赖 Linux 内核提供的系统调用来完成工作。</li></ul></li><li><strong>典型应用场景</strong>:<ul><li>编译一个标准的 C&#x2F;C++ 应用程序（如 Nginx, Redis），让它运行在 RISC-V 架构的 Linux 发行版上（如 Ubuntu, Debian for RISC-V）。</li><li>开发 Linux 用户态驱动或服务程序。</li></ul></li></ul><blockquote><p><strong>Tip</strong>: <code>riscv64-unknown-linux-gnu-</code> 和 <code>riscv64-linux-gnu-</code> 在功能上是等价的，可以互换使用。<code>unknown</code> 字段在这里没有实际影响。</p></blockquote><hr><h3 id="3-如何获取和安装工具链"><a href="#3-如何获取和安装工具链" class="headerlink" title="3. 如何获取和安装工具链"></a>3. 如何获取和安装工具链</h3><h4 id="方式一：使用包管理器-简单快捷"><a href="#方式一：使用包管理器-简单快捷" class="headerlink" title="方式一：使用包管理器 (简单快捷)"></a>方式一：使用包管理器 (简单快捷)</h4><p>对于 <code>linux-gnu</code> 工具链，这是最简单的方法。以 Ubuntu&#x2F;Debian 为例：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 C 和 C++ 交叉编译器</span><br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install gcc-riscv64-linux-gnu g++-riscv64-linux-gnu<br></code></pre></td></tr></table></figure><ul><li><strong>优点</strong>: 安装简单</li><li><strong>缺点</strong>: 版本可能不是最新的</li></ul><h4 id="方式二：从源码编译-推荐，灵活且最新"><a href="#方式二：从源码编译-推荐，灵活且最新" class="headerlink" title="方式二：从源码编译 (推荐，灵活且最新)"></a>方式二：从源码编译 (推荐，灵活且最新)</h4><p>获取<strong>最新版本</strong>工具链（包括 <code>elf</code> 和 <code>linux-gnu</code>）的<strong>最佳方式</strong>。</p><ol start="0"><li><p><strong>安装相关依赖</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install libncurses-dev libncursesw5-dev pkg-config autoconf automake bison flex gawk gcc g++ libtool make patch python3-dev texinfo wget<br><span class="hljs-built_in">sudo</span> apt-get install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev make bison flex texinfo gawk libncurses5-dev libexpat1-dev libgmp-dev libmpfr-dev libmpc-dev libgmp-dev libmpfr-dev libmpc-dev<br></code></pre></td></tr></table></figure></li><li><p><strong>克隆官方仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#`--recursive` 参数至关重要，它会同时下载 `gcc`, `binutils` 等所有子模块。</span><br>git <span class="hljs-built_in">clone</span> --recursive https://github.com/riscv-collab/riscv-gnu-toolchain<br><span class="hljs-built_in">cd</span> riscv-gnu-toolchain<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>* 检查当前子模块情况。<br>git submodule status<br><br>* 拉取子模块(init: 子模块未初始化时初始化，recursive: 嵌套子模块也一起拉取)<br>* 主仓库换分支时同步子模块<br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure></li><li><p><strong>配置与编译</strong><br>需要指定安装路径 (<code>--prefix</code>) 和目标架构 (<code>--with-arch</code>, <code>--with-abi</code>)。</p><ul><li><strong>编译 <code>linux-gnu</code> 工具链 (用于Linux):</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建安装目录</span><br><span class="hljs-built_in">mkdir</span> -p /opt/riscv-linux<br><span class="hljs-comment"># 配置: 目录，目标是为linux构建工具链</span><br>./configure --prefix=/opt/riscv-linux --enable-linux<br><span class="hljs-comment"># `make linux` 会自动处理多阶段编译的复杂流程（构建临时gcc-&gt;构建glibc-&gt;构建最终gcc）</span><br><span class="hljs-keyword">time</span> make -j$(<span class="hljs-built_in">nproc</span>) linux<br><span class="hljs-comment"># 安装</span><br><span class="hljs-built_in">sudo</span> make install <br></code></pre></td></tr></table></figure><ul><li><strong>编译 <code>elf</code> 工具链 (用于裸机):riscv64-unknown-elf-</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个安装目录</span><br><span class="hljs-built_in">mkdir</span> -p /opt/riscv-elf<br><span class="hljs-comment"># 配置: 其中 `rv64gc` 指支持 64 位基础整数指令集（I）、乘除法（M）、原子（A）、浮点（F、D）、压缩（C）等扩展；</span><br><span class="hljs-comment">#       `lp64d` 表示 long 和 pointer 为 64 位，使用 double 精度浮点。</span><br>./configure --prefix=/opt/riscv-elf --with-arch=rv64gc --with-abi=lp64d<br><span class="hljs-comment"># 编译 (-j`nproc` 使用所有CPU核心加速)</span><br><span class="hljs-keyword">time</span> make -j$(<span class="hljs-built_in">nproc</span>)<br><span class="hljs-comment"># 安装</span><br><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure></li><li><p><strong>添加到环境变量</strong><br>为了方便使用，将工具链的 <code>bin</code> 目录添加到 <code>PATH</code>。编辑 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加这行到文件末尾 (根据编译的类型选择)</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/opt/riscv-elf/bin:<span class="hljs-variable">$PATH</span>&quot;</span>  <span class="hljs-comment"># For elf toolchain</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/opt/riscv-linux/bin:<span class="hljs-variable">$PATH</span>&quot;</span> <span class="hljs-comment"># For linux toolchain</span><br><br><span class="hljs-comment"># 使配置生效</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="4-简单使用"><a href="#4-简单使用" class="headerlink" title="4. 简单使用"></a>4. 简单使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hello.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, RISC-V World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用-elf-工具链编译"><a href="#使用-elf-工具链编译" class="headerlink" title="使用 elf 工具链编译"></a>使用 <code>elf</code> 工具链编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译</span><br>riscv64-unknown-elf-gcc -o hello.elf hello.c<br><br><span class="hljs-comment"># 查看文件类型</span><br>file hello.elf<br><span class="hljs-comment"># 输出会类似:</span><br><span class="hljs-comment"># hello.elf: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped</span><br></code></pre></td></tr></table></figure><p>这个 <code>hello.elf</code> 是一个<strong><em>静态链接</em>的裸机程序</strong>。它不能直接在 <strong>x86 Linux</strong> 主机上运行，也不能在 RISC-V Linux 系统上直接运行，因为它缺少操作系统加载器所需的信息。它需要被烧录到裸机环境或通过模拟器（如 QEMU-system）加载执行。</p><blockquote><p>这个 <code>hello.elf</code> 文件虽然是标准的 ELF 格式，但它与 Linux 可执行文件有本质区别：</p><ul><li><strong>不含 <code>INTERP</code> 段</strong>：它不指定动态链接器，因为它不依赖任何动态库。</li><li><strong>静态链接</strong>: 它静态链接了轻量级的 <code>newlib</code> C 库，而非 <code>glibc</code>。</li><li><strong>无系统调用</strong>: 其中的 <code>printf</code> 函数最终依赖开发者实现的底层 I&#x2F;O 桩函数（如通过 UART 发送字符），而不是 Linux 的 <code>write</code> 系统调用。</li><li><strong>不同的程序入口</strong>: 它的启动代码 (<code>_start</code>) 负责初始化 C 运行环境后调用 <code>main</code>，但 <code>main</code> 返回后程序通常会进入死循环，因为它没有“退出”到操作系统的概念。</li></ul></blockquote><h4 id="使用-linux-gnu-工具链编译"><a href="#使用-linux-gnu-工具链编译" class="headerlink" title="使用 linux-gnu 工具链编译"></a>使用 <code>linux-gnu</code> 工具链编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译</span><br>riscv64-linux-gnu-gcc -o hello.linux hello.c<br><br><span class="hljs-comment"># 查看文件类型</span><br>file hello.linux<br><span class="hljs-comment"># 输出会类似:</span><br><span class="hljs-comment"># hello.linux: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, for GNU/Linux 4.15.0, not stripped</span><br></code></pre></td></tr></table></figure><p>这个 <code>hello.linux</code> 是一个<strong><em>动态链接</em>的 Linux 程序</strong>。它需要一个 RISC-V Linux 环境来运行，因为它依赖于该环境中的动态链接器 (<code>ld-linux-riscv64-lp64d.so.1</code>) 和 glibc 库。</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><table><thead><tr><th>特性</th><th><code>riscv64-unknown-elf</code></th><th><code>riscv64-linux-gnu</code></th></tr></thead><tbody><tr><td><strong>目标平台</strong></td><td><strong>裸机 (Bare-metal)</strong>、RTOS</td><td><strong>GNU&#x2F;Linux 系统</strong></td></tr><tr><td><strong>C 库</strong></td><td><code>newlib</code> (轻量级，无 OS 依赖)</td><td><code>glibc</code> (功能完备，依赖 Linux 内核)</td></tr><tr><td><strong>核心用途</strong></td><td>固件、Bootloader、RTOS 应用、简单操作系统内核</td><td>编译可在 RISC-V Linux 上运行的应用程序</td></tr><tr><td><strong>选择场景</strong></td><td>“为一块开发板从零开始写程序。”</td><td>“在启动的 Linux 上面运行软件。”</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/note/">note</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/note/toolchain/">toolchain</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/toolchain/">toolchain</category>
      
      
      <comments>https://goko-son626.github.io/post/riscv-toolchains.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>常见的编译库和编译工具</title>
      <link>https://goko-son626.github.io/post/Compilation-libraries-and-tools.html</link>
      <guid>https://goko-son626.github.io/post/Compilation-libraries-and-tools.html</guid>
      <pubDate>Sun, 04 Jun 2023 12:08:24 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;常见的编译库与编译工具的介绍以及使用场景&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>常见的编译库与编译工具的介绍以及使用场景</strong></em></li></ul><span id="more"></span><p><strong>1. 编译器 (Compiler)</strong></p><ul><li>代码的“翻译官”。将 C&#x2F;C++ 代码翻译成机器能懂的汇编代码或目标文件 (<code>.o</code>)。</li><li><strong>典型代表</strong>：<code>GCC</code>, <code>Clang</code>。</li><li><strong>使用场景</strong>：写任何代码并想让它运行时，第一步就是用编译器进行翻译。</li></ul><p><strong>2. 工具链 (Toolchain)</strong></p><ul><li>一个完整的“工具箱”。编译器是工具链的核心组件之一**。工具链还包含了链接器 (<code>ld</code>)、汇编器 (<code>as</code>) 等，它们协同工作，将代码和库文件打包成最终的可执行文件。</li><li><strong>使用场景</strong>：<ul><li><strong>本地工具链</strong>：编译在本机运行的程序 (e.g., <code>gcc</code>)。</li><li><strong>交叉工具链</strong>：在一种架构（如x86电脑）上，编译给另一种架构（如RISC-V开发板）运行的程序 (e.g., <code>riscv64-linux-gnu-gcc</code>)。</li></ul></li></ul><p><strong>3. libc (C标准库)</strong></p><ul><li>一个<strong>API标准或规范</strong>，不是一个具体的软件。它定义了像 <code>printf</code>, <code>malloc</code> 等基础函数。它是所有C程序的基础依赖。你需要一个具体的<strong>实现</strong>来使用它。</li><li><strong>使用场景</strong>：这是一个抽象概念，你写的每一行C代码，只要调用了标准函数，都在与这个“标准”打交道。</li></ul><p><strong>4. glibc (GNU C Library)</strong></p><ul><li><code>libc</code> 的一种强大、功能全面的实现**。它是为 <strong>Linux 操作系统</strong>设计的 <code>libc</code>。它不仅包含标准C函数，还包含大量与Linux内核交互的接口（如进程、网络功能）。</li><li><strong>使用场景</strong>：当你需要开发一个运行在<strong>标准Linux系统</strong>（如Ubuntu&#x2F;Debian&#x2F;CentOS）上的应用程序时，你的程序会链接 <code>glibc</code>。对应的工具链通常叫 <code>...-linux-gnu-gcc</code>。</li></ul><p><strong>5. newlib</strong></p><ul><li><code>libc</code> 的一种轻量级、精简的实现**。它是为<strong>没有操作系统</strong>的环境设计的。因此，它没有 <code>fork</code> 等需要OS支持的复杂功能。</li><li><strong>使用场景</strong>：开发<strong>裸机 (Bare-metal)</strong> 程序、固件 (Firmware)、Bootloader，或者在简单的实时操作系统 (RTOS) 上开发。对应的工具链通常叫 <code>...-elf-gcc</code>。</li></ul><p><strong>6. GNU</strong></p><ul><li>一个庞大的自由软件生态系统。上面讨论的大部分经典工具都来自GNU项目，包括 <code>GCC</code> (编译器), <code>glibc</code> (C库), <code>GDB</code> (调试器), <code>Make</code> (构建工具)。”GNU Toolchain” 指的就是这一整套工具。</li><li><strong>使用场景</strong>：Linux 和嵌入式开发的事实标准。</li></ul><p><strong>8. ELF (Executable and Linkable Format)</strong></p><ul><li>一种<strong>文件格式</strong>，像 <code>.doc</code> 或 <code>.pdf</code> 一样。它是工具链最终生成的<strong>产品</strong>。无论是裸机程序还是Linux程序，最终都可以打包成 ELF 格式。</li><li><strong>使用场景</strong>：<ul><li><strong>裸机ELF</strong>：内部不依赖 <code>glibc</code>，直接在硬件上跑。</li><li><strong>Linux ELF</strong>：内部依赖 <code>glibc</code> 和Linux内核，必须在Linux系统上跑。</li></ul></li><li><strong>关键</strong>：决定它在哪跑的，是它内部链接了什么库，而不是 <code>ELF</code> 这个格式本身。</li></ul><ol start="9"><li><strong>JIT</strong>:(即时编译，Just-In-Time compilation): 动态编译技术，它介于解释执行和提前编译（AOT, Ahead-Of-Time）之间。</li></ol><ul><li>解释执行：代码一行行解释运行（如 Python、早期 JavaScript），启动快，但运行慢。</li><li>提前编译（AOT）：代码在运行前全部编译成目标机器码（如 C&#x2F;C++），运行快，但灵活性差。</li><li>JIT：在运行时，把中间表示（IR, bytecode）翻译成机器码，并缓存起来，下次直接运行机器码。既能接近原生性能，又保留了灵活性。</li><li>JIT 的本质过程：程序一开始以 字节码（或中间表示）形式运行。运行过程中，JIT 编译器发现“这段代码执行得<strong>很频繁</strong>”（<strong>热点代码</strong>），于是触发编译。把字节码即时翻译成当前 CPU 架构的机器码（x86、ARM、RISC-V 等）。后续直接执行机器码（免去解释器逐条解释的开销）。</li></ul><ol start="10"><li><strong>Clang&#x2F;LLVM</strong>:</li></ol><ul><li><p>Clang：C&#x2F;C++ 前端（把 <code>C/C++/Objective-C</code> 源转成通用的标准化的中间语言<code>LLVM IR</code>）。</p><ul><li>词法分析：把代码拆成一个个单词（token），比如 int, main, (, ), {, }。</li><li>语法分析：检查这些单词组合起来是否符合 C&#x2F;C++ 的语法规则。如果写了 int main{) 这种错误，Clang 就在这一步报错。</li><li>生成中间表示 (IR)：如果语法正确，Clang 会把代码转换成一种通用的、与具体计算机架构无关的格式，这就是 LLVM Intermediate Representation (LLVM IR)。</li></ul></li><li><p>LLVM：编译器后台&#x2F;工具链，接收Clang生成的LLVM IR, 进行一系列加工，生成可执行的机器码。</p><ul><li>优化 (Optimization)：LLVM 会对 IR 进行大量的优化。比如删除无用的代码、合并重复的计算、展开循环等等，让最终的程序跑得更快、体积更小。这是 LLVM 的核心优势之一。</li><li>代码生成 (Code Generation)：这是最关键的一步。LLVM 会根据你指定的 “目标平台 (Target)”，将优化后的 IR 翻译成该平台专属的机器指令。</li></ul></li><li><p>可移植性：Clang&#x2F;LLVM 支持很多后端&#x2F;目标（x86&#x2F;arm&#x2F;bpf 等）。当你用 -target bpf 时，Clang 输出的是 eBPF 字节码（虚拟指令），不是 x86 或 arm 机器码。这个字节码理论上可以在任何支持 eBPF 的内核上运行（但内核版本&#x2F;ABI 细节会影响，CO-RE&#x2F;BTF 出现就是为了解决这类兼容性问题）。最终在内核里，JIT 会把字节码翻译成当前 CPU 的本地机器码。</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/note/">note</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/note/compiler/">compiler</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/compiler/">compiler</category>
      
      
      <comments>https://goko-son626.github.io/post/Compilation-libraries-and-tools.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 hexo 搭建博客</title>
      <link>https://goko-son626.github.io/post/hexo-blog.html</link>
      <guid>https://goko-son626.github.io/post/hexo-blog.html</guid>
      <pubDate>Sun, 28 May 2023 05:25:09 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;使用hexo和GitHub Pagtes部署一个自己的博客&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>使用hexo和GitHub Pagtes部署一个自己的博客</strong></em></li></ul><span id="more"></span><h3 id="1-安装并初始化Hexo"><a href="#1-安装并初始化Hexo" class="headerlink" title="1. 安装并初始化Hexo"></a>1. 安装并初始化Hexo</h3><ul><li><ol><li>安装 Hexo CLI</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>初始化博客项目目录</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mkdir my-blog &amp;&amp; cd my-blog<br>hexo init<br>npm install<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>本地预览</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo server<br></code></pre></td></tr></table></figure><ul><li>启动本地服务：在浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看效果</li></ul><h3 id="2-配置-GitHub-Pages-部署"><a href="#2-配置-GitHub-Pages-部署" class="headerlink" title="2.  配置 GitHub Pages 部署"></a>2.  配置 GitHub Pages 部署</h3><ul><li><ol><li>创建GitHub仓库</li></ol><ul><li>创建一个仓库，名字叫 你的GitHub用户名.github.io</li><li>比如你是 goko，就叫 goko.github.io</li></ul></li><li><ol start="2"><li>安装部署插件</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>修改 _config.yml（根目录下）添加部署配置：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">deploy:<br>  type: git<br>  # repo建议使用SSH, SSH免密<br>  repo: https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git<br>  branch: main  # 或者 master，看你的默认分支<br></code></pre></td></tr></table></figure><ul><li><ol start="4"><li>生成并部署博客</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><h3 id="3-域名-com-绑定"><a href="#3-域名-com-绑定" class="headerlink" title="3. 域名(.com)绑定"></a>3. 域名(<xxxx>.com)绑定</xxxx></h3><ul><li><ol><li>添加域名(在my-blog下)</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">echo &quot;&lt;xxxx&gt;.com&quot; &gt; source/CNAME<br># 或者可以：echo &quot;www.&lt;xxxx&gt;.com&quot; &gt; source/CNAME<br># 只能添加一个，而且两个需要添加不同的域名解析（如下）<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>重新部署</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>设置 DNS 解析指向 GitHub Pages</li></ol></li></ul><p><strong>A. 使用裸域名（apex 域名）goku72.com</strong></p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>@</td><td>185.199.108.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.109.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.110.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.111.153</td><td>GitHub Pages IP</td></tr></tbody></table><p>example aliyun:</p><ol><li>选择业务需求: 将网站域名解析到服务器IPv4地址</li><li>选择网站域名(主机记录): <xxxx>.com（对应设置“@”主机记录）</xxxx></li><li>填写 IP（记录值）：</li></ol><ul><li>在输入框里粘贴以下四行（每一行一个 IP）：</li><li><pre><code>  &gt; 185.199.109.153  &gt; 185.199.108.153  &gt; 185.199.110.153  &gt; 185.199.111.153</code></pre></li></ul><hr><p><strong>B. 使用 <a href="http://www.goku72.com/">www.goku72.com</a> 作为主域名</strong></p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th><th>说明</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>&lt;github用户名&gt;.github.io.</td><td>指向你的 GitHub 用户页仓库</td></tr></tbody></table><p>example aliyun:</p><ol><li>选择业务需求: 将网站域名解析到另外的目标域名</li><li>选择网站域名(主机记录): www.<xxxx>.com（对应设置“www”主机记录）</xxxx></li><li>填写 IP（记录值）：&lt;github用户名&gt;.github.io. (最有有一个符号”.”)</li></ol><h3 id="4-设置主题"><a href="#4-设置主题" class="headerlink" title="4. 设置主题"></a>4. 设置主题</h3><ul><li>cd my-blog&#x2F;themes</li><li>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> butterfly</li><li>修改_config.yml: <ul><li>theme: butterfly</li></ul></li><li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</li></ul><p><strong>更多主题</strong>：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p><strong>注：</strong></p><ul><li>如果AB两个方式都添加了，只需要在 Hexo 项目的 source&#x2F;CNAME 文件中写 www.<xxxx>.com，GitHub Pages 就会自动把 goku72.com 重定向过去，无需额外设置！</xxxx></li><li>后续换域名只需要：阿里云重新解析 + 修改 source&#x2F;CNAME + 重新部署 Hexo，就能完成域名迁移。</li><li>有些主题可能需要下载插件</li></ul>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/note/">note</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/note/hexo/">hexo</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/hexo/">hexo</category>
      
      
      <comments>https://goko-son626.github.io/post/hexo-blog.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>GoKo&#39;s blog</title>
    <link>https://GoKo-Son626.github.io/</link>
    
    <atom:link href="https://goko-son626.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 06 May 2025 00:58:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>xv6-riscv-ch2</title>
      <link>https://goko-son626.github.io/post/xv6-riscv-ch2.html</link>
      <guid>https://goko-son626.github.io/post/xv6-riscv-ch2.html</guid>
      <pubDate>Mon, 05 May 2025 04:27:56 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;This chapter2 explains how the OS is structured internally to manage hardware resources, run processes, and enforce protection.&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>This chapter2 explains how the OS is structured internally to manage hardware resources, run processes, and enforce protection.</strong></em></li></ul><span id="more"></span><h2 id="ch2-Operating-system-organization"><a href="#ch2-Operating-system-organization" class="headerlink" title="ch2: Operating system organization"></a><strong>ch2: Operating system organization</strong></h2><ul><li>A key requirement for an operating system is to support several activities at once.</li><li>an operating system must fulfill three requirements: multiplexing, isolation, and<br>interaction.</li><li>Xv6 runs on a multi-core1 RISC-V microprocessor, and much of its low-level functionality<br>(for example, its process implementation) is specific to RISC-V. RISC-V is a 64-bit CPU, and xv6<br>is written in “LP64” C, which means long (L) and pointers (P) in the C programming language<br>are 64 bits, but an int is 32 bits.</li><li><a href="https://lf-riscv.atlassian.net/wiki/x/kYD2">RISCV Technical Specifications</a></li></ul><h3 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h3><ul><li>The Unix interface is not the only way to abstract<br>resources, but it has proved to be a good one.</li></ul><h3 id="2-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="2.2 User mode, supervisor mode, and system calls"></a>2.2 User mode, supervisor mode, and system calls</h3><ul><li>CPUs provide hardware support for strong isolation. For example, RISC-V has three modes in<br>which the CPU can execute instructions: machine mode, supervisor mode, and user mode. Instruc-<br>tions executing in machine mode have full privilege; a CPU starts in machine mode. Machine mode<br>is mostly intended for setting up the computer during boot. Xv6 executes a few lines in machine<br>mode and then changes to supervisor mode.</li><li>In supervisor mode the CPU is allowed to execute privileged instructions: for example, en-<br>abling and disabling interrupts, reading and writing the register that holds the address of a page<br>table, etc.</li><li>An application can execute only user-mode instructions (e.g., adding<br>numbers, etc.) and is said to be running in user space, while the software in supervisor mode can<br>also execute privileged instructions and is said to be running in kernel space. The software running<br>in kernel space (or in supervisor mode) is called the kernel.</li><li>CPUs provide a<br>special instruction that switches the CPU from user mode to supervisor mode and enters the kernel<br>at an entry point specified by the kernel. (RISC-V provides the ecall instruction for this purpose.)<br>Once the CPU has switched to supervisor mode, the kernel can then validate the arguments of the<br>system call (e.g., check if the address passed to the system call is part of the application’s memory),<br>decide whether the application is allowed to perform the requested operation (e.g., check if the<br>application is allowed to write the specified file), and then deny it or execute it. It is important that<br>the kernel control the entry point for transitions to supervisor mode; if the application could decide<br>the kernel entry point, a malicious application could, for example, enter the kernel at a point where<br>the validation of arguments is skipped.</li></ul><h3 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h3><ul><li>A key design question is what part of the operating system should run in supervisor mode. One<br>possibility is that the entire operating system resides in the kernel, so that the implementations of<br>all system calls run in supervisor mode. This organization is called a <strong>monolithic kernel</strong>.</li><li>A downside of the monolithic organization is that the interactions among different parts of<br>the operating system are often complex (as we will see in the rest of this text), and therefore it is easy for an operating system developer to make a mistake. In a monolithic kernel, a mistake is<br>fatal, because an error in supervisor mode will often cause the kernel to fail. If the kernel fails,<br>the computer stops working, and thus all applications fail too. The computer must reboot to start<br>again.</li><li>To reduce the risk of mistakes in the kernel, OS designers can minimize the amount of operating<br>system code that runs in supervisor mode, and execute the bulk of the operating system in user<br>mode. This kernel organization is called a <strong>microkernel</strong>.</li><li>Figure 2.1 illustrates this microkernel design. In the figure, the file system runs as a user-level<br>process. OS services running as processes are called servers. To allow applications to interact with<br>the file server, the kernel provides an <strong>inter-process communication mechanism</strong> to send messages<br>from one user-mode process to another.<br><img src="/post/xv6-riscv-ch2/image.png" alt="alt text"></li><li>Xv6 is implemented as a monolithic kernel, like most Unix operating systems. Thus, the xv6<br>kernel interface corresponds to the operating system interface, and the kernel implements the com-<br>plete operating system. Since xv6 doesn’t provide many services, its kernel is smaller than some<br>microkernels, but conceptually xv6 is monolithic.</li></ul><h3 id="2-4-Code-xv6-organization"><a href="#2-4-Code-xv6-organization" class="headerlink" title="2.4 Code: xv6 organization"></a>2.4 Code: xv6 organization</h3><p><img src="/post/xv6-riscv-ch2/image-1.png" alt="alt text"></p><ul><li>The xv6 kernel source is in the kernel&#x2F; sub-directory. The source is divided into files, following<br>a rough notion of modularity; Figure 2.2 lists the files.The inter-module interfaces are defined in defs.h (kernel&#x2F;defs.h).</li></ul><h3 id="2-5-Process-overview"><a href="#2-5-Process-overview" class="headerlink" title="2.5 Process overview"></a>2.5 Process overview</h3><ul><li>The unit of isolation in xv6 (as in other Unix operating systems) is a process. The process ab-<br>straction prevents one process from wrecking or spying on another process’s memory, CPU, file<br>descriptors, etc. It also prevents a process from wrecking the kernel itself, so that a process can’t<br>subvert the kernel’s isolation mechanisms.</li><li>To help enforce isolation, the process abstraction provides the illusion to a program that it has<br>its own private machine. A process provides a program with what appears to be a private memory<br>system, or address space, which other processes cannot read or write. A process also provides the<br>program with what appears to be its own CPU to execute the program’s instructions.</li><li>Xv6 uses page tables (which are implemented by hardware) to give each process its own ad-<br>dress space. The RISC-V page table translates (or “maps”) a virtual address (the address that an<br>RISC-V instruction manipulates) to a physical address (an address that the CPU sends to main<br>memory).</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">|  9 bits | 9 bits | 9 bits |     12 bits     |<br>|  VPN[2] | VPN[1] | VPN[0] | Page Offset     |<br>|--------  页表索引 --------| 页内偏移 |<br><br>example:<br>虚拟地址：0x0000004001234567<br>              ↓<br>VPN[2] = 0x01  → level-2 页表（根）中偏移 8，得到 PTE1 → 指向 0x2000_0000<br>VPN[1] = 0x01  → level-1 页表中偏移 8，得到 PTE2 → 指向 0x3000_0000<br>VPN[0] = 0x46  → level-0 页表中偏移 0x230，得到 PTE3 → 页帧 0x4000<br>offset  = 0x4567<br><br>→ 最终物理地址 = 0x4000_0000 + 0x4567 = **0x4000_4567**<br></code></pre></td></tr></table></figure><ul><li>Xv6 maintains a separate page table for each process that defines that process’s address space.<br>As illustrated in Figure 2.3, an address space includes the process’s user memory starting at virtual<br>address zero.<br><img src="/post/xv6-riscv-ch2/image-2.png" alt="alt text"><ul><li>Instructions come first, followed by global variables, then the stack, and finally a “heap” area (for malloc) that the process can expand as needed.</li><li>There are a number of factors that limit the maximum size of a  process’s address space: pointers on the RISC-V are 64 bits wide; the hardware uses only the low 39 bits when looking up virtual addresses in page tables; and xv6 uses only 38 of those 39 bits. Thus, the maximum address is 238 − 1 &#x3D; 0x3fffffffff, which is MAXVA (kernel&#x2F;riscv.h:378).</li><li>At the top of the address space xv6 places a trampoline page (4096 bytes) and a trapframe page. Xv6 uses these two pages to transition into the kernel and back; the trampoline page contains the code to transition in and out of the kernel, and the trapframe is where the kernel saves the process’s user registers, as Chapter 4 explains.</li></ul></li><li>The xv6 kernel maintains many pieces of state for each process, which it gathers into a struct proc (kernel&#x2F;proc.h:85). A process’s most important pieces of kernel state are its page table, its kernel<br>stack, and its run state. We’ll use the notation p-&gt;xxx to refer to elements of the proc structure; for example, p-&gt;pagetable is a pointer to the process’s page table.</li><li>Each process has a thread of control (or thread for short) that holds the state needed to ex-<br>ecute the process.might be executing on a CPU, or suspended (not<br>executing, but capable of resuming executing in the future).</li><li>Each process has two stacks:<ul><li><strong>user stack</strong>: When the process is executing user instructions,only its user stack is in use, and its kernel stack is empty.</li><li><strong>kernel stack</strong>: When the process enters the kernel (for a system call or interrupt), the kernel code executes on the process’s kernel stack;   while a process is in the kernel, its user stack still contains saved data, but isn’t actively used.</li><li>A process’s thread alternates between actively using its user stack and its kernel stack.   The kernel stack is separate (and protected from user code) so that the kernel can execute even if a process has wrecked its user stack.</li></ul></li><li>A process can make a system call by executing the RISC-V <code>ecall</code> instruction. This instruction raises the hardware privilege level and changes the program counter to a kernel-defined entry point. The code at the entry point switches to the process’s kernel stack and executes the kernel instructions that implement the system call. When the system call completes, the kernel switches back to the user stack and returns to user space by calling the <code>sret</code> instruction, which lowers the hardware privilege level and resumes executing user instructions just after the system call instruction. A process’s thread can “block” in the kernel to wait for I&#x2F;O, and resume where it left off when the I&#x2F;O has finished.</li><li><code>p-&gt;state</code> indicates whether the process is allocated, ready to run, currently running on a CPU, waiting for I&#x2F;O, or exiting.</li><li><code>p-&gt;pagetable</code> holds the process’s page table, in the format that the RISC-V hardware ex- pects. Xv6 causes the paging hardware to use a process’s p-&gt;pagetable when executing that process in user space. A process’s page table also serve</li><li><em><strong>In summary</strong>, a process bundles two design ideas: an address space to give a process the illusion of its own memory, and a thread to give the process the illusion of its own CPU. In xv6, a process consists of one address space and one thread. In real operating systems a process may have more than one thread to take advantage of multiple CPUs.</em></li></ul><h3 id="2-6-Code-starting-xv6-the-first-process-and-system-call"><a href="#2-6-Code-starting-xv6-the-first-process-and-system-call" class="headerlink" title="2.6 Code: starting xv6, the first process and system call"></a>2.6 Code: starting xv6, the first process and system call</h3><p>To make xv6 more concrete, we’ll outline how the kernel starts and runs the first process.The subsequent chapters will describe the mechanisms that show up in this overview in more detail.</p><p>When the RISC-V computer powers on, it initializes itself and runs a boot loader which is stored in read-only memory.<br>The boot loader loads the xv6 kernel into memory.Then, in machine mode, the CPU executes xv6 starting at <code>_entry</code> (<code>kernel/entry.S:7</code>).The RISC-V starts with paging hardware disabled: virtual addresses map directly to physical addresses.</p><p>The loader loads the xv6 kernel into memory at physical address <code>0x80000000</code>.<br>The reason it places the kernel at <code>0x80000000</code> rather than <code>0x0</code> is because the address range <code>0x0:0x80000000</code> contains I&#x2F;O devices.</p><p>The instructions at <code>_entry</code> set up a stack so that xv6 can run C code.<br>Xv6 declares space for an initial stack, <code>stack0</code>, in the file <code>start.c</code> (<code>kernel/start.c:11</code>).The code at <code>_entry</code> loads the stack pointer register <code>sp</code> with the address <code>stack0 + 4096</code>, the top of the stack, because the stack on RISC-V grows down.Now that the kernel has a stack, <code>_entry</code> calls into C code at <code>start</code> (<code>kernel/start.c:15</code>).</p><p>The function <code>start</code> performs some configuration that is only allowed in machine mode, and then switches to supervisor mode.<br>To enter supervisor mode, RISC-V provides the instruction <code>mret</code>.This instruction is most often used to return from a previous call from supervisor mode to machine mode.<code>start</code> isn’t returning from such a call, but sets things up as if it were:</p><ul><li>it sets the previous privilege mode to supervisor in the register <code>mstatus</code>,</li><li>it sets the return address to <code>main</code> by writing <code>main</code>’s address into the register <code>mepc</code>,</li><li>disables virtual address translation in supervisor mode by writing 0 into the page-table register <code>satp</code>,</li><li>and delegates all interrupts and exceptions to supervisor mode.</li></ul><p>Before jumping into supervisor mode, <code>start</code> performs one more task:<br>it programs the clock chip to generate timer interrupts.With this housekeeping out of the way, <code>start</code> “returns” to supervisor mode by calling <code>mret</code>.<br>This causes the program counter to change to <code>main</code> (<code>kernel/main.c:11</code>), the address previously stored in <code>mepc</code>.</p><p>After <code>main</code> (<code>kernel/main.c:11</code>) initializes several devices and subsystems, it creates the first process by calling <code>userinit</code> (<code>kernel/proc.c:233</code>).The first process executes a small program written in RISC-V assembly, which makes the first system call in xv6.<code>initcode.S</code> (<code>user/initcode.S:3</code>) loads the number for the <code>exec</code> system call, <code>SYS_EXEC</code> (<code>kernel/syscall.h:8</code>), into register <code>a7</code>,and then calls <code>ecall</code> to re-enter the kernel.</p><p>The kernel uses the number in register <code>a7</code> in <code>syscall</code> (<code>kernel/syscall.c:132</code>) to call the desired system call.<br>The system call table (<code>kernel/syscall.c:107</code>) maps <code>SYS_EXEC</code> to the function <code>sys_exec</code>, which the kernel invokes.As we saw in Chapter 1, <code>exec</code> replaces the memory and registers of the current process with a new program (in this case, <code>/init</code>).</p><p>Once the kernel has completed <code>exec</code>, it returns to user space in the <code>/init</code> process.<code>init</code> (<code>user/init.c:15</code>) creates a new console device file if needed and then opens it as file descriptors 0, 1, and 2. Then it starts a shell on the console. The system is up.</p><h3 id="2-7-Security-Model"><a href="#2-7-Security-Model" class="headerlink" title="2.7 Security Model"></a>2.7 Security Model</h3><ul><li><p>The operating system must assume that a process’s <strong>user-level code</strong> will do its best to wreck the kernel or other processes.User code may try to dereference pointers outside its allowed address space; it may attempt to execute any RISC-V instructions, even those not intended for user code; it may try to read and write any RISC-V control register; it may try to directly access device hardware; and it may pass clever values to system calls in an attempt to trick the kernel into crashing or doing something stupid. The kernel’s goal is to restrict each user process so that all it can do is:</p><ul><li>read&#x2F;write&#x2F;execute its own user memory,</li><li>use the 32 general-purpose RISC-V registers,</li><li>and affect the kernel and other processes <strong>only</strong> in the ways that system calls are intended to allow.</li></ul></li><li><p>The expectations for the <strong>kernel’s own code</strong> are quite different.Kernel code is assumed to be written by well-meaning and careful programmers.Kernel code is expected to be bug-free, and certainly to contain nothing malicious.This assumption affects how we analyze kernel code.For example, there are many internal kernel functions (e.g., the spin locks) that would cause serious problems if kernel code used them incorrectly.When examining any specific piece of kernel code, we’ll want to convince ourselves that it behaves correctly.We assume, however, that kernel code in general is correctly written, and follows all the rules about use of the kernel’s own functions and data structures. At the hardware level, the RISC-V CPU, RAM, disk, etc. are assumed to operate as advertised in the documentation, with no hardware bugs.</p></li></ul><h3 id="2-8-Real-world"><a href="#2-8-Real-world" class="headerlink" title="2.8 Real world"></a>2.8 Real world</h3><p>Most operating systems have adopted the process concept, and most processes look similar to xv6’s. Modern operating systems, however, support several threads within a process, to allow a single process to exploit multiple CPUs. Supporting multiple threads in a process involves quite a bit of machinery that xv6 doesn’t have, often including interface changes (e.g., Linux’s clone, a variant of fork), to control which aspects of a process threads share.</p>]]></content:encoded>
      
      
      
      <category domain="https://GoKo-Son626.github.io/tags/xv6-riscv/">xv6-riscv</category>
      
      
      <comments>https://goko-son626.github.io/post/xv6-riscv-ch2.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>xv6-riscv-ch1</title>
      <link>https://goko-son626.github.io/post/xv6-riscv-ch1.html</link>
      <guid>https://goko-son626.github.io/post/xv6-riscv-ch1.html</guid>
      <pubDate>Mon, 05 May 2025 02:00:04 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;This chapter-1 introduces the basic Unix process, file, and I&amp;#x2F;O abstractions that applications use to interact with the OS.&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>This chapter-1 introduces the basic Unix process, file, and I&#x2F;O abstractions that applications use to interact with the OS.</strong></em></li></ul><span id="more"></span><h2 id="ch1-Operating-system-interfaces"><a href="#ch1-Operating-system-interfaces" class="headerlink" title="ch1: Operating system interfaces"></a><strong>ch1: Operating system interfaces</strong></h2><ul><li><p>As Figure 1.1 shows, xv6 takes the traditional form of a kernel, a special program that provides<br>services to running programs. Each running program, called a process, has memory containing<br>instructions, data, and a stack. The instructions implement the program’s computation. The data<br>are the variables on which the computation acts. The stack organizes the program’s procedure calls.<br>A given computer typically has many processes but only a single kernel.<br><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/xv6-riscv-ch1/image.png" alt="alt text"></p></li><li><p>When a user program invokes a sys-<br>tem call, the hardware raises the privilege level and starts executing a pre-arranged function in the<br>kernel.<br>The collection of system calls that a kernel provides is the interface that user programs see. The<br>xv6 kernel provides a subset of the services and system calls that Unix kernels traditionally offer.<br>Figure 1.2 lists all of xv6’s system calls.<br><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/xv6-riscv-ch1/image-1.png" alt="alt text"></p></li><li><p>The shell is an ordinary program that reads commands from the user and executes them. The<br>fact that the shell is a user program, and not part of the kernel, illustrates the power of the system<br>call interface: there is nothing special about the shell. It also means that the shell is easy to replace;<br>as a result, modern Unix systems have a variety of shells to choose from, each with its own user<br>interface and scripting features. The xv6 shell is a simple implementation of the essence of the<br>Unix Bourne shell. Its implementation can be found at (user&#x2F;sh.c:1).<br><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/xv6-riscv-ch1/image-2.png" alt="alt text"><br>The xv6 shell uses the exec calls of blew to run programs on behalf of users. The main structure of<br>the shell is simple; see main (user&#x2F;sh.c:146). The main loop reads a line of input from the user with<br>getcmd. Then it calls fork, which creates a copy of the shell process. The parent calls wait,<br>while the child runs the command. For example, if the user had typed “echo hello” to the shell,<br>runcmd would have been called with “echo hello” as the argument. runcmd (user&#x2F;sh.c:55) runs<br>the actual command. For “echo hello”, it would call exec (user&#x2F;sh.c:79). If exec succeeds then<br>the child will execute instructions from echo instead of runcmd. At some point echo will call<br>exit, which will cause the parent to return from wait in main (user&#x2F;sh.c:146).</p></li></ul><h3 id="1-1-Processes-and-memory"><a href="#1-1-Processes-and-memory" class="headerlink" title="1.1 Processes and memory"></a>1.1 Processes and memory</h3><ul><li>An xv6 process consists of user-space memory (instructions, data, and stack) and per-process state<br>private to the kernel. Xv6 time-shares processes: it transparently switches the available CPUs<br>among the set of processes waiting to execute. When a process is not executing, xv6 saves the<br>process’s CPU registers, restoring them when it next runs the process. The kernel associates a<br>process identifier, or PID, with each process.</li><li>the following program fragment written in the C programming lan-<br>guage</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();<br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>pid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>In the example, the output lines<br>parent: child&#x3D;1234<br>child: exiting<br>might come out in either order (or even intermixed), depending on whether the parent or child gets<br>to its printf call first. After the child exits, the parent’s wait returns, causing the parent to print<br>parent: child 1234 is done<br>Although the child has the same memory contents as the parent initially, the parent and child are<br>executing with separate memory and separate registers: changing a variable in one does not affect<br>the other. For example, when the return value of wait is stored into pid in the parent process, it<br>doesn’t change the variable pid in the child. The value of pid in the child will still be zero.</p><ul><li>The exec system call replaces the calling process’s memory with a new memory image loaded<br>from a file stored in the file system. The file must have a particular format, which specifies which<br>part of the file holds instructions, which part is data, at which instruction to start, etc. Xv6 uses the<br>ELF format, which Chapter 3 discusses in more detail. Usually the file is the result of compiling<br>a program’s source code. When exec succeeds, it does not return to the calling program; instead,<br>the instructions loaded from the file start executing at the entry point declared in the ELF header.<br>exec takes two arguments: the name of the file containing the executable and an array of string<br>arguments. For example</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *argv[<span class="hljs-number">3</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;echo&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>argv[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>exec(<span class="hljs-string">&quot;/bin/echo&quot;</span>, argv);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exec error\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>This fragment replaces the calling program with an instance of the program &#x2F;bin&#x2F;echo running<br>with the argument list echo hello. Most programs ignore the first element of the argument array,<br>which is conventionally the name of the program.</p><ul><li>why fork and exec are not combined in a single call<br>we will see later that<br>the shell exploits the separation in its implementation of I&#x2F;O redirection.<br>Xv6 allocates most user-space memory implicitly: fork allocates the memory required for the<br>child’s copy of the parent’s memory, and exec allocates enough memory to hold the executable<br>file. A process that needs more memory at run-time (perhaps for malloc) can call sbrk(n) to<br>grow its data memory by n zero bytes; sbrk returns the location of the new memory.</li></ul><h3 id="1-2-I-O-and-File-descriptors"><a href="#1-2-I-O-and-File-descriptors" class="headerlink" title="1.2 I&#x2F;O and File descriptors"></a>1.2 I&#x2F;O and File descriptors</h3><ul><li>A file descriptor is a small integer representing a kernel-managed object that a process may read<br>from or write to. A process may obtain a file descriptor by opening a file, directory, or device,<br>or by creating a pipe, or by duplicating an existing descriptor. For simplicity we’ll often refer<br>to the object a file descriptor refers to as a “file”; the file descriptor interface abstracts away the<br>differences between files, pipes, and devices, making them all look like streams of bytes. We’ll<br>refer to input and output as I&#x2F;O.</li><li>Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so that<br>every process has a private space of file descriptors starting at zero. By convention, a process reads<br>from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and<br>writes error messages to file descriptor 2 (standard error). As we will see, the shell exploits the<br>convention to implement I&#x2F;O redirection and pipelines. The shell ensures that it always has three<br>file descriptors open (user&#x2F;sh.c:152), which are by default file descriptors for the console.</li><li>The following program fragment (which forms the essence of the program cat) copies data<br>from its standard input to its standard output. If an error occurs, it writes a message to the standard<br>error.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">for</span>(;;)&#123;<br>n = read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span> buf);<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read error\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(write(<span class="hljs-number">1</span>, buf, n) != n)&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write error\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The important thing to note in the code fragment is that cat doesn’t know whether it is reading<br>from a file, console, or a pipe. Similarly cat doesn’t know whether it is printing to a console, a<br>file, or whatever. The use of file descriptors and the convention that file descriptor 0 is input and<br>file descriptor 1 is output allows a simple implementation of cat.</p><ul><li>The close system call releases a file descriptor, making it free for reuse by a future open,<br>pipe, or dup system call (see below). A newly allocated file descriptor is always the lowest-<br>numbered unused descriptor of the current process.</li><li>File descriptors and fork interact to make I&#x2F;O redirection easy to implement.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cat&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>close(<span class="hljs-number">0</span>);<br>open(<span class="hljs-string">&quot;input.txt&quot;</span>, O_RDONLY);<br>exec(<span class="hljs-string">&quot;cat&quot;</span>, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>After the child closes file descriptor 0, open is guaranteed to use that file descriptor for the newly<br>opened input.txt: 0 will be the smallest available file descriptor. cat then executes with file<br>descriptor 0 (standard input) referring to input.txt. The parent process’s file descriptors are not<br>changed by this sequence</p><ul><li>Two file descriptors share an offset if they were derived from the same original file descriptor<br>by a sequence of fork and dup calls. Otherwise file descriptors do not share offsets, even if they<br>resulted from open calls for the same file.</li><li>dup allows shells to implement commands like this: <code>ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</code>. The 2&gt;&amp;1 tells the shell to give the command a file descriptor 2 that is a duplicate of descriptor 1. Both the name of the existing file and the error message for the non-existing file will show up in the file tmp1. The xv6 shell doesn’t support I&#x2F;O redirection for the error file descriptor, but now you know how to implement it.</li></ul><h3 id="1-3-Pipes"><a href="#1-3-Pipes" class="headerlink" title="1.3 Pipes"></a>1.3 Pipes</h3><ul><li>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading<br>and one for writing. Writing data to one end of the pipe makes that data available for reading from<br>the other end of the pipe. Pipes provide a way for processes to communicate.</li><li>The following example code runs the program wc with standard input connected to the read<br>end of a pipe.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pipe(p);<br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123;<br>close(<span class="hljs-number">0</span>);<br>dup(p[<span class="hljs-number">0</span>]);<br>close(p[<span class="hljs-number">0</span>]);<br>close(p[<span class="hljs-number">1</span>]);<br>exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>close(p[<span class="hljs-number">0</span>]);<br>write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>);<br>close(p[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">          pipe<br>  [p[1]] -------&gt; [p[0]]<br>   (write)         (read)<br><br>parent:<br>   write(p[1], ...)<br><br>child:<br>   dup(p[0]) -&gt; fd 0<br>   exec(&quot;wc&quot;) -&gt; wc reads from stdin (=read of pipe)<br></code></pre></td></tr></table></figure><p>The fact that read blocks until it is impossible for new data to arrive<br>is one reason that it’s important for the child to close the write end of the pipe before executing<br>wc above: if one of wc ’s file descriptors referred to the write end of the pipe and <strong>not close</strong>, wc would never see<br>end-of-file.</p><ul><li>The xv6 shell implements pipelines such as grep fork sh.c | wc -l in a manner similar<br>to the above code (user&#x2F;sh.c:101). The child process creates a pipe to connect the left end of the<br>pipeline with the right end. Then it calls fork and runcmd for the left end of the pipeline and<br>fork and runcmd for the right end, and waits for both to finish. The right end of the pipeline<br>may be a command that itself includes a pipe (e.g., a | b | c), which itself forks two new child<br>processes (one for b and one for c). Thus, the shell may create a tree of processes. The leaves<br>16of this tree are commands and the interior nodes are processes that wait until the left and right<br>children complete.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">   sh<br>  /  \<br>a     sh<br>     /  \<br>   b     c<br></code></pre></td></tr></table></figure><ul><li><code>echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</code><br>Pipes have at least three advantages over temporary files in this situation. <ul><li>First, pipes automatically clean themselves up; with the file redirection, a shell would have to be careful to remove &#x2F;tmp&#x2F;xyz when done. </li><li>Second, pipes can pass arbitrarily long streams of data, while file redirection requires enough free space on disk to store all the data. </li><li>Third, pipes allow for parallel execution of pipeline stages, while the file approach requires the first program to finish before the second starts.</li></ul></li></ul><h3 id="1-4-File-system"><a href="#1-4-File-system" class="headerlink" title="1.4 File system"></a>1.4 File system</h3><ul><li>The xv6 file system provides data files, which contain uninterpreted byte arrays, and directories,<br>which contain named references to data files and other directories.</li><li>There are system calls to create new files and directories: mkdir creates a new directory, open<br>with the O_CREATE flag creates a new data file, and mknod creates a new device file. This example<br>illustrates all three:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">mkdir(<span class="hljs-string">&quot;/dir&quot;</span>);<br>fd = open(<span class="hljs-string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY);<br>close(fd);<br>mknod(<span class="hljs-string">&quot;/console&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>mknod creates a special file that refers to a device. Associated with a device file are the major and<br>minor device numbers (the two arguments to mknod), which uniquely identify a kernel device.<br>When a process later opens a device file, the kernel diverts read and write system calls to the<br>kernel device implementation instead of passing them to the file system.</p><ul><li>A file’s name is distinct from the file itself; the same underlying file, called an inode, can have<br>multiple names, called links. Each link consists of an entry in a directory; the entry contains a file<br>name and a reference to an inode. An inode holds metadata about a file, including its type (file or<br>directory or device), its length, the location of the file’s content on disk, and the number of links to<br>a file.</li><li>The fstat system call retrieves information from the inode that a file descriptor refers to. It<br>fills in a struct stat, defined in stat.h (kernel&#x2F;stat.h) as:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#define T_DIR           1// Directory<br>#define T_FILE          2// File<br>#define T_DEVICE        3// Device<br><br>struct stat &#123;<br>        int dev;        // File system’s disk device<br>        uint ino;       // Inode number<br>        short type;     // Type of file<br>        short nlink;    // Number of links to file<br>        uint64 size;    // Size of file in bytes<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>The link system call creates another file system name referring to the same inode as an exist-<br>ing file. This fragment creates a new file named both a and b.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">open(<span class="hljs-string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);<br>link(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br></code></pre></td></tr></table></figure><p>Reading from or writing to a is the same as reading from or writing to b. Each inode is identified<br>by a unique inode number. After the code sequence above, it is possible to determine that a and b<br>refer to the same underlying contents by inspecting the result of fstat: both will return the same<br>inode number (ino), and the nlink count will be set to 2.<br>The unlink system call removes a name from the file</p><ul><li>The unlink system call removes a name from the file system. The file’s inode and the disk<br>space holding its content are only freed when the file’s link count is zero and no file descriptors<br>refer to it. Thus adding</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">unlink(<span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure><p>to the last code sequence leaves the inode and file content accessible as b. Furthermore,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = open(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>, O_CREATE|O_RDWR);<br>unlink(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>);<br></code></pre></td></tr></table></figure><p>is an idiomatic way to create a temporary inode with no name that will be cleaned up when the<br>process closes fd or exits.</p><ul><li>Unix provides file utilities callable from the shell as user-level programs, for example mkdir,<br>ln, and rm. This design allows anyone to extend the command-line interface by adding new user-<br>level programs. In hindsight this plan seems obvious, but other systems designed at the time of<br>Unix often built such commands into the shell (and built the shell into the kernel).<br>One exception is cd, which is built into the shell (user&#x2F;sh.c:161). cd must change the current<br>working directory of the shell itself. If cd were run as a regular command, then the shell would<br>18fork a child process, the child process would run cd, and cd would change the child ’s working<br>directory. The parent’s (i.e., the shell’s) working directory would not change.</li></ul><h3 id="1-5-Real-world"><a href="#1-5-Real-world" class="headerlink" title="1.5 Real world"></a>1.5 Real world</h3><ul><li>the shell was the <strong>first so-called “scripting language.”</strong> The Unix system call interface persists today in<br>systems like BSD, Linux, and macOS.</li><li>The Unix system call interface has been standardized through the Portable Operating System<br>Interface (POSIX) standard. Xv6 is not POSIX compliant: it is missing many system calls (in-<br>cluding basic ones such as lseek), and many of the system calls it does provide differ from the<br>standard. Our main goals for xv6 are simplicity and clarity while providing a simple UNIX-like<br>system-call interface. Several people have extended xv6 with a few more system calls and a sim-<br>ple C library in order to run basic Unix programs. Modern kernels, however, provide many more<br>system calls, and many more kinds of kernel services, than xv6. For example, they support net-<br>working, windowing systems, user-level threads, drivers for many devices, and so on. Modern<br>kernels evolve continuously and rapidly, and offer many features beyond POSIX.</li><li>Xv6 does not provide a notion of users or of protecting one user from another; in Unix terms,<br>all xv6 processes run as root.</li></ul><h3 id="comments："><a href="#comments：" class="headerlink" title="comments："></a>comments：</h3><ul><li>Linux tries to adhere to POSIX (glibc provides most of the POSIX interfaces), but has its own extensions (e.g., epoll).</li><li>Programmers who write POSIX interfaces can compile and run them on macOS, BSD, and Linux (as long as they don’t use platform-specific extensions).</li><li>Think of the xv6 system call interface as a “subset implementation of POSIX.”</li><li></li></ul><p><a href="https://pubs.opengroup.org/onlinepubs/9699919799/"><strong>POSIX文档</strong></a></p>]]></content:encoded>
      
      
      
      <category domain="https://GoKo-Son626.github.io/tags/xv6-riscv/">xv6-riscv</category>
      
      
      <comments>https://goko-son626.github.io/post/xv6-riscv-ch1.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>xv6-riscv_struct</title>
      <link>https://goko-son626.github.io/post/xv6-riscv-struct.html</link>
      <guid>https://goko-son626.github.io/post/xv6-riscv-struct.html</guid>
      <pubDate>Sun, 04 May 2025 16:17:48 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;File structure of &lt;code&gt;xv6-riscv&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><em><strong>File structure of <code>xv6-riscv</code></strong></em></p><span id="more"></span><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs zsh">.<br>├── kernel<br>│   ├── bio.c<br>│   ├── buf.h<br>│   ├── console.c<br>│   ├── defs.h<br>│   ├── elf.h<br>│   ├── entry.S<br>│   ├── exec.c<br>│   ├── fcntl.h<br>│   ├── file.c<br>│   ├── file.h<br>│   ├── fs.c<br>│   ├── fs.h<br>│   ├── kalloc.c<br>│   ├── kernel.ld<br>│   ├── kernelvec.S<br>│   ├── log.c<br>│   ├── main.c<br>│   ├── memlayout.h<br>│   ├── param.h<br>│   ├── pipe.c<br>│   ├── plic.c<br>│   ├── printf.c<br>│   ├── proc.c<br>│   ├── proc.h<br>│   ├── riscv.h<br>│   ├── sleeplock.c<br>│   ├── sleeplock.h<br>│   ├── spinlock.c<br>│   ├── spinlock.h<br>│   ├── start.c<br>│   ├── stat.h<br>│   ├── string.c<br>│   ├── swtch.S<br>│   ├── syscall.c<br>│   ├── syscall.h<br>│   ├── sysfile.c<br>│   ├── sysproc.c<br>│   ├── trampoline.S<br>│   ├── trap.c<br>│   ├── types.h<br>│   ├── uart.c<br>│   ├── virtio_disk.c<br>│   ├── virtio.h<br>│   └── vm.c<br>├── LICENSE<br>├── Makefile<br>├── mkfs<br>│   └── mkfs.c<br>├── README<br>└── user<br>    ├── cat.c<br>    ├── echo.c<br>    ├── forktest.c<br>    ├── grep.c<br>    ├── grind.c<br>    ├── init.c<br>    ├── initcode.S<br>    ├── kill.c<br>    ├── ln.c<br>    ├── ls.c<br>    ├── mkdir.c<br>    ├── printf.c<br>    ├── rm.c<br>    ├── sh.c<br>    ├── stressfs.c<br>    ├── ulib.c<br>    ├── umalloc.c<br>    ├── user.h<br>    ├── user.ld<br>    ├── usertests.c<br>    ├── usys.pl<br>    ├── wc.c<br>    └── zombie.c<br></code></pre></td></tr></table></figure><h2 id="逐文件详细解读它们的作用、重要性："><a href="#逐文件详细解读它们的作用、重要性：" class="headerlink" title="逐文件详细解读它们的作用、重要性："></a>逐文件详细解读它们的作用、重要性：</h2><hr><h3 id="🧠-整体结构"><a href="#🧠-整体结构" class="headerlink" title="🧠 整体结构"></a>🧠 整体结构</h3><table><thead><tr><th>目录&#x2F;文件</th><th>作用</th><th>建议重点关注</th></tr></thead><tbody><tr><td><code>kernel/</code></td><td>xv6 核心实现，内核源码</td><td>✅ 必看</td></tr><tr><td><code>user/</code></td><td>用户态程序、测试程序、库</td><td>✅ 推荐</td></tr><tr><td><code>mkfs/</code></td><td>构建文件系统镜像工具</td><td>❗可选</td></tr><tr><td>顶层构建文件</td><td><code>Makefile</code>, <code>README</code>, <code>LICENSE</code> 等</td><td>🧩 熟悉结构用</td></tr></tbody></table><hr><h2 id="📁-kernel-—-xv6-的心脏（重点模块）"><a href="#📁-kernel-—-xv6-的心脏（重点模块）" class="headerlink" title="📁 kernel&#x2F; — xv6 的心脏（重点模块）"></a>📁 kernel&#x2F; — xv6 的心脏（重点模块）</h2><p>xv6 主要模块可分为：</p><ul><li><strong>内核启动与内存管理</strong>：<code>entry.S</code>、<code>start.c</code>、<code>vm.c</code>、<code>kalloc.c</code></li><li><strong>中断、异常、系统调用</strong>：<code>trap.c</code>、<code>syscall.c</code>、<code>kernelvec.S</code>、<code>trampoline.S</code></li><li><strong>进程调度与管理</strong>：<code>proc.c</code>、<code>swtch.S</code></li><li><strong>文件系统与文件接口</strong>：<code>fs.c</code>、<code>file.c</code>、<code>bio.c</code>、<code>log.c</code></li><li><strong>设备驱动</strong>：<code>uart.c</code>、<code>console.c</code>、<code>virtio_disk.c</code>、<code>plic.c</code></li><li><strong>内核工具代码</strong>：<code>spinlock.c</code>、<code>sleeplock.c</code>、<code>printf.c</code>、<code>string.c</code></li></ul><hr><h3 id="🧾-文件级详细解释（按子系统分类）"><a href="#🧾-文件级详细解释（按子系统分类）" class="headerlink" title="🧾 文件级详细解释（按子系统分类）"></a>🧾 文件级详细解释（按子系统分类）</h3><hr><h5 id="🟩-一、内核启动与内存管理"><a href="#🟩-一、内核启动与内存管理" class="headerlink" title="🟩 一、内核启动与内存管理"></a>🟩 一、内核启动与内存管理</h5><table><thead><tr><th>文件</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>entry.S</code></td><td>核心启动汇编入口</td><td>设置页表、跳转到 <code>start()</code></td></tr><tr><td><code>start.c</code></td><td>C 语言入口</td><td><code>main()</code> 前做环境初始化（页表、trapframe）</td></tr><tr><td><code>main.c</code></td><td>内核主函数</td><td>启动内核模块，如 <code>userinit()</code></td></tr><tr><td><code>kernel.ld</code></td><td>内核链接脚本</td><td>指定内核段地址、符号导出顺序</td></tr><tr><td><code>vm.c</code></td><td>虚拟内存系统</td><td>页表分配、拷贝、映射（基于 Sv39）</td></tr><tr><td><code>kalloc.c</code></td><td>物理页分配器</td><td>管理空闲页链表，用于 <code>allocuvm</code></td></tr><tr><td><code>memlayout.h</code></td><td>内存布局宏</td><td>定义 KERNBASE、PHYSTOP 等常量</td></tr></tbody></table><p>📌 建议从 <code>entry.S → start.c → main.c → userinit()</code> 跑一遍流程。</p><hr><h5 id="🟦-二、进程管理与调度"><a href="#🟦-二、进程管理与调度" class="headerlink" title="🟦 二、进程管理与调度"></a>🟦 二、进程管理与调度</h5><table><thead><tr><th>文件</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>proc.c</code></td><td>管理进程表、fork&#x2F;wait</td><td><code>scheduler()</code> 是调度器核心</td></tr><tr><td><code>proc.h</code></td><td>进程结构体定义</td><td>结构体 <code>struct proc</code> 包含页表、状态、trapframe</td></tr><tr><td><code>swtch.S</code></td><td>上下文切换汇编</td><td>保存&#x2F;恢复寄存器，调度必用</td></tr><tr><td><code>trap.c</code></td><td>trap&#x2F;中断入口</td><td>用户 → 内核的总入口；异常调度、syscall 都走它</td></tr><tr><td><code>sysproc.c</code></td><td>与进程相关的系统调用</td><td><code>sys_exit</code>、<code>sys_fork</code>、<code>sys_wait</code></td></tr></tbody></table><p>📌 强烈建议：给 <code>fork()</code>、<code>scheduler()</code>、<code>yield()</code> 加打印观察运行。</p><hr><h5 id="🟨-三、系统调用机制"><a href="#🟨-三、系统调用机制" class="headerlink" title="🟨 三、系统调用机制"></a>🟨 三、系统调用机制</h5><table><thead><tr><th>文件</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>syscall.c</code></td><td>syscall 分发器</td><td>根据 syscall num 分发到 <code>sys_*</code></td></tr><tr><td><code>syscall.h</code></td><td>syscall 编号</td><td>用 <code>#define SYS_write 1</code> 等映射</td></tr><tr><td><code>sysfile.c</code></td><td>文件相关 syscall</td><td><code>open/close/read/write</code> 的内核实现</td></tr><tr><td><code>usys.pl</code> → <code>usys.S</code></td><td>用户态 syscall 包装</td><td>生成用户代码 <code>mov a7, id; ecall</code></td></tr></tbody></table><p>📌 syscall 流程 &#x3D; 用户态 <code>ecall</code> → trap → syscall.c → sys_*()</p><hr><h5 id="🟧-四、文件系统与-I-O-接口"><a href="#🟧-四、文件系统与-I-O-接口" class="headerlink" title="🟧 四、文件系统与 I&#x2F;O 接口"></a>🟧 四、文件系统与 I&#x2F;O 接口</h5><table><thead><tr><th>文件</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>fs.c</code></td><td>inode 层</td><td><code>ialloc</code>, <code>readi</code>, <code>writei</code>，文件核心结构</td></tr><tr><td><code>fs.h</code></td><td>inode 定义</td><td><code>struct inode</code>，块地址信息等</td></tr><tr><td><code>file.c</code></td><td>文件描述符层</td><td><code>struct file</code>，管理 open&#x2F;close 等</td></tr><tr><td><code>file.h</code></td><td>文件描述符定义</td><td>支持 pipe&#x2F;dev&#x2F;inode 等类型</td></tr><tr><td><code>bio.c</code></td><td>缓存块读写</td><td>实现 block 级读写缓存</td></tr><tr><td><code>log.c</code></td><td>日志机制</td><td>crash-safe 写操作事务（write-ahead logging）</td></tr><tr><td><code>pipe.c</code></td><td>管道实现</td><td>内存中双向 FIFO</td></tr><tr><td><code>fcntl.h</code>, <code>stat.h</code></td><td>POSIX 相关头文件</td><td>用于 <code>open</code> flag、<code>stat</code> 结构体</td></tr></tbody></table><p>📌 建议调试 <code>fs.c</code> 的 <code>namei()</code>、<code>dirlookup()</code>，看路径如何被解析。</p><hr><h5 id="🟥-五、设备驱动与中断控制"><a href="#🟥-五、设备驱动与中断控制" class="headerlink" title="🟥 五、设备驱动与中断控制"></a>🟥 五、设备驱动与中断控制</h5><table><thead><tr><th>文件</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>uart.c</code></td><td>串口驱动</td><td>初始化串口，写入字符给终端</td></tr><tr><td><code>console.c</code></td><td>控制台 I&#x2F;O</td><td>与 UART 配合实现 shell 输入输出</td></tr><tr><td><code>plic.c</code></td><td>中断控制器</td><td>Platform-Level Interrupt Controller</td></tr><tr><td><code>virtio_disk.c</code></td><td>虚拟磁盘驱动</td><td>QEMU 虚拟磁盘硬件访问层</td></tr><tr><td><code>virtio.h</code></td><td>virtio 设备定义</td><td>配套数据结构</td></tr></tbody></table><p>📌 <code>virtio_disk.c</code> 调试方法：观察 <code>virtio_rw()</code> 实现的读写逻辑。</p><hr><h5 id="🟫-六、工具类-内核库函数"><a href="#🟫-六、工具类-内核库函数" class="headerlink" title="🟫 六、工具类 &#x2F; 内核库函数"></a>🟫 六、工具类 &#x2F; 内核库函数</h5><table><thead><tr><th>文件</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>defs.h</code></td><td>内核函数声明</td><td><code>extern</code> 所有模块函数，供全局使用</td></tr><tr><td><code>riscv.h</code></td><td>RISC-V CSR 宏、寄存器定义</td><td>包含 <code>rdtime</code>, <code>csrr</code>, <code>sstatus</code> 等</td></tr><tr><td><code>spinlock.c/.h</code></td><td>自旋锁实现</td><td>核心互斥机制，需关中断</td></tr><tr><td><code>sleeplock.c/.h</code></td><td>睡眠锁实现</td><td>用于文件系统，sleep&#x2F;wakeup 管理</td></tr><tr><td><code>string.c</code></td><td>libc 实现</td><td><code>memcpy</code>, <code>strlen</code> 等内核自带函数</td></tr><tr><td><code>printf.c</code></td><td>内核级 printf</td><td>用于调试打印，无缓冲版</td></tr><tr><td><code>param.h</code></td><td>系统参数宏</td><td>定义 <code>NPROC</code>, <code>MAXPATH</code> 等全局参数</td></tr><tr><td><code>types.h</code></td><td>常用类型定义</td><td><code>uchar</code>, <code>uint</code>, <code>sint</code> 等简写</td></tr></tbody></table><p>📌 常用 grep 命令：<code>grep -rn &quot;spin_lock&quot; kernel/</code> 追踪并发点</p><hr><h3 id="📁-user-—-用户态程序与测试"><a href="#📁-user-—-用户态程序与测试" class="headerlink" title="📁 user&#x2F; — 用户态程序与测试"></a>📁 user&#x2F; — 用户态程序与测试</h3><table><thead><tr><th>文件</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>*.c</code></td><td>命令程序</td><td>shell 命令如 <code>ls</code>, <code>cat</code>, <code>echo</code>, <code>sh</code> 等</td></tr><tr><td><code>init.c</code></td><td>首个用户进程</td><td><code>userinit()</code> 启动的程序，运行 <code>/init</code></td></tr><tr><td><code>initcode.S</code></td><td>最原始的用户态代码</td><td>由 <code>userinit()</code> 载入的程序（汇编）</td></tr><tr><td><code>ulib.c</code></td><td>libc 函数</td><td>用户态的 <code>malloc</code>, <code>printf</code> 等</td></tr><tr><td><code>umalloc.c</code></td><td>malloc 实现</td><td>用户态堆分配</td></tr><tr><td><code>usertests.c</code></td><td>用户态测试集</td><td>测试 syscall、进程、文件功能</td></tr><tr><td><code>user.ld</code></td><td>用户态链接脚本</td><td>控制用户程序的段分布</td></tr><tr><td><code>user.h</code></td><td>函数声明</td><td>供用户程序引用 <code>printf</code>, <code>fork</code> 等接口</td></tr></tbody></table><p>📌 强烈推荐你从 <code>init.c</code> 开始 debug，第一个用户进程的运行关键路径！</p><hr><h3 id="📁-mkfs-—-构建文件系统镜像工具"><a href="#📁-mkfs-—-构建文件系统镜像工具" class="headerlink" title="📁 mkfs&#x2F; — 构建文件系统镜像工具"></a>📁 mkfs&#x2F; — 构建文件系统镜像工具</h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>mkfs.c</code></td><td>构建 xv6 文件系统镜像（user&#x2F;init 等文件压入）</td></tr></tbody></table><p>📌 不看也无妨，用于 <code>make</code> 阶段构建 <code>fs.img</code></p><hr><h3 id="📄-顶层文件"><a href="#📄-顶层文件" class="headerlink" title="📄 顶层文件"></a>📄 顶层文件</h3><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>Makefile</code></td><td>编译入口，构建 <code>kernel</code>, <code>fs.img</code>, <code>qemu</code> 等</td></tr><tr><td><code>README</code></td><td>简要说明文档，讲解如何使用</td></tr><tr><td><code>LICENSE</code></td><td>授权条款（MIT）</td></tr></tbody></table><hr><h3 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h3><ul><li>用 <strong>模块化思维</strong> 分阶段学，比如 “先把 trap 理清楚”，再看 syscall。</li><li>推荐搭配如下工具：<ul><li>tmux</li><li>zsh</li><li>grep…</li></ul></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://GoKo-Son626.github.io/tags/xv6-riscv/">xv6-riscv</category>
      
      
      <comments>https://goko-son626.github.io/post/xv6-riscv-struct.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo博客搭建</title>
      <link>https://goko-son626.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://goko-son626.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html</guid>
      <pubDate>Thu, 01 May 2025 05:25:09 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;使用hexo和GitHub Pagtes部署一个自己的博客&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>使用hexo和GitHub Pagtes部署一个自己的博客</strong></em></li></ul><span id="more"></span><h3 id="1-安装并初始化Hexo"><a href="#1-安装并初始化Hexo" class="headerlink" title="1. 安装并初始化Hexo"></a>1. 安装并初始化Hexo</h3><ul><li><ol><li>安装 Hexo CLI</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>初始化博客项目目录</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mkdir my-blog &amp;&amp; cd my-blog<br>hexo init<br>npm install<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>本地预览</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo server<br></code></pre></td></tr></table></figure><ul><li>启动本地服务：在浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看效果</li></ul><h3 id="2-配置-GitHub-Pages-部署"><a href="#2-配置-GitHub-Pages-部署" class="headerlink" title="2.  配置 GitHub Pages 部署"></a>2.  配置 GitHub Pages 部署</h3><ul><li><ol><li>创建GitHub仓库</li></ol><ul><li>创建一个仓库，名字叫 你的GitHub用户名.github.io</li><li>比如你是 goko，就叫 goko.github.io</li></ul></li><li><ol start="2"><li>安装部署插件</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>修改 _config.yml（根目录下）添加部署配置：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">deploy:<br>  type: git<br>  # repo建议使用SSH, SSH免密<br>  repo: https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git<br>  branch: main  # 或者 master，看你的默认分支<br></code></pre></td></tr></table></figure><ul><li><ol start="4"><li>生成并部署博客</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><h3 id="3-域名-com-绑定"><a href="#3-域名-com-绑定" class="headerlink" title="3. 域名(.com)绑定"></a>3. 域名(<xxxx>.com)绑定</xxxx></h3><ul><li><ol><li>添加域名(在my-blog下)</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">echo &quot;&lt;xxxx&gt;.com&quot; &gt; source/CNAME<br># 或者可以：echo &quot;www.&lt;xxxx&gt;.com&quot; &gt; source/CNAME<br># 只能添加一个，而且两个需要添加不同的域名解析（如下）<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>重新部署</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>设置 DNS 解析指向 GitHub Pages</li></ol></li></ul><p><strong>A. 使用裸域名（apex 域名）goku72.com</strong></p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>@</td><td>185.199.108.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.109.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.110.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.111.153</td><td>GitHub Pages IP</td></tr></tbody></table><p>example aliyun:</p><ol><li>选择业务需求: 将网站域名解析到服务器IPv4地址</li><li>选择网站域名(主机记录): <xxxx>.com（对应设置“@”主机记录）</xxxx></li><li>填写 IP（记录值）：</li></ol><ul><li>在输入框里粘贴以下四行（每一行一个 IP）：</li><li><pre><code>  &gt; 185.199.109.153  &gt; 185.199.108.153  &gt; 185.199.110.153  &gt; 185.199.111.153</code></pre></li></ul><hr><p><strong>B. 使用 <a href="http://www.goku72.com/">www.goku72.com</a> 作为主域名</strong></p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th><th>说明</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>&lt;github用户名&gt;.github.io.</td><td>指向你的 GitHub 用户页仓库</td></tr></tbody></table><p>example aliyun:</p><ol><li>选择业务需求: 将网站域名解析到另外的目标域名</li><li>选择网站域名(主机记录): www.<xxxx>.com（对应设置“www”主机记录）</xxxx></li><li>填写 IP（记录值）：&lt;github用户名&gt;.github.io. (最有有一个符号”.”)</li></ol><h3 id="4-设置主题"><a href="#4-设置主题" class="headerlink" title="4. 设置主题"></a>4. 设置主题</h3><ul><li>cd my-blog&#x2F;themes</li><li>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> butterfly</li><li>修改_config.yml: <ul><li>theme: butterfly</li></ul></li><li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</li></ul><p><strong>更多主题</strong>：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p><strong>注：</strong></p><ul><li>如果AB两个方式都添加了，只需要在 Hexo 项目的 source&#x2F;CNAME 文件中写 www.<xxxx>.com，GitHub Pages 就会自动把 goku72.com 重定向过去，无需额外设置！</xxxx></li><li>后续换域名只需要：阿里云重新解析 + 修改 source&#x2F;CNAME + 重新部署 Hexo，就能完成域名迁移。</li><li>有些主题可能需要下载插件</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://GoKo-Son626.github.io/tags/hexo/">hexo</category>
      
      
      <comments>https://goko-son626.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>

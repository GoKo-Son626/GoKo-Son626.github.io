<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>GoKo&#39;s blog</title>
    <link>https://GoKo-Son626.github.io/</link>
    
    <atom:link href="https://goko-son626.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 27 May 2025 11:05:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>IIC</title>
      <link>https://goko-son626.github.io/post/wds-IIC.html</link>
      <guid>https://goko-son626.github.io/post/wds-IIC.html</guid>
      <pubDate>Sun, 25 May 2025 02:02:38 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;hr&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><hr></li></ul><span id="more"></span><h1 id="EEPROM-IIC"><a href="#EEPROM-IIC" class="headerlink" title="EEPROM(IIC)"></a>EEPROM(IIC)</h1><ul><li>ROM(Read Only Memory): 制造和升级不便</li><li>PROM(Programmable ROM): 但是只能写入一次，后续无法修改</li><li>EPROM(Erasable Programmable ROM): 紫外线透过玻璃窗口照射内部芯片就可以擦除其内部的数据</li><li>EEPROM: 带电可擦除可编程只读存储器，以电子信号来修改其内容，它属于双电压芯片。借助于EEPROM芯片的双电压特性，可以使BIOS具有良好的防毒功能，在升级时，把跳线开关打至“on”的位置，即给芯片加上相应的编程电压，就可以方便地升级；平时使用时，则把跳线开关打至“off”的位置，防止CIH类的病毒对BIOS芯片的非法修改。</li></ul><p>读取IIC设备：</p><ul><li>控制器</li><li>设备地址：根据芯片手册和模块原理图查询<br>查找IIC设备：i2cdetect -y 0&#x2F;1&#x2F;2…</li></ul><ul><li><p><strong>Platform 总线 (Platform Bus):</strong></p><ul><li><strong>特点:</strong> 这是一种虚拟总线，用于连接那些没有硬件总线（如PCI、USB等）但又需要与CPU直接通信的设备。这些设备通常是SoC（System on Chip）内部的各种控制器，例如GPIO控制器、UART、SPI、I2C控制器本身等等。</li><li><strong>作用:</strong> 它提供了一种统一的机制来管理和抽象这些片上设备，使得驱动开发者不需要关心具体的硬件地址和中断号，而是通过 Platform 总线提供的接口来注册和操作设备。</li><li><strong>原理:</strong> Platform 设备和 Platform 驱动通过 <code>platform_device</code> 和 <code>platform_driver</code> 结构体进行描述。当设备和驱动的名称匹配时，内核就会将它们关联起来。</li><li><strong>匹配过程:</strong> 通常是基于 <code>name</code> 字段的字符串匹配。<code>platform_device</code> 中的 <code>name</code> 字段与 <code>platform_driver</code> 中 <code>driver.name</code> 字段进行比较。如果匹配成功，就会调用驱动的 <code>probe</code> 函数。</li></ul></li><li><p><strong>I2C 总线 (I2C Bus):</strong></p><ul><li><strong>特点:</strong> I2C 是一种串行通信协议，用于连接低速外设，如传感器、EEPROM、实时时钟 (RTC) 等。在 Linux 中，I2C 总线管理着I2C控制器和I2C从设备。</li><li><strong>作用:</strong> 它为I2C设备提供了一套标准的API，使得驱动开发者可以方便地读写I2C设备寄存器，而无需关心I2C协议的底层细节。</li><li><strong>原理:</strong> I2C 总线包含I2C适配器（I2C Adapter，即I2C控制器）和I2C客户端（I2C Client，即I2C从设备）。适配器提供I2C通信能力，客户端则代表具体的I2C设备。</li><li><strong>匹配过程:</strong> I2C设备的匹配通常有两种方式：<ul><li><strong>基于名称匹配:</strong> <code>i2c_client</code> 中的 <code>name</code> 字段与 <code>i2c_driver</code> 中的 <code>id_table</code> 里的 <code>name</code> 字段进行匹配。</li><li><strong>基于compatible字符串匹配 (更常用和推荐):</strong> <code>i2c_client</code> 中的 <code>of_node-&gt;compatible</code> 属性与 <code>i2c_driver</code> 中的 <code>of_match_table</code> 里的 <code>compatible</code> 字符串进行匹配。这种方式常用于设备树 (Device Tree) 中。</li></ul></li></ul></li></ul><p>除了这两者，还有：</p><ul><li><strong>PCI 总线 (PCI Bus):</strong> 用于连接高性能外设，如显卡、网卡、声卡等。</li><li><strong>USB 总线 (USB Bus):</strong> 用于连接各种USB设备，如U盘、键盘、鼠标、摄像头等。</li><li><strong>SPI 总线 (SPI Bus):</strong> 另一种串行通信协议，常用于连接传感器、FLASH存储器等。</li><li><strong>MMC&#x2F;SD 总线 (MMC&#x2F;SD Bus):</strong> 用于连接SD卡、eMMC存储器等。</li><li><strong>Input 总线 (Input Bus):</strong> 用于管理各种输入设备，如键盘、鼠标、触摸屏等。</li><li><strong>等等…</strong></li></ul><h3 id="2-它们之间有什么区别和联系？都有什么用？原理是什么？"><a href="#2-它们之间有什么区别和联系？都有什么用？原理是什么？" class="headerlink" title="2. 它们之间有什么区别和联系？都有什么用？原理是什么？"></a>2. 它们之间有什么区别和联系？都有什么用？原理是什么？</h3><p><strong>区别：</strong></p><ul><li><strong>物理特性:</strong><ul><li><strong>I2C:</strong> 是一种串行通信协议，有SDA（数据线）和SCL（时钟线）两根线。</li><li><strong>Platform:</strong> 是一种虚拟总线，没有对应的物理连接线，它抽象的是CPU内部或直接连接到CPU的设备。</li><li><strong>其他总线 (PCI, USB等):</strong> 都有各自的物理连接方式和通信协议。</li></ul></li><li><strong>设备类型:</strong><ul><li><strong>I2C:</strong> 专注于低速外设。</li><li><strong>Platform:</strong> 专注于SoC内部或直接连接的片上设备。</li><li><strong>PCI:</strong> 专注于高性能、高带宽设备。</li><li><strong>USB:</strong> 专注于即插即用、通用性强的设备。</li></ul></li></ul><p><strong>联系：</strong></p><ul><li><strong>统一的设备模型:</strong> 尽管有各种不同的总线，但 Linux 内核提供了一个统一的设备模型 (Device Model)。这个模型的目标是将设备和驱动进行分离，实现通用化和可移植性。</li><li><strong>Bus-Device-Driver 架构:</strong> 所有的总线都遵循 Bus-Device-Driver 架构。<ul><li><strong>Bus (总线):</strong> 负责管理其上的设备和驱动，提供匹配机制。</li><li><strong>Device (设备):</strong> 代表具体的硬件设备，包含设备的各种信息（地址、中断号、名称、ID等）。</li><li><strong>Driver (驱动):</strong> 负责与特定类型的设备进行交互，实现设备的各种功能。</li></ul></li><li><strong>Client-Driver 适配:</strong> 你说的没错！无论是 I2C、Platform 还是其他总线，它们的核心都是 <strong>Client (设备) 和 Driver (驱动) 进行适配</strong>。这里的 “Client” 对应于 “Device”。</li></ul><p><strong>都有什么用？</strong></p><ul><li><strong>抽象硬件差异:</strong> 不同的总线屏蔽了底层硬件的复杂性，提供统一的编程接口。</li><li><strong>代码复用:</strong> 驱动可以独立于具体的硬件平台开发，只要设备模型支持，就可以在不同的平台上运行。</li><li><strong>模块化管理:</strong> 允许设备和驱动作为独立的模块加载和卸载，提高了系统的灵活性。</li><li><strong>即插即用 (Plug-and-Play):</strong> 对于PCI、USB等支持热插拔的总线，设备模型可以实现设备的动态识别和加载驱动。</li></ul><p><strong>原理：</strong></p><p>Linux 设备模型的核心思想是 <strong>“将设备和驱动分离”</strong>。它通过 <code>struct device</code> 和 <code>struct device_driver</code> 这两个核心结构体来表示设备和驱动。</p><ul><li><strong><code>struct bus_type</code>:</strong> 定义了总线的属性和操作，包括设备的注册、驱动的注册、设备的遍历、驱动的匹配函数等。</li><li><strong><code>struct device</code>:</strong> 代表一个具体的硬件设备。它包含设备的通用属性（如名称、父设备、设备树节点等），以及特定总线的私有数据。</li><li><strong><code>struct device_driver</code>:</strong> 代表一个设备驱动。它包含驱动的通用属性（如名称、驱动所支持的设备ID表），以及驱动的操作函数（如 <code>probe</code>、<code>remove</code> 等）。</li></ul><p>当一个设备被注册到总线上时，总线会遍历所有已注册的驱动，尝试找到能够与该设备匹配的驱动。一旦匹配成功，就会调用驱动的 <code>probe</code> 函数来初始化设备。</p><h3 id="3-驱动不就是一份代码吗？为什么还有driver的代码和client的代码，两份？"><a href="#3-驱动不就是一份代码吗？为什么还有driver的代码和client的代码，两份？" class="headerlink" title="3. 驱动不就是一份代码吗？为什么还有driver的代码和client的代码，两份？"></a>3. 驱动不就是一份代码吗？为什么还有driver的代码和client的代码，两份？</h3><p>这是一个很好的问题，也是很多初学者容易混淆的地方。</p><p><strong>驱动 (Driver) 确实是“一份代码”，但这份代码是为了管理一类特定功能的硬件设备。</strong></p><p>为了实现驱动的通用性和可移植性，Linux 设备模型将驱动分成了两个逻辑部分：</p><ol><li><p><strong>设备 (Device) 的描述代码 (Client&#x2F;Platform Device):</strong></p><ul><li>这部分代码主要负责 <strong>描述硬件设备的信息</strong>，而不是实现设备的功能。它告诉内核：“这里有一个设备，它的类型是什么，它连接在哪个总线上，它的地址是多少，它需要哪些资源（如中断、内存区域）”。</li><li>这部分代码通常位于 <strong>板级文件 (board-specific file)</strong> 或 <strong>设备树 (Device Tree)</strong> 中。</li><li>例如：<ul><li>对于 Platform 设备，你会看到 <code>struct platform_device</code> 的定义，里面包含了设备的名称、资源等。</li><li>对于 I2C 设备，你会看到 <code>struct i2c_client</code> 的定义，或者在设备树中描述I2C设备的节点。</li></ul></li></ul></li><li><p><strong>驱动 (Driver) 的功能实现代码 (Platform Driver&#x2F;I2C Driver):</strong></p><ul><li>这部分代码才是真正意义上的 <strong>“驱动”</strong>。它负责 <strong>实现与特定类型设备进行交互的逻辑</strong>。</li><li>它包含了设备初始化（<code>probe</code> 函数）、数据传输、中断处理、电源管理等核心功能。</li><li>这部分代码通常位于 <strong>独立的驱动文件</strong> 中（例如：<code>drivers/char/xxx.c</code>, <code>drivers/i2c/chips/yyy.c</code>, <code>drivers/platform/zzz.c</code>）。</li><li>例如：<ul><li>对于 Platform 驱动，你会看到 <code>struct platform_driver</code> 的定义，其中包含了 <code>probe</code>、<code>remove</code> 等函数指针。</li><li>对于 I2C 驱动，你会看到 <code>struct i2c_driver</code> 的定义，同样包含 <code>probe</code>、<code>remove</code> 等函数指针。</li></ul></li></ul></li></ol><p><strong>为什么会有两份？</strong></p><ul><li><strong>分离关注点 (Separation of Concerns):</strong><ul><li>将设备描述和驱动功能分离，使得驱动代码更加通用。同一个驱动可以在不同的硬件平台上使用，只要这些平台能够正确描述出该设备。</li><li>板级厂商只需要描述其硬件设备的特性，而驱动开发者可以专注于实现设备功能。</li></ul></li><li><strong>可移植性 (Portability):</strong><ul><li>驱动代码可以独立于具体的硬件平台编译和加载。</li><li>当硬件平台发生变化时，可能只需要修改设备描述部分（如设备树），而无需修改驱动代码本身。</li></ul></li><li><strong>模块化 (Modularity):</strong><ul><li>设备和驱动可以作为独立的模块动态加载和卸载，方便开发和调试。</li></ul></li><li><strong>即插即用 (Plug and Play):</strong><ul><li>当设备被发现时（例如插入USB设备），内核可以根据设备的描述信息自动寻找并加载对应的驱动。</li></ul></li></ul><h3 id="4-Match-的过程是什么样子的呢？"><a href="#4-Match-的过程是什么样子的呢？" class="headerlink" title="4. Match 的过程是什么样子的呢？"></a>4. Match 的过程是什么样子的呢？</h3><p>匹配 (Matching) 是设备模型中最核心的机制之一。当一个设备被注册到总线上时，内核会触发匹配过程，寻找能够驱动该设备的驱动。</p><p><strong>通用匹配流程 (以 Platform 总线为例)：</strong></p><ol><li><strong>设备注册:</strong> 当内核或某个模块发现并注册一个 <code>platform_device</code> 到 <code>platform_bus</code> 上时，匹配过程开始。<ul><li>这通常发生在内核启动时，或者通过设备树动态解析设备。</li><li><code>platform_device_register()</code> 函数会被调用。</li></ul></li><li><strong>遍历驱动:</strong> <code>platform_bus</code> 会遍历所有已经注册到它上面的 <code>platform_driver</code>。</li><li><strong>调用匹配函数:</strong> 对于每一个 <code>platform_driver</code>，总线会调用其内部的 <code>match</code> 函数（对于 Platform 总线，通常是 <code>platform_match()</code>）。</li><li><strong>匹配逻辑:</strong> <code>match</code> 函数会根据预定的规则（通常是名称匹配或 compatible 字符串匹配）来判断当前设备是否与当前驱动兼容。<ul><li><strong>名称匹配:</strong> <code>platform_device-&gt;name == platform_driver-&gt;driver.name</code>。</li><li><strong>设备树 compatible 匹配 (更常用):</strong> <code>platform_device-&gt;of_node-&gt;compatible</code> 属性与 <code>platform_driver-&gt;of_match_table</code> 中的 <code>compatible</code> 字符串进行比较。</li></ul></li><li><strong>成功匹配:</strong> 如果 <code>match</code> 函数返回成功（表示设备和驱动匹配），那么总线就会将该设备与该驱动关联起来。</li><li><strong>调用 <code>probe</code> 函数:</strong> 接着，内核会调用匹配成功的 <code>platform_driver</code> 的 <code>probe</code> 函数。<ul><li><code>probe</code> 函数是驱动的核心，它负责初始化设备、请求资源、注册中断、创建设备节点等等。</li><li>如果 <code>probe</code> 函数成功返回，表示设备驱动加载成功；如果返回错误码，则表示加载失败。</li></ul></li></ol><p><strong>I2C 总线匹配流程：</strong></p><p>I2C 总线的匹配与 Platform 类似，但它有自己的 <code>i2c_bus_type</code> 和匹配函数。</p><ol><li><strong>I2C 适配器注册:</strong> I2C 控制器作为 Platform 设备注册后，其 Platform 驱动会注册 <code>i2c_adapter</code>，这代表了一个可用的 I2C 总线。</li><li><strong>I2C 客户端注册:</strong> I2C 设备的描述（通常在设备树中）被解析后，会创建一个 <code>i2c_client</code> 结构体并将其注册到对应的 <code>i2c_adapter</code> 上。</li><li><strong>遍历 I2C 驱动:</strong> I2C 总线会遍历所有已经注册的 <code>i2c_driver</code>。</li><li><strong>调用匹配函数:</strong> I2C 总线会调用其内部的匹配函数 (<code>i2c_device_match()</code>)。</li><li><strong>匹配逻辑:</strong><ul><li><strong>ID 表匹配:</strong> <code>i2c_driver-&gt;id_table</code> 字段中的 <code>name</code> 成员与 <code>i2c_client-&gt;name</code> 进行匹配。</li><li><strong>设备树 compatible 匹配 (更常用):</strong> <code>i2c_client-&gt;dev.of_node-&gt;compatible</code> 属性与 <code>i2c_driver-&gt;driver.of_match_table</code> 中的 <code>compatible</code> 字符串进行比较。</li></ul></li><li><strong>成功匹配:</strong> 匹配成功后，调用 <code>i2c_driver</code> 的 <code>probe</code> 函数。</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>Linux 设备模型的核心是 Bus-Device-Driver 架构，旨在将设备和驱动分离，实现代码的通用性和可移植性。</strong></li><li><strong>总线 (Bus) 负责管理设备和驱动的注册与匹配。</strong></li><li><strong>设备 (Device&#x2F;Client) 描述了硬件的特性和资源。</strong></li><li><strong>驱动 (Driver) 实现了与设备交互的逻辑。</strong></li><li><strong>匹配过程是总线根据预定的规则（名称或 compatible 字符串）将设备和驱动关联起来的过程，成功后会调用驱动的 <code>probe</code> 函数。</strong></li></ul><p>希望这些解释能帮助你更好地理解 Linux 设备驱动的 Bus-Device-Driver 架构！这是一个值得深入学习的领域，一旦掌握，你会对操作系统如何与硬件交互有更深刻的理解。</p>]]></content:encoded>
      
      
      
      <category domain="https://GoKo-Son626.github.io/tags/linux-dirvers/">linux-dirvers</category>
      
      
      <comments>https://goko-son626.github.io/post/wds-IIC.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>start-kerneling</title>
      <link>https://goko-son626.github.io/post/start-kerneling.html</link>
      <guid>https://goko-son626.github.io/post/start-kerneling.html</guid>
      <pubDate>Mon, 19 May 2025 19:02:36 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;前言介绍….&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>前言介绍….</strong></em></li></ul><span id="more"></span>]]></content:encoded>
      
      
      
      <category domain="https://GoKo-Son626.github.io/tags/kernel-start/">kernel-start</category>
      
      
      <comments>https://goko-son626.github.io/post/start-kerneling.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>riscv-toolchains</title>
      <link>https://goko-son626.github.io/post/riscv-toolchains.html</link>
      <guid>https://goko-son626.github.io/post/riscv-toolchains.html</guid>
      <pubDate>Sun, 18 May 2025 08:30:56 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;riscv-toolchain介绍&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>riscv-toolchain介绍</strong></em></li></ul><span id="more"></span><p>GNU 工具链的<strong>三元组</strong>（triplet），格式是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&lt;目标架构&gt;-&lt;供应商&gt;-&lt;目标系统&gt;<br></code></pre></td></tr></table></figure><p>riscv64-unknown-elf-：<br>        适用于 riscv64 架构、面向嵌入式&#x2F;裸机平台（使用 newlib 标准库）的工具链。<br>        可从 riscv-collab&#x2F;riscv-gnu-toolchain 构建。<br>        不推荐通过包管理工具安装此编译链。发行版软件源中的此工具链常常缺少关键的 newlib 标准库。<br>riscv64-unknown-linux-gnu-：<br>        适用于 riscv64 架构、面向 linux-gnu 平台（使用 glibc 标准库）的工具链，可以与riscv64-linux-gnu- 相互替换。可从 riscv-collab&#x2F;riscv-gnu-toolchain 构建。<br>riscv64-linux-gnu-：<br>        适用于 riscv64 架构、面向 linux-gnu 平台（使用 glibc 标准库）的工具链。<br>        可通过包管理工具（如 Ubuntu 的 apt）安装。受限于发行版软件源限制，其编译器版本可能较老。</p>]]></content:encoded>
      
      
      
      <category domain="https://GoKo-Son626.github.io/tags/riscv-toolchain/">riscv-toolchain</category>
      
      
      <comments>https://goko-son626.github.io/post/riscv-toolchains.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>qspinlock</title>
      <link>https://goko-son626.github.io/post/qspinlock.html</link>
      <guid>https://goko-son626.github.io/post/qspinlock.html</guid>
      <pubDate>Sat, 03 May 2025 01:25:24 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;qspinlock is a hybrid spinlock combining the fairness of ticket locks with the scalability of MCS locks: it uses only 4 bytes under low contention, falls back to an MCS queue under heavy load, and optimizes the second contender with a pending bit. It improves fairness and scalability but should not be enabled on RISC-V platforms lacking Ziccrse or Zabha.&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>qspinlock is a hybrid spinlock combining the fairness of ticket locks with the scalability of MCS locks: it uses only 4 bytes under low contention, falls back to an MCS queue under heavy load, and optimizes the second contender with a pending bit. It improves fairness and scalability but should not be enabled on RISC-V platforms lacking Ziccrse or Zabha.</strong></em></li></ul><span id="more"></span><h4 id="1-传统spinlock："><a href="#1-传统spinlock：" class="headerlink" title="1. 传统spinlock："></a>1. 传统spinlock：</h4><ul><li>多个等待的 CPU 核心中，谁先获得锁并无保证，存在公平性问题，同时缓存一致性开销大（如MESI），CPU核心越大，cache需求越厉害，缺乏可扩展性</li></ul><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/spinlock/image-8.png" alt="alt text"></p><h4 id="2-Ticket-spinlock"><a href="#2-Ticket-spinlock" class="headerlink" title="2. Ticket spinlock"></a>2. Ticket spinlock</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TICKET_NEXT16</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>u32 lock;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">raw_tickets</span> &#123;</span><br><span class="hljs-comment">/* little endian */</span><br>u16 owner;<br>u16 next;<br>&#125; tickets;<br>&#125;;<br>&#125; <span class="hljs-type">arch_spinlock_t</span>;<br><br>my_ticket = atomic_fetch_inc(&amp;lock-&gt;tickets.next);<br><br> <span class="hljs-keyword">while</span> (lock-&gt;tickets.owner != my_ticket)<br>    cpu_relax();<br></code></pre></td></tr></table></figure><ul><li>解决了公平问题，防止某些 CPU 永远得不到锁，但所有核都轮询同一个owner变量，read cache line成热点，限制扩展性</li></ul><h4 id="3-MCS-lock"><a href="#3-MCS-lock" class="headerlink" title="3. MCS lock"></a>3. MCS lock</h4><ul><li>本质上是一种基于链表结构的自旋锁，每个CPU有一个对应的节点(锁的副本)，基于各自不同的副本变量进行等待，锁本身是共享的，但队列节点是线程自己维护的，每个CPU只需要查询自己对应的本地cache line，仅在这个变量发生变化的时候，才需要读取内存和刷新这条cache line, 不像 classic&#x2F;ticket对共享变量进行spin</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">int</span> locked; <span class="hljs-comment">/* 1 if lock acquired */</span><br><span class="hljs-type">int</span> count;  <span class="hljs-comment">/* nesting count, see qspinlock.c */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mcs_spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mcs_spinlock **lock, <span class="hljs-keyword">struct</span> mcs_spinlock *node)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">prev</span>;</span><br><br><span class="hljs-comment">/* Init node */</span><br>node-&gt;locked = <span class="hljs-number">0</span>;<br>node-&gt;next   = <span class="hljs-literal">NULL</span>;<br><br>prev = xchg(lock, node);<br><span class="hljs-keyword">if</span> (likely(prev == <span class="hljs-literal">NULL</span>)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>WRITE_ONCE(prev-&gt;next, node);<br><br><span class="hljs-comment">/* Wait until the lock holder passes the lock down. */</span><br>arch_mcs_spin_lock_contended(&amp;node-&gt;locked);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个 CPU 线程创建的node 是独立的，每个线程都有自己的 node 实例。但是结构体中多了一个指针使结构体变大了，导致了“内存开销问题”：MCS 锁把竞争带来的 cache-line 抖动降低了，但牺牲了一些内存和部分结构管理的成本。</li></ul><h4 id="4-qspinlock"><a href="#4-qspinlock" class="headerlink" title="4. qspinlock"></a>4. qspinlock</h4><p><strong>include&#x2F;asm-generic&#x2F;qspinlock_types.h:</strong> 锁数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qspinlock</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-type">atomic_t</span> val;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * By using the whole 2nd least significant byte for the</span><br><span class="hljs-comment">                 * pending bit, we can allow better optimization of the lock</span><br><span class="hljs-comment">                 * acquisition for the pending bit holder.</span><br><span class="hljs-comment">                 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __LITTLE_ENDIAN</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>                        u8      locked;<br>                        u8      pending;<br>                &#125;;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>                        u16     locked_pending;<br>                        u16     tail;<br>                &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>                        u16     tail;<br>                        u16     locked_pending;<br>                &#125;;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>                        u8      reserved[<span class="hljs-number">2</span>];<br>                        u8      pending;<br>                        u8      locked;<br>                &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;;<br>&#125; <span class="hljs-type">arch_spinlock_t</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Initializier</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED       &#123; &#123; .val = ATOMIC_INIT(0) &#125; &#125;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Bitfields in the atomic value:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When NR_CPUS &lt; 16K</span><br><span class="hljs-comment"> *  0- 7: locked byte</span><br><span class="hljs-comment"> *     8: pending</span><br><span class="hljs-comment"> *  9-15: not used</span><br><span class="hljs-comment"> * 16-17: tail index</span><br><span class="hljs-comment"> * 18-31: tail cpu (+1)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When NR_CPUS &gt; = 16K</span><br><span class="hljs-comment"> *  0- 7: locked byte</span><br><span class="hljs-comment"> *     8: pending</span><br><span class="hljs-comment"> *  9-10: tail index</span><br><span class="hljs-comment"> * 11-31: tail cpu (+1)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_SET_MASK(type)       (((1U &lt;&lt; _Q_ ## type ## _BITS) - 1)\</span><br><span class="hljs-meta">                                      &lt;&lt; _Q_ ## type ## _OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_LOCKED_OFFSET        0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_LOCKED_BITS          8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_LOCKED_MASK          _Q_SET_MASK(LOCKED)</span><br></code></pre></td></tr></table></figure><p><strong>When NR_CPUS &lt; 16K：</strong><br><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/spinlock/image-7.png" alt="alt text"></p><ul><li><code>locked</code>：用来表示这个锁是否被人持有（0：无，1：有）</li><li><code>pending</code>：可以理解为最优先持锁位，即当unlock之后只有这个位的CPU最先持锁，也有1和0</li><li><code>tail</code>：有idx+CPU构成，用来标识等待队列的最后一个节点。</li><li><code>tail_idx</code>：就是index，它作为mcs_nodes数组的下标使用</li><li><code>tail_CPU</code>：用来表示CPU的编号+1，+1因为规定tail为0的时候表示等待队列中没有成员</li></ul><p><strong>kernel&#x2F;locking&#x2F;mcs_spinlock.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span>;</span><br>        <span class="hljs-type">int</span> locked; <span class="hljs-comment">/* 1 if lock acquired */</span><br>        <span class="hljs-type">int</span> count;  <span class="hljs-comment">/* nesting count, see qspinlock.c */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>locked = 1</code>:只是说锁传到了当前加节点，但是当前节点还需要主动申请锁(qspinlock -&gt; locked &#x3D; 1)<br><code>count</code>：针对四种上下文用于追踪当前用了第几个 node（即 idx），最大为4,不够用时就fallback不排队直接自旋</p><p><strong>kernel&#x2F;locking&#x2F;qspinlock.c:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODES       4</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qnode</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> <span class="hljs-title">mcs</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PARAVIRT_SPINLOCKS</span><br>        <span class="hljs-type">long</span> reserved[<span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Per-CPU queue node structures; we can never have more than 4 nested</span><br><span class="hljs-comment"> * contexts: task, softirq, hardirq, nmi.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Exactly fits one 64-byte cacheline on a 64-bit architecture.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * PV doubles the storage and uses the second cacheline for PV state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">DEFINE_PER_CPU_ALIGNED</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> qnode, qnodes[MAX_NODES])</span>;<br></code></pre></td></tr></table></figure><ul><li>一个 CPU 上可能嵌套多个锁, <code>qnodes</code>针对四种上下文情况下，例：进程上下文中发生中断后再次获取锁</li><li>PER_CPU的优点是快，可防止抢锁时再mallock或临时分配导致延迟，成本等问题</li></ul><p><strong>申请锁：</strong></p><ol><li>快速申请<br><strong>include&#x2F;asm-generic&#x2F;qspinlock.h</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * queued_spin_lock - acquire a queued spinlock</span><br><span class="hljs-comment"> * @lock: Pointer to queued spinlock structure</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">queued_spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> qspinlock *lock)</span><br>&#123;<br><span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (likely(atomic_try_cmpxchg_acquire(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL)))<br><span class="hljs-keyword">return</span>;<br><br>queued_spin_lock_slowpath(lock, val);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/spinlock/image-9.png" alt="alt text"></p><ol start="2"><li>中速申请</li></ol><ul><li>快速申请失败，queue中为空时，设置锁的pending位</li><li>再次检测（检查中间是否有其它cpu进入）</li><li>一直循环检测locked位</li><li>当locked位为0时，清除pending位获得锁</li></ul><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/spinlock/image-11.png" alt="alt text"></p><ol start="3"><li>慢速申请</li></ol><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/spinlock/image-12.png" alt="alt text"></p><table><thead><tr><th>申请</th><th>操作</th></tr></thead><tbody><tr><td>快速申请</td><td>这个锁当前没有人持有，直接通过cmpxchg()设置locked域即可获取了锁</td></tr><tr><td>中速申请</td><td>锁已经被人持有，但是MCS链表没有其他人，有且仅有一个人在等待这个锁。设置pending域，表示是第一顺位继承者，自旋等待lock-&gt; locked清0，即锁持有者释放锁</td></tr><tr><td>慢速申请</td><td>进入到queue中自旋等待，若为队列头（队列中没有等待的cpu），说明它已排到最前，可以开始尝试获取锁；否则，它会自旋等待前一个节点释放锁，并通知它可以尝试获取锁了</td></tr></tbody></table><p><strong>end:</strong></p><ul><li><p>如果只有1个或2个CPU试图获取锁，那么只需要一个4字节的qspinlock就可以了，其所占内存的大小和ticket spinlock一样。当有3个以上的CPU试图获取锁，则需要(N-2)个MCS node</p></li><li><p>qspinlock中加入”pending”位域的意义，如果是两个CPU试图获取锁，那么第二个CPU只需要简单地设置”pending”为1，而不用创建一个MCS node</p></li><li><p>试图加锁的CPU数目超过3个，使用ticket spinlock机制就会造成多个CPU的cache line刷新的问题，而qspinlock可以利用MCS node队列来解决这个问题</p></li><li><p>在多核争用严重场景下，qspinlock 让等待者在本地内存区域自旋，减少了锁的缓存抖动和对总线的竞争消耗</p></li><li><p>RISCV_QUEUED_SPINLOCKS 只应在平台具有 Zabha 或 Ziccrse 时启用，不支持的情况不要选用</p></li><li><p>优先级反转问题，queue会保证了FIFO提高了公平性，但它无法感知任务的优先级，可能因为排在队列前方的低优先级任务未释放锁而发生等待，从而导致 优先级反转</p></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://GoKo-Son626.github.io/tags/riscv/">riscv</category>
      
      
      <comments>https://goko-son626.github.io/post/qspinlock.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo博客搭建</title>
      <link>https://goko-son626.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://goko-son626.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html</guid>
      <pubDate>Thu, 01 May 2025 05:25:09 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;使用hexo和GitHub Pagtes部署一个自己的博客&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>使用hexo和GitHub Pagtes部署一个自己的博客</strong></em></li></ul><span id="more"></span><h3 id="1-安装并初始化Hexo"><a href="#1-安装并初始化Hexo" class="headerlink" title="1. 安装并初始化Hexo"></a>1. 安装并初始化Hexo</h3><ul><li><ol><li>安装 Hexo CLI</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>初始化博客项目目录</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mkdir my-blog &amp;&amp; cd my-blog<br>hexo init<br>npm install<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>本地预览</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo server<br></code></pre></td></tr></table></figure><ul><li>启动本地服务：在浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看效果</li></ul><h3 id="2-配置-GitHub-Pages-部署"><a href="#2-配置-GitHub-Pages-部署" class="headerlink" title="2.  配置 GitHub Pages 部署"></a>2.  配置 GitHub Pages 部署</h3><ul><li><ol><li>创建GitHub仓库</li></ol><ul><li>创建一个仓库，名字叫 你的GitHub用户名.github.io</li><li>比如你是 goko，就叫 goko.github.io</li></ul></li><li><ol start="2"><li>安装部署插件</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>修改 _config.yml（根目录下）添加部署配置：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">deploy:<br>  type: git<br>  # repo建议使用SSH, SSH免密<br>  repo: https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git<br>  branch: main  # 或者 master，看你的默认分支<br></code></pre></td></tr></table></figure><ul><li><ol start="4"><li>生成并部署博客</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><h3 id="3-域名-com-绑定"><a href="#3-域名-com-绑定" class="headerlink" title="3. 域名(.com)绑定"></a>3. 域名(<xxxx>.com)绑定</xxxx></h3><ul><li><ol><li>添加域名(在my-blog下)</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">echo &quot;&lt;xxxx&gt;.com&quot; &gt; source/CNAME<br># 或者可以：echo &quot;www.&lt;xxxx&gt;.com&quot; &gt; source/CNAME<br># 只能添加一个，而且两个需要添加不同的域名解析（如下）<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>重新部署</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>设置 DNS 解析指向 GitHub Pages</li></ol></li></ul><p><strong>A. 使用裸域名（apex 域名）goku72.com</strong></p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>@</td><td>185.199.108.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.109.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.110.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.111.153</td><td>GitHub Pages IP</td></tr></tbody></table><p>example aliyun:</p><ol><li>选择业务需求: 将网站域名解析到服务器IPv4地址</li><li>选择网站域名(主机记录): <xxxx>.com（对应设置“@”主机记录）</xxxx></li><li>填写 IP（记录值）：</li></ol><ul><li>在输入框里粘贴以下四行（每一行一个 IP）：</li><li><pre><code>  &gt; 185.199.109.153  &gt; 185.199.108.153  &gt; 185.199.110.153  &gt; 185.199.111.153</code></pre></li></ul><hr><p><strong>B. 使用 <a href="http://www.goku72.com/">www.goku72.com</a> 作为主域名</strong></p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th><th>说明</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>&lt;github用户名&gt;.github.io.</td><td>指向你的 GitHub 用户页仓库</td></tr></tbody></table><p>example aliyun:</p><ol><li>选择业务需求: 将网站域名解析到另外的目标域名</li><li>选择网站域名(主机记录): www.<xxxx>.com（对应设置“www”主机记录）</xxxx></li><li>填写 IP（记录值）：&lt;github用户名&gt;.github.io. (最有有一个符号”.”)</li></ol><h3 id="4-设置主题"><a href="#4-设置主题" class="headerlink" title="4. 设置主题"></a>4. 设置主题</h3><ul><li>cd my-blog&#x2F;themes</li><li>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> butterfly</li><li>修改_config.yml: <ul><li>theme: butterfly</li></ul></li><li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</li></ul><p><strong>更多主题</strong>：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p><strong>注：</strong></p><ul><li>如果AB两个方式都添加了，只需要在 Hexo 项目的 source&#x2F;CNAME 文件中写 www.<xxxx>.com，GitHub Pages 就会自动把 goku72.com 重定向过去，无需额外设置！</xxxx></li><li>后续换域名只需要：阿里云重新解析 + 修改 source&#x2F;CNAME + 重新部署 Hexo，就能完成域名迁移。</li><li>有些主题可能需要下载插件</li></ul>]]></content:encoded>
      
      
      
      <category domain="https://GoKo-Son626.github.io/tags/hexo/">hexo</category>
      
      
      <comments>https://goko-son626.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>

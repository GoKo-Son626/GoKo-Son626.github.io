<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>GoKo&#39;s blog</title>
    <link>https://GoKo-Son626.github.io/</link>
    
    <atom:link href="https://goko-son626.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 03 Aug 2025 07:07:30 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>xxx</title>
      <link>https://goko-son626.github.io/post/xxx.html</link>
      <guid>https://goko-son626.github.io/post/xxx.html</guid>
      <pubDate>Sun, 03 Aug 2025 07:06:47 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;前言介绍….&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>前言介绍….</strong></em></li></ul><span id="more"></span><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3>]]></content:encoded>
      
      
      
      
      <comments>https://goko-son626.github.io/post/xxx.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RISC-V toolchain</title>
      <link>https://goko-son626.github.io/post/riscv-toolchains.html</link>
      <guid>https://goko-son626.github.io/post/riscv-toolchains.html</guid>
      <pubDate>Sun, 18 May 2025 08:30:56 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;在 RISC-V 开发中, 交叉编译工具链允许我们在一个平台（如 x86 主机）上，为另一个平台（如RISC-V 开发板）生成可执行代码。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>在 RISC-V 开发中, 交叉编译工具链允许我们在一个平台（如 x86 主机）上，为另一个平台（如RISC-V 开发板）生成可执行代码。</strong></em></li></ul><span id="more"></span><h3 id="核心概念：工具链的“三元组”-Triplet"><a href="#核心概念：工具链的“三元组”-Triplet" class="headerlink" title="核心概念：工具链的“三元组” (Triplet)"></a>核心概念：工具链的“三元组” (Triplet)</h3><p>你经常会看到像 <code>riscv64-unknown-linux-gnu-</code> 这样的名称，这就是工具链的“三元组”，其标准格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;arch&gt;-&lt;vendor&gt;-&lt;os&gt;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;arch&gt;</code> (架构)：指定目标 CPU 架构，例如 <code>riscv64</code> 或 <code>riscv32</code>。</li><li><code>&lt;vendor&gt;</code> (供应商)：通常是 <code>unknown</code> 或公司名。</li><li><code>&lt;os&gt;</code> (操作系统&#x2F;环境)：这是<strong>最关键</strong>的部分，它决定了工具链的目标环境和使用的 C 标准库 (libc)。最常见的两个是：<ul><li><code>elf</code>: 面向<strong>裸机 (Bare-metal)</strong> 或<strong>嵌入式实时操作系统 (RTOS)</strong>。</li><li><code>linux-gnu</code>: 面向<strong>完整的 GNU&#x2F;Linux 操作系统</strong>。</li></ul></li></ul><h3 id="两大主流工具链详解"><a href="#两大主流工具链详解" class="headerlink" title="两大主流工具链详解"></a>两大主流工具链详解</h3><h4 id="1-riscv64-unknown-elf"><a href="#1-riscv64-unknown-elf" class="headerlink" title="1. riscv64-unknown-elf"></a>1. <code>riscv64-unknown-elf</code></h4><p>用于<strong>裸机和嵌入式</strong>开发的标准工具链。</p><ul><li><strong>目标系统</strong>: 没有任何操作系统的环境（裸机），或者使用了轻量级实时操作系统（如 FreeRTOS, RT-Thread）的环境。</li><li><strong>C 标准库 (Libc)</strong>: 使用 <strong>Newlib</strong>。<ul><li><strong>Newlib</strong> 是一个轻量级的 C 库，专为嵌入式系统设计。它只提供最基础的 C 语言函数（如 <code>strcpy</code>, <code>printf</code>），并且不依赖任何操作系统的系统调用（Syscall）。如果需要文件操作或内存管理，需要实现底层的“桩函数”(stubs)。</li></ul></li><li><strong>应用场景</strong>:<ul><li>编写 Bootloader（如 U-Boot）。</li><li>开发 RISC-V 的“特权二进制接口”固件（如 OpenSBI）。</li><li>为微控制器 (MCU) 编写固件。</li><li>开发简单的操作系统内核。</li></ul></li></ul><h4 id="2-riscv64-linux-gnu"><a href="#2-riscv64-linux-gnu" class="headerlink" title="2. riscv64-linux-gnu"></a>2. <code>riscv64-linux-gnu</code></h4><p>用于<strong>在 RISC-V 平台上开发 Linux 应用</strong>的工具链。</p><ul><li><strong>目标系统</strong>: 运行完整 Linux 内核的系统。</li><li><strong>C 标准库 (Libc)</strong>: 使用 <strong>glibc</strong> (GNU C Library)。<ul><li><strong>glibc</strong> 是功能完备的标准 C 库，提供了丰富的 POSIX API 支持（如 <code>fork</code>, <code>pthread</code>, 文件系统操作等）。它深度依赖 Linux 内核提供的系统调用来完成工作。</li></ul></li><li><strong>典型应用场景</strong>:<ul><li>编译一个标准的 C&#x2F;C++ 应用程序（如 Nginx, Redis），让它运行在 RISC-V 架构的 Linux 发行版上（如 Ubuntu, Debian for RISC-V）。</li><li>开发 Linux 用户态驱动或服务程序。</li></ul></li></ul><blockquote><p><strong>Tip</strong>: <code>riscv64-unknown-linux-gnu-</code> 和 <code>riscv64-linux-gnu-</code> 在功能上是等价的，可以互换使用。<code>unknown</code> 字段在这里没有实际影响。</p></blockquote><hr><h3 id="如何获取和安装工具链"><a href="#如何获取和安装工具链" class="headerlink" title="如何获取和安装工具链"></a>如何获取和安装工具链</h3><h4 id="方式一：使用包管理器-简单快捷"><a href="#方式一：使用包管理器-简单快捷" class="headerlink" title="方式一：使用包管理器 (简单快捷)"></a>方式一：使用包管理器 (简单快捷)</h4><p>对于 <code>linux-gnu</code> 工具链，这是最简单的方法。以 Ubuntu&#x2F;Debian 为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 C 和 C++ 交叉编译器</span><br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install gcc-riscv64-linux-gnu g++-riscv64-linux-gnu<br></code></pre></td></tr></table></figure><ul><li><strong>优点</strong>: 安装简单，一键搞定。</li><li><strong>缺点</strong>: 版本可能不是最新的，且通常不提供 <code>elf</code> 版本的工具链。</li></ul><h4 id="方式二：从源码编译-推荐，灵活且最新"><a href="#方式二：从源码编译-推荐，灵活且最新" class="headerlink" title="方式二：从源码编译 (推荐，灵活且最新)"></a>方式二：从源码编译 (推荐，灵活且最新)</h4><p>获取<strong>最新版本</strong>工具链（包括 <code>elf</code> 和 <code>linux-gnu</code>）的<strong>最佳方式</strong>。</p><ol><li><p><strong>克隆官方仓库</strong><br><code>--recursive</code> 参数至关重要，它会同时下载 <code>gcc</code>, <code>binutils</code> 等所有子模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --recursive https://github.com/riscv-collab/riscv-gnu-toolchain<br><span class="hljs-built_in">cd</span> riscv-gnu-toolchain<br></code></pre></td></tr></table></figure></li><li><p><strong>配置与编译</strong><br>需要指定安装路径 (<code>--prefix</code>) 和目标架构 (<code>--with-arch</code>, <code>--with-abi</code>)。</p><ul><li><strong>编译 <code>elf</code> 工具链 (用于裸机):</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个安装目录</span><br><span class="hljs-built_in">mkdir</span> -p /opt/riscv-elf<br><span class="hljs-comment"># 配置: 其中 `rv64gc` 指支持 64 位基础整数指令集（I）、乘除法（M）、原子（A）、浮点（F、D）、压缩（C）等扩展；</span><br><span class="hljs-comment">#       `lp64d` 表示 long 和 pointer 为 64 位，使用 double 精度浮点。</span><br>./configure --prefix=/opt/riscv-elf --with-arch=rv64gc --with-abi=lp64d<br><span class="hljs-comment"># 编译 (-j`nproc` 使用所有CPU核心加速)</span><br>make -j$(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure></li><li><strong>编译 <code>linux-gnu</code> 工具链 (用于Linux):</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个安装目录</span><br><span class="hljs-built_in">mkdir</span> -p /opt/riscv-linux<br><span class="hljs-comment"># 配置</span><br>./configure --prefix=/opt/riscv-linux<br><span class="hljs-comment"># 编译: make linux 是一个便捷的快捷方式，它等同于为 configure 脚本提供了一套适用于编译 Linux 用户态程序的默认参数。</span><br>make -j$(<span class="hljs-built_in">nproc</span>) linux<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：<code>make linux</code> 是编译 <code>linux-gnu</code> 工具链的快捷方式。</p></blockquote></li></ul></li><li><p><strong>添加到环境变量</strong><br>为了方便使用，将工具链的 <code>bin</code> 目录添加到 <code>PATH</code>。编辑你的 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加这行到文件末尾 (根据你编译的类型选择)</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/opt/riscv-elf/bin:<span class="hljs-variable">$PATH</span>&quot;</span>  <span class="hljs-comment"># For elf toolchain</span><br><span class="hljs-comment"># export PATH=&quot;/opt/riscv-linux/bin:$PATH&quot; # For linux toolchain</span><br><br><span class="hljs-comment"># 使配置生效</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hello.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, RISC-V World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用-elf-工具链编译"><a href="#使用-elf-工具链编译" class="headerlink" title="使用 elf 工具链编译"></a>使用 <code>elf</code> 工具链编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译</span><br>riscv64-unknown-elf-gcc -o hello.elf hello.c<br><br><span class="hljs-comment"># 查看文件类型</span><br>file hello.elf<br><span class="hljs-comment"># 输出会类似:</span><br><span class="hljs-comment"># hello.elf: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped</span><br></code></pre></td></tr></table></figure><p>这个 <code>hello.elf</code> 是一个<strong>静态链接的裸机程序</strong>。它不能直接在 <strong>x86 Linux</strong> 主机上运行，也不能在 RISC-V Linux 系统上直接运行，因为它缺少操作系统加载器所需的信息。它需要被烧录到裸机环境或通过模拟器（如 QEMU-system）加载执行。</p><blockquote><p>这个 <code>hello.elf</code> 文件虽然是标准的 ELF 格式，但它与 Linux 可执行文件有本质区别：</p><ul><li><strong>不含 <code>INTERP</code> 段</strong>：它不指定动态链接器，因为它不依赖任何动态库。</li><li><strong>静态链接</strong>: 它静态链接了轻量级的 <code>newlib</code> C 库，而非 <code>glibc</code>。</li><li><strong>无系统调用</strong>: 其中的 <code>printf</code> 函数最终依赖开发者实现的底层 I&#x2F;O 桩函数（如通过 UART 发送字符），而不是 Linux 的 <code>write</code> 系统调用。</li><li><strong>不同的程序入口</strong>: 它的启动代码 (<code>_start</code>) 负责初始化 C 运行环境后调用 <code>main</code>，但 <code>main</code> 返回后程序通常会进入死循环，因为它没有“退出”到操作系统的概念。</li></ul></blockquote><h4 id="使用-linux-gnu-工具链编译"><a href="#使用-linux-gnu-工具链编译" class="headerlink" title="使用 linux-gnu 工具链编译"></a>使用 <code>linux-gnu</code> 工具链编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译</span><br>riscv64-linux-gnu-gcc -o hello.linux hello.c<br><br><span class="hljs-comment"># 查看文件类型</span><br>file hello.linux<br><span class="hljs-comment"># 输出会类似:</span><br><span class="hljs-comment"># hello.linux: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, for GNU/Linux 4.15.0, not stripped</span><br></code></pre></td></tr></table></figure><p>这个 <code>hello.linux</code> 是一个<strong>动态链接的 Linux 程序</strong>。它需要一个 RISC-V Linux 环境来运行，因为它依赖于该环境中的动态链接器 (<code>ld-linux-riscv64-lp64d.so.1</code>) 和 glibc 库。</p><hr><h3 id="总结：我该用哪个？"><a href="#总结：我该用哪个？" class="headerlink" title="总结：我该用哪个？"></a>总结：我该用哪个？</h3><table><thead><tr><th>特性</th><th><code>riscv64-unknown-elf</code></th><th><code>riscv64-linux-gnu</code></th></tr></thead><tbody><tr><td><strong>目标平台</strong></td><td><strong>裸机 (Bare-metal)</strong>、RTOS</td><td><strong>GNU&#x2F;Linux 系统</strong></td></tr><tr><td><strong>C 库</strong></td><td><code>newlib</code> (轻量级，无 OS 依赖)</td><td><code>glibc</code> (功能完备，依赖 Linux 内核)</td></tr><tr><td><strong>核心用途</strong></td><td>固件、Bootloader、RTOS 应用、简单操作系统内核</td><td>编译可在 RISC-V Linux 上运行的应用程序</td></tr><tr><td><strong>选择场景</strong></td><td>“为一块开发板从零开始写程序。”</td><td>“在启动的 Linux 上面运行软件。”</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/risc-v/">risc-v</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/risc-v/Toolchain/">Toolchain</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/risc-v/">risc-v</category>
      
      
      <comments>https://goko-son626.github.io/post/riscv-toolchains.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>qspinlock</title>
      <link>https://goko-son626.github.io/post/qspinlock.html</link>
      <guid>https://goko-son626.github.io/post/qspinlock.html</guid>
      <pubDate>Sat, 03 May 2025 01:25:24 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;qspinlock 是一种为现代多核系统设计的先进混合自旋锁。它巧妙地融合了两种经典锁的优点：既继承了票据锁（ticket lock）的公平性，又借鉴了 MCS 锁优异的可扩展性。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>qspinlock 是一种为现代多核系统设计的先进混合自旋锁。它巧妙地融合了两种经典锁的优点：既继承了票据锁（ticket lock）的公平性，又借鉴了 MCS 锁优异的可扩展性。</strong></em></li></ul><span id="more"></span><h4 id="1-传统spinlock："><a href="#1-传统spinlock：" class="headerlink" title="1. 传统spinlock："></a>1. 传统spinlock：</h4><ul><li>多个等待的 CPU 核心中，谁先获得锁并无保证，存在公平性问题，同时缓存一致性开销大（如MESI），CPU核心越大，cache需求越厉害，缺乏可扩展性</li></ul><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-8.png" alt="alt text"></p><h4 id="2-Ticket-spinlock"><a href="#2-Ticket-spinlock" class="headerlink" title="2. Ticket spinlock"></a>2. Ticket spinlock</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TICKET_NEXT16</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    u32 lock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">raw_tickets</span> &#123;</span><br>      <span class="hljs-comment">/* little endian */</span><br>      u16 owner;<br>      u16 next;<br>    &#125; tickets;<br>  &#125;;<br>&#125; <span class="hljs-type">arch_spinlock_t</span>;<br><br>my_ticket = atomic_fetch_inc(&amp;lock-&gt;tickets.next);<br><br><span class="hljs-keyword">while</span> (lock-&gt;tickets.owner != my_ticket)<br>  cpu_relax();<br></code></pre></td></tr></table></figure><ul><li>解决了公平问题，防止某些 CPU 永远得不到锁，但所有核都轮询同一个owner变量，read cache line成热点，限制扩展性</li></ul><h4 id="3-MCS-lock"><a href="#3-MCS-lock" class="headerlink" title="3. MCS lock"></a>3. MCS lock</h4><ul><li>本质上是一种基于链表结构的自旋锁，每个CPU有一个对应的节点(锁的副本)，基于各自不同的副本变量进行等待，锁本身是共享的，但队列节点是线程自己维护的，每个CPU只需要查询自己对应的本地cache line，仅在这个变量发生变化的时候，才需要读取内存和刷新这条cache line, 不像 classic&#x2F;ticket对共享变量进行spin</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-type">int</span> locked; <span class="hljs-comment">/* 1 if lock acquired */</span><br>  <span class="hljs-type">int</span> count;  <span class="hljs-comment">/* nesting count, see qspinlock.c */</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mcs_spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mcs_spinlock **lock, <span class="hljs-keyword">struct</span> mcs_spinlock *node)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">prev</span>;</span><br><br>  <span class="hljs-comment">/* Init node */</span><br>  node-&gt;locked = <span class="hljs-number">0</span>;<br>  node-&gt;next   = <span class="hljs-literal">NULL</span>;<br><br>  prev = xchg(lock, node);<br>  <span class="hljs-keyword">if</span> (likely(prev == <span class="hljs-literal">NULL</span>)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  WRITE_ONCE(prev-&gt;next, node);<br><br>  <span class="hljs-comment">/* Wait until the lock holder passes the lock down. */</span><br>  arch_mcs_spin_lock_contended(&amp;node-&gt;locked);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个 CPU 线程创建的node 是独立的，每个线程都有自己的 node 实例。但是结构体中多了一个指针使结构体变大了，导致了“内存开销问题”：MCS 锁把竞争带来的 cache-line 抖动降低了，但牺牲了一些内存和部分结构管理的成本。</li></ul><h4 id="4-qspinlock"><a href="#4-qspinlock" class="headerlink" title="4. qspinlock"></a>4. qspinlock</h4><p><strong>include&#x2F;asm-generic&#x2F;qspinlock_types.h:</strong> 锁数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qspinlock</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-type">atomic_t</span> val;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * By using the whole 2nd least significant byte for the</span><br><span class="hljs-comment">                 * pending bit, we can allow better optimization of the lock</span><br><span class="hljs-comment">                 * acquisition for the pending bit holder.</span><br><span class="hljs-comment">                 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __LITTLE_ENDIAN</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      u8      locked;<br>      u8      pending;<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      u16     locked_pending;<br>      u16     tail;<br>    &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      u16     tail;<br>      u16     locked_pending;<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>      u8      reserved[<span class="hljs-number">2</span>];<br>      u8      pending;<br>      u8      locked;<br>    &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  &#125;;<br>&#125; <span class="hljs-type">arch_spinlock_t</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Initializier</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED       &#123; &#123; .val = ATOMIC_INIT(0) &#125; &#125;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Bitfields in the atomic value:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When NR_CPUS &lt; 16K</span><br><span class="hljs-comment"> *  0- 7: locked byte</span><br><span class="hljs-comment"> *     8: pending</span><br><span class="hljs-comment"> *  9-15: not used</span><br><span class="hljs-comment"> * 16-17: tail index</span><br><span class="hljs-comment"> * 18-31: tail cpu (+1)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When NR_CPUS &gt; = 16K</span><br><span class="hljs-comment"> *  0- 7: locked byte</span><br><span class="hljs-comment"> *     8: pending</span><br><span class="hljs-comment"> *  9-10: tail index</span><br><span class="hljs-comment"> * 11-31: tail cpu (+1)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_SET_MASK(type)       (((1U &lt;&lt; _Q_ ## type ## _BITS) - 1)\</span><br><span class="hljs-meta">&lt;&lt; _Q_ ## type ## _OFFSET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_LOCKED_OFFSET        0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_LOCKED_BITS          8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Q_LOCKED_MASK          _Q_SET_MASK(LOCKED)</span><br></code></pre></td></tr></table></figure><p><strong>When NR_CPUS &lt; 16K：</strong><br><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-7.png" alt="alt text"></p><ul><li><code>locked</code>：用来表示这个锁是否被人持有（0：无，1：有）</li><li><code>pending</code>：可以理解为最优先持锁位，即当unlock之后只有这个位的CPU最先持锁，也有1和0</li><li><code>tail</code>：有idx+CPU构成，用来标识等待队列的最后一个节点。</li><li><code>tail_idx</code>：就是index，它作为mcs_nodes数组的下标使用</li><li><code>tail_CPU</code>：用来表示CPU的编号+1，+1因为规定tail为0的时候表示等待队列中没有成员</li></ul><p><strong>kernel&#x2F;locking&#x2F;mcs_spinlock.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-type">int</span> locked; <span class="hljs-comment">/* 1 if lock acquired */</span><br>  <span class="hljs-type">int</span> count;  <span class="hljs-comment">/* nesting count, see qspinlock.c */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>locked = 1</code>:只是说锁传到了当前加节点，但是当前节点还需要主动申请锁(qspinlock -&gt; locked &#x3D; 1)<br><code>count</code>：针对四种上下文用于追踪当前用了第几个 node（即 idx），最大为4,不够用时就fallback不排队直接自旋</p><p><strong>kernel&#x2F;locking&#x2F;qspinlock.c:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODES       4</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qnode</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> <span class="hljs-title">mcs</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PARAVIRT_SPINLOCKS</span><br>  <span class="hljs-type">long</span> reserved[<span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Per-CPU queue node structures; we can never have more than 4 nested</span><br><span class="hljs-comment"> * contexts: task, softirq, hardirq, nmi.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Exactly fits one 64-byte cacheline on a 64-bit architecture.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * PV doubles the storage and uses the second cacheline for PV state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">DEFINE_PER_CPU_ALIGNED</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> qnode, qnodes[MAX_NODES])</span>;<br></code></pre></td></tr></table></figure><ul><li>一个 CPU 上可能嵌套多个锁, <code>qnodes</code>针对四种上下文情况下，例：进程上下文中发生中断后再次获取锁</li><li>PER_CPU的优点是快，可防止抢锁时再mallock或临时分配导致延迟，成本等问题</li></ul><p><strong>申请锁：</strong></p><ol><li>快速申请<br><strong>include&#x2F;asm-generic&#x2F;qspinlock.h</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * queued_spin_lock - acquire a queued spinlock</span><br><span class="hljs-comment"> * @lock: Pointer to queued spinlock structure</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">queued_spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> qspinlock *lock)</span><br>&#123;<br>  <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (likely(atomic_try_cmpxchg_acquire(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL)))<br>    <span class="hljs-keyword">return</span>;<br><br>  queued_spin_lock_slowpath(lock, val);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-9.png" alt="alt text"></p><ol start="2"><li>中速申请</li></ol><ul><li>快速申请失败，queue中为空时，设置锁的pending位</li><li>再次检测（检查中间是否有其它cpu进入）</li><li>一直循环检测locked位</li><li>当locked位为0时，清除pending位获得锁</li></ul><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-11.png" alt="alt text"></p><ol start="3"><li>慢速申请</li></ol><p><img src="https://raw.githubusercontent.com/GoKo-Son626/my-blog_images/main/qspinlock/image-12.png" alt="alt text"></p><table><thead><tr><th>申请</th><th>操作</th></tr></thead><tbody><tr><td>快速申请</td><td>这个锁当前没有人持有，直接通过cmpxchg()设置locked域即可获取了锁</td></tr><tr><td>中速申请</td><td>锁已经被人持有，但是MCS链表没有其他人，有且仅有一个人在等待这个锁。设置pending域，表示是第一顺位继承者，自旋等待lock-&gt; locked清0，即锁持有者释放锁</td></tr><tr><td>慢速申请</td><td>进入到queue中自旋等待，若为队列头（队列中没有等待的cpu），说明它已排到最前，可以开始尝试获取锁；否则，它会自旋等待前一个节点释放锁，并通知它可以尝试获取锁了</td></tr></tbody></table><p><strong>end:</strong></p><ul><li><p>如果只有1个或2个CPU试图获取锁，那么只需要一个4字节的qspinlock就可以了，其所占内存的大小和ticket spinlock一样。当有3个以上的CPU试图获取锁，则需要(N-2)个MCS node</p></li><li><p>qspinlock中加入”pending”位域的意义，如果是两个CPU试图获取锁，那么第二个CPU只需要简单地设置”pending”为1，而不用创建一个MCS node</p></li><li><p>试图加锁的CPU数目超过3个，使用ticket spinlock机制就会造成多个CPU的cache line刷新的问题，而qspinlock可以利用MCS node队列来解决这个问题</p></li><li><p>在多核争用严重场景下，qspinlock 让等待者在本地内存区域自旋，减少了锁的缓存抖动和对总线的竞争消耗</p></li><li><p>RISCV_QUEUED_SPINLOCKS 只应在平台(RISC-V)具有 Zabha 或 Ziccrse 时启用，不支持的情况不要选用</p></li><li><p>优先级反转问题，queue会保证了FIFO提高了公平性，但它无法感知任务的优先级，可能因为排在队列前方的低优先级任务未释放锁而发生等待，从而导致 优先级反转</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/kernel/">kernel</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/kernel/qspinlock/">qspinlock</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/lock/">lock</category>
      
      
      <comments>https://goko-son626.github.io/post/qspinlock.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo-blog</title>
      <link>https://goko-son626.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html</link>
      <guid>https://goko-son626.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html</guid>
      <pubDate>Thu, 01 May 2025 05:25:09 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;使用hexo和GitHub Pagtes部署一个自己的博客&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em><strong>使用hexo和GitHub Pagtes部署一个自己的博客</strong></em></li></ul><span id="more"></span><h3 id="1-安装并初始化Hexo"><a href="#1-安装并初始化Hexo" class="headerlink" title="1. 安装并初始化Hexo"></a>1. 安装并初始化Hexo</h3><ul><li><ol><li>安装 Hexo CLI</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>初始化博客项目目录</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mkdir my-blog &amp;&amp; cd my-blog<br>hexo init<br>npm install<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>本地预览</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo server<br></code></pre></td></tr></table></figure><ul><li>启动本地服务：在浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看效果</li></ul><h3 id="2-配置-GitHub-Pages-部署"><a href="#2-配置-GitHub-Pages-部署" class="headerlink" title="2.  配置 GitHub Pages 部署"></a>2.  配置 GitHub Pages 部署</h3><ul><li><ol><li>创建GitHub仓库</li></ol><ul><li>创建一个仓库，名字叫 你的GitHub用户名.github.io</li><li>比如你是 goko，就叫 goko.github.io</li></ul></li><li><ol start="2"><li>安装部署插件</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>修改 _config.yml（根目录下）添加部署配置：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">deploy:<br>  type: git<br>  # repo建议使用SSH, SSH免密<br>  repo: https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git<br>  branch: main  # 或者 master，看你的默认分支<br></code></pre></td></tr></table></figure><ul><li><ol start="4"><li>生成并部署博客</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><h3 id="3-域名-com-绑定"><a href="#3-域名-com-绑定" class="headerlink" title="3. 域名(.com)绑定"></a>3. 域名(<xxxx>.com)绑定</xxxx></h3><ul><li><ol><li>添加域名(在my-blog下)</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">echo &quot;&lt;xxxx&gt;.com&quot; &gt; source/CNAME<br># 或者可以：echo &quot;www.&lt;xxxx&gt;.com&quot; &gt; source/CNAME<br># 只能添加一个，而且两个需要添加不同的域名解析（如下）<br></code></pre></td></tr></table></figure><ul><li><ol start="2"><li>重新部署</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>设置 DNS 解析指向 GitHub Pages</li></ol></li></ul><p><strong>A. 使用裸域名（apex 域名）goku72.com</strong></p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>@</td><td>185.199.108.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.109.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.110.153</td><td>GitHub Pages IP</td></tr><tr><td>A</td><td>@</td><td>185.199.111.153</td><td>GitHub Pages IP</td></tr></tbody></table><p>example aliyun:</p><ol><li>选择业务需求: 将网站域名解析到服务器IPv4地址</li><li>选择网站域名(主机记录): <xxxx>.com（对应设置“@”主机记录）</xxxx></li><li>填写 IP（记录值）：</li></ol><ul><li>在输入框里粘贴以下四行（每一行一个 IP）：</li><li><pre><code>  &gt; 185.199.109.153  &gt; 185.199.108.153  &gt; 185.199.110.153  &gt; 185.199.111.153</code></pre></li></ul><hr><p><strong>B. 使用 <a href="http://www.goku72.com/">www.goku72.com</a> 作为主域名</strong></p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>记录值</th><th>说明</th></tr></thead><tbody><tr><td>CNAME</td><td>www</td><td>&lt;github用户名&gt;.github.io.</td><td>指向你的 GitHub 用户页仓库</td></tr></tbody></table><p>example aliyun:</p><ol><li>选择业务需求: 将网站域名解析到另外的目标域名</li><li>选择网站域名(主机记录): www.<xxxx>.com（对应设置“www”主机记录）</xxxx></li><li>填写 IP（记录值）：&lt;github用户名&gt;.github.io. (最有有一个符号”.”)</li></ol><h3 id="4-设置主题"><a href="#4-设置主题" class="headerlink" title="4. 设置主题"></a>4. 设置主题</h3><ul><li>cd my-blog&#x2F;themes</li><li>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> butterfly</li><li>修改_config.yml: <ul><li>theme: butterfly</li></ul></li><li>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</li></ul><p><strong>更多主题</strong>：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p><strong>注：</strong></p><ul><li>如果AB两个方式都添加了，只需要在 Hexo 项目的 source&#x2F;CNAME 文件中写 www.<xxxx>.com，GitHub Pages 就会自动把 goku72.com 重定向过去，无需额外设置！</xxxx></li><li>后续换域名只需要：阿里云重新解析 + 修改 source&#x2F;CNAME + 重新部署 Hexo，就能完成域名迁移。</li><li>有些主题可能需要下载插件</li></ul>]]></content:encoded>
      
      
      <category domain="https://GoKo-Son626.github.io/categories/blog/">blog</category>
      
      <category domain="https://GoKo-Son626.github.io/categories/blog/hexo/">hexo</category>
      
      
      <category domain="https://GoKo-Son626.github.io/tags/hexo/">hexo</category>
      
      
      <comments>https://goko-son626.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>

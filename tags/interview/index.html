<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: interview - GoKo&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="GoKo&#039;s blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GoKo&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="GoKo"><meta property="og:url" content="https://goko-son626.github.io/"><meta property="og:site_name" content="GoKo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><meta property="article:author" content="GoKo Mell"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://GoKo-Son626.github.io"},"headline":"GoKo's blog","image":["https://goko-son626.github.io/img/og_image.png"],"author":{"@type":"Person","name":"GoKo Mell"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":""}</script><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/rss.xml" title="GoKo's blog" type="application/rss+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/GoKo-Mell.png" alt="GoKo&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/friend">Friend</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags/">标签</a></li><li class="is-active"><a href="#" aria-current="page">interview</a></li></ul></nav></div></div><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-05-24  <a class="commentCountImg" href="/post/Troy-interview.html#comment-container"><span class="display-none-class">ae106d33b4950d77697b5c0e31bf764d</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="ae106d33b4950d77697b5c0e31bf764d">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>11.2 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/post/Troy-interview.html">Troy-interview</a></h1><div class="content"><span id="more"></span>

<h1 id="1-linux启动"><a href="#1-linux启动" class="headerlink" title="1. linux启动"></a>1. linux启动</h1><h3 id="1-存储介质"><a href="#1-存储介质" class="headerlink" title="1. 存储介质"></a><strong>1. 存储介质</strong></h3><table>
<thead>
<tr>
<th>SRAM &gt;</th>
<th>DRAM&gt;&gt;</th>
<th>ROM</th>
<th>HDD</th>
</tr>
</thead>
<tbody><tr>
<td>sram:</td>
<td>静态随机存取存储器：</td>
<td>快 成本高:</td>
<td>用于高速缓存</td>
</tr>
<tr>
<td>dram：</td>
<td>动态随机存取存储器：</td>
<td>略慢 成本低：</td>
<td>内存条</td>
</tr>
<tr>
<td>rom：</td>
<td>只读存储器：</td>
<td>掉电不丢失 最慢：</td>
<td>BIOS&#x2F;UEFI&#x2F;bootloader…</td>
</tr>
<tr>
<td>ram includes sram and dram</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>ROM (Read-Only Memory)</strong> 是一种只能读取不能修改的存储器，早期用于存放固定的启动代码。</li>
<li><strong>NOR Flash</strong> 是一种特殊的闪存，它在存储启动代码方面取代了传统的ROM和一些早期的EEPROM。NOR Flash最大的特点是支持“<strong>执行到位</strong>”（Execute In Place, XIP），这意味着处理器可以直接从NOR Flash中读取并执行代码，而不需要先将代码加载到RAM中。这对于启动过程至关重要。</li>
<li>在PC上，BIOS (Basic Input&#x2F;Output System) 或更现代的UEFI (Unified Extensible Firmware Interface) 就是存储在主板上的NOR Flash中，负责电脑开机时的自检、硬件初始化以及引导操作系统。</li>
</ul>
<p><strong>2. 系统上电</strong></p>
<ul>
<li><p>Soc会从固化的启动介质（如SPI NOR&#x2F;NAND:「SPI」是指 Serial Peripheral Interface（串行外设接口），是一种通信总线协议，通常用于连接 Flash 存储器。SPI NOR &#x2F; NAND Flash 是常见的非易失性存储器，上电后Soc中的BootROM会从固化的启动介质（如SPI NOR&#x2F;NAND&#x2F;eMMC&#x2F;SD Card）读取并加载第一阶段的Bootloader， 通常是 SPL（Secondary Program Loader）二级程序加载器。</p>
<p>   +——————+<br>   |     上电复位     |<br>   +——–+———+<br>        |<br>        v<br>   +——————+<br>   |     执行BootROM      | &lt;– 固化在 SoC 内部的不可修改代码（类似计算机的BIOS ROM）<br>   |                     |<br>   | **核心任务：**      |<br>   |  -&gt; 极简硬件初始化    | (例如：配置时钟、基本GPIO、电源管理单元)<br>   |  -&gt; <strong>初始化SoC内部SRAM</strong> | (这是CPU在外部DRAM可用前的唯一工作内存，容量通常几十到几百KB)<br>   |  -&gt; 配置外部启动设备控制器| (例如：SPI控制器、SD&#x2F;eMMC控制器，以便能从这些设备读取数据)<br>   |                     |<br>   | 从外部启动介质（如 SPI NOR&#x2F;NAND Flash&#x2F;eMMC&#x2F;SD Card） |<br>   | 读取 SPL 的头部或整个 SPL -&gt; <strong>SoC内部SRAM</strong> |<br>   | <strong>解释：</strong>          |<br>   |  *   <strong>SPI NOR Flash：</strong> 理论上支持XIP（Execute In Place），CPU可以直接在其上执行代码。<br>   |      但出于性能、通用性和后续阶段流程的统一性考虑，通常仍会将SPL加载到更快的SoC内部SRAM中执行。<br>   |  *   <strong>NAND Flash&#x2F;eMMC&#x2F;SD Card：</strong> 它们是块设备，<strong>不支持XIP</strong>，因此必须先将SPL<br>   |      （或其一部分）加载到SoC内部SRAM中才能执行。<br>   |  *   <strong>目的：</strong> 提供一个快速、可靠、上电即用的临时工作区，以执行下一阶段的启动代码。<br>   |                                                      &lt;–加载第一阶段Bootloader:SPL:几十KB到几百KB<br>   +——–+———+<br>        |<br>        v<br>        SPL &#x3D; Secondary Program Loader<br>   +——————++————————————————-+<br>   |       执行SPL        |   &lt;– 此时SPL在SoC内部SRAM中运行，执行效率高<br>   |                     |<br>   | **核心任务：**      |<br>   |  -&gt; <strong>初始化外部DRAM控制器和DRAM内存</strong> | (这是SPL最关键的任务，使数GB的主内存可用)<br>   |  -&gt; 初始化更多关键外设    | (例如：USB控制器、UART用于调试、MMC&#x2F;SD控制器等)<br>   |  -&gt; 加载 U-Boot 到外部DRAM | (U-Boot通常较大，需要外部DRAM提供足够空间)<br>   +——–+———+<br>        |<br>        v<br>   +——————+<br>   |   执行U-Boot     | &lt;– 第二阶段 Bootloader，此时已在外部DRAM中运行<br>   |                     |<br>   | **核心任务：**      |<br>   |  -&gt; 初始化更复杂的外设    | (例如：网络、显示、存储设备文件系统等)<br>   |  -&gt; 提供命令行接口        | (供用户交互和调试，如设置环境变量)<br>   |  -&gt; 加载 Linux Kernel、Device Tree Blob (dtb)、 |<br>   |     Initial Ramdisk (initrd) 到外部DRAM   |<br>   |  -&gt; 根据配置，执行 booti&#x2F;bootm 等命令，将控制权移交给Linux内核 |<br>   +——–+———+<br>        |<br>  +———+———-+<br>  | 可选中间阶段（平台相关，如TF-A或OpenSBI） |<br>  |                        | <strong>解释：</strong> 这些阶段通常在U-Boot之前或与U-Boot并行工作，而非严格地在U-Boot之后。<br>  |                        | 它们管理CPU的权限级别和安全状态，在U-Boot或Linux内核之前加载并运行。<br>  |                        | 当U-Boot或Linux内核需要执行安全操作时，会通过EL3的Secure Monitor（ATF）或<br>  |                        | M-mode的SBI（OpenSBI）来完成。<br>  |                        |<br>  | ARM: TF-A (Trusted Firmware-A)   | -&gt; <strong>BL31</strong> (EL3 Secure Monitor) 负责管理安全世界和非安全世界，<br>  |   (包含BL31, BL32)      |    提供PSCI (Power State Coordination Interface)等服务。<br>  |                        | -&gt; <strong>BL32</strong> (EL1 Secure World) 可选，用于运行TEE OS (如OP-TEE)。<br>  |                        | -&gt; <strong>BL33</strong> 通常是U-Boot。如果某些配置中，ATF直接加载Linux内核，<br>  |                        |    则BL33可以指向裸格式的Linux内核镜像。<br>  |                        |<br>  | RISC-V: OpenSBI (M-mode) | -&gt; 提供标准的SBI (Supervisor Binary Interface)，允许操作系统在S-mode<br>  |   (Machine Mode)       |    调用底层硬件功能（如中断处理、定时器、系统关机等）。<br>  |                        | -&gt; <code>fw_payload.elf</code> 通常是OpenSBI和Linux内核的组合，由SPL直接加载并执行。<br>  +———+———-+<br>        |<br>        v<br>   +——————+<br>   |   Linux Kernel   |    &lt;– 操作系统的核心部分<br>   | start_kernel()   |<br>   |  -&gt; 初始化更多硬件     | (例如：驱动程序、文件系统等)<br>   |  -&gt; 初始化内核子系统 | (例如：进程管理、内存管理、调度器等)<br>   |  -&gt; 挂载根文件系统    |<br>   |  -&gt; 启动 init 进程    | (用户空间第一个进程)<br>   +——–+———+<br>        |<br>        v<br>   +——————+<br>   |    &#x2F;sbin&#x2F;init    | &lt;– 用户空间起点，开始加载用户程序和服务<br>   |  用户空间起点     |<br>   +——————+</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">权限级别</th>
<th align="left">世界</th>
<th align="left">作用</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>BL1</strong></td>
<td align="left">EL3</td>
<td align="left">Secure</td>
<td align="left">ROM引导 (Primary Bootloader)</td>
<td align="left">出厂固化在 SoC 中（如STM32MP157的BootROM），其任务是从外部存储（SPI NOR &#x2F; eMMC &#x2F; SD）中寻找并加载下一阶段的BL2到内部SRAM执行。</td>
</tr>
<tr>
<td align="left"><strong>BL2</strong></td>
<td align="left">EL3</td>
<td align="left">Secure</td>
<td align="left">固件加载器 (Secondary Bootloader)</td>
<td align="left">由BL1加载并执行，其主要任务是初始化一些必要的硬件，并加载后续的固件（如BL31和BL33）到DRAM，然后将控制权交给它们。STM32MP15 使用 TF-A 的 <code>bl2.bin</code>。</td>
</tr>
<tr>
<td align="left"><strong>BL31</strong></td>
<td align="left">EL3</td>
<td align="left">Secure</td>
<td align="left">安全运行时固件 (Secure Monitor)</td>
<td align="left">运行在EL3，提供Secure Monitor Call (SMC) 接口，响应来自非安全世界的请求（如系统电源管理PSCI、核间通信、切换安全&#x2F;非安全模式等）。它是管理安全与非安全世界转换的核心。</td>
</tr>
<tr>
<td align="left"><strong>BL32</strong></td>
<td align="left">Secure World (通常为EL1或EL0)</td>
<td align="left">Secure</td>
<td align="left">可选的安全执行环境 (TEE)</td>
<td align="left">运行在Secure World，通常是一个独立的“迷你操作系统”（如OP-TEE），用于处理敏感操作，如加密、密钥管理、指纹识别等，与主操作系统（非安全世界）隔离。这是一个可选的阶段。</td>
</tr>
<tr>
<td align="left"><strong>BL33</strong></td>
<td align="left">EL2&#x2F;EL1 (或更低)</td>
<td align="left">Non-secure</td>
<td align="left">最终跳转目标</td>
<td align="left">通常是主操作系统的前导加载器（如U-Boot）或直接就是Linux内核。它运行在非安全世界，负责非安全侧的硬件初始化和加载Linux内核。EL2是管理程序，EL1是操作系统内核。</td>
</tr>
</tbody></table>
<h1 id="2-设备树-Device-Tree-DT"><a href="#2-设备树-Device-Tree-DT" class="headerlink" title="2. 设备树 (Device Tree - DT)"></a>2. 设备树 (Device Tree - DT)</h1><ul>
<li>设备树是一种用于描述硬件信息的<strong>数据结构</strong>，它以文本形式（DTS）描述了系统中的CPU、内存、总线、各种外设及其连接关系、中断、时钟等所有硬件细节。编译后生成二进制文件（DTB），供引导程序（Bootloader）和内核使用。</li>
</ul>
<ul>
<li><strong>.dts&#x2F;.dtsi -&gt; dtb：</strong> 使用 <code>dtc (Device Tree Compiler)</code> 编译器将设备树源文件 (<code>.dts</code>) 及其包含的片段文件 (<code>.dtsi</code>) 编译成二进制的设备树文件 (<code>.dtb</code>)。这个编译过程是<strong>架构无关</strong>的。</li>
<li>*<em>通过of_<em>系列API读取信息：</em></em> Linux内核通过一套<code>of_*</code>（Open Firmware）API来解析<code>.dtb</code>文件，并在运行时获取各种硬件信息，供内核子系统和驱动程序使用。</li>
<li><strong>设备树语言本身是架构无关的：</strong> 无论是ARM、RISC-V、PowerPC、MIPS等任何CPU架构，都可以使用相同的DTS语法来描述硬件。<code>dtc</code>编译器是通用的。</li>
<li><strong>设备树内容与CPU架构高度相关：</strong> 虽然语法通用，但设备树中描述的<strong>具体硬件信息</strong>（如CPU节点下的ISA扩展、特权模式；中断控制器如RISC-V的PLIC&#x2F;CLINT；内存映射；外设的寄存器地址等）是<strong>与目标CPU架构和SoC设计紧密绑定</strong>的。</li>
</ul>
<h3 id="1-设备树结构"><a href="#1-设备树结构" class="headerlink" title="1. 设备树结构"></a>1. 设备树结构</h3><p>一个典型的设备树文件以根节点 <code>/</code> 开始，并包含多个子节点，每个节点代表一个硬件设备或逻辑单元。属性则用于描述设备的具体信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs c">/dts-v1/; <span class="hljs-comment">// 声明设备树语言版本，固定写法</span><br><br><span class="hljs-comment">// 包含文件：通常用于导入SoC厂商提供的芯片级通用设备树定义</span><br><span class="hljs-comment">// 例如：#include &lt;dt-bindings/interrupt-controller/irq.h&gt; // 包含中断控制器宏定义</span><br><span class="hljs-comment">//       #include &quot;riscv_vendor_soc.dtsi&quot; // 假设SoC厂商提供芯片级通用DTSi</span><br><span class="hljs-comment">//       #include &quot;riscv_vendor_board_common.dtsi&quot; // 假设板卡厂商提供公共DTSi</span><br><br>/ &#123;	                <span class="hljs-comment">// 根节点，必须有且唯一，代表整个系统</span><br>    compatible = <span class="hljs-string">&quot;your_vendor,your_board_model&quot;</span>, <span class="hljs-string">&quot;vendor,soc_model&quot;</span>, <span class="hljs-string">&quot;generic-platform&quot;</span>; <span class="hljs-comment">// 核心属性，用于板级驱动匹配。</span><br>                        <span class="hljs-comment">// 多个值时按顺序匹配，越具体越靠前。</span><br>    model = <span class="hljs-string">&quot;Your Specific Board Name and Model&quot;</span>; <span class="hljs-comment">// 可读的板子型号名称</span><br>    interrupt-parent = &lt;&amp;plic&gt;; <span class="hljs-comment">// 根节点或总线节点通常会指定其默认的中断控制器</span><br><br>    <span class="hljs-comment">// 定义当前节点及其子节点`reg`属性中地址和长度单元的长度。</span><br>    <span class="hljs-comment">// &lt;1&gt; 表示一个32位单元；&lt;2&gt; 表示一个64位单元。</span><br>    <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>; <span class="hljs-comment">// 用于`reg`属性中物理地址的单元数量</span></span><br>    <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;    <span class="hljs-comment">// 用于`reg`属性中内存区域大小的单元数量</span></span><br><br>    aliases &#123; <span class="hljs-comment">// 别名节点，为常用设备节点提供短名称，方便访问和引用（例如：/soc/serial@... 可以别名为 serial0）</span><br>        serial0 = &amp;uart0;<br>        spi0 = &amp;spi0_controller;<br>        ethernet0 = &amp;ethernet_mac;<br>        mmc0 = &amp;sd_controller;<br>        <span class="hljs-comment">// ...</span><br>    &#125;;<br><br>    chosen &#123; <span class="hljs-comment">// 用于引导程序（Bootloader）和操作系统内核之间传递参数的节点</span><br>        <span class="hljs-built_in">stdout</span>-path = <span class="hljs-string">&quot;serial0:115200&quot;</span>; <span class="hljs-comment">// 指定内核启动时的控制台输出设备（引用alias）和波特率</span><br>        bootargs = <span class="hljs-string">&quot;console=ttyS0,115200 earlycon root=/dev/mmcblk0p2 rootwait ro&quot;</span>; <span class="hljs-comment">// 传递给内核的启动参数</span><br>        <span class="hljs-comment">// linux,initrd-start = &lt;0x...&gt;; // 可选：指定Initrd的物理内存起始地址</span><br>        <span class="hljs-comment">// linux,initrd-end = &lt;0x...&gt;;   // 可选：指定Initrd的物理内存结束地址</span><br>    &#125;;<br><br>    memory@<span class="hljs-number">80000000</span> &#123; <span class="hljs-comment">// 物理内存区域节点，节点名应包含起始地址</span><br>        device_type = <span class="hljs-string">&quot;memory&quot;</span>; <span class="hljs-comment">// 节点类型，固定为&quot;memory&quot;，表示这是一个内存区域</span><br>        reg = &lt;<span class="hljs-number">0x80000000</span> <span class="hljs-number">0x40000000</span>&gt;; <span class="hljs-comment">// 物理起始地址和大小 (例如：从0x80000000开始，大小1GB)</span><br>                                       <span class="hljs-comment">// 必须与板载DRAM的实际配置相符</span><br>    &#125;;<br><br>    cpus &#123; <span class="hljs-comment">// 定义系统中所有 CPU 核的数量、拓扑、启动方式等</span><br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>; <span class="hljs-comment">// CPU ID的长度（通常是hart ID）</span></span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;    <span class="hljs-comment">// CPU节点通常没有大小信息</span></span><br><br>        cpu0: cpu@<span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 每个CPU核一个节点，节点名通常包含其ID</span><br>            compatible = <span class="hljs-string">&quot;riscv&quot;</span>; <span class="hljs-comment">// RISC-V CPU的通用兼容性</span><br>            device_type = <span class="hljs-string">&quot;cpu&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0</span>&gt;; <span class="hljs-comment">// hart id (硬件线程ID)</span><br>            clock-frequency = &lt;<span class="hljs-number">1000000000</span>&gt;; <span class="hljs-comment">// CPU主频，单位Hz (例如1GHz)</span><br>            riscv,isa = <span class="hljs-string">&quot;rv64imafdc&quot;</span>; <span class="hljs-comment">// RISC-V指令集扩展（例如：64位、整数、乘除、原子、浮点、双精度浮点、压缩指令）</span><br>            riscv,priv-modes = &lt;<span class="hljs-number">0x3</span>&gt;; <span class="hljs-comment">// 支持的特权模式 (M-mode, S-mode)</span><br>            <span class="hljs-comment">// interrupt-controller; // 如果该CPU内部有核心本地中断控制器(CLINT)，可以标记</span><br>            <span class="hljs-comment">// clock-names = &quot;cpu_clk&quot;; // 如果CPU有特定的时钟名称</span><br>            <span class="hljs-comment">// clocks = &lt;&amp;bus_clk&gt;;     // 引用CPU的时钟源</span><br>            <span class="hljs-comment">// d-cache-size = &lt;...&gt;; // L1 D-Cache大小</span><br>            <span class="hljs-comment">// i-cache-size = &lt;...&gt;; // L1 I-Cache大小</span><br>            <span class="hljs-comment">// l2-cache = &lt;&amp;l2_cache&gt;; // 引用L2 Cache节点</span><br>        &#125;;<br>        <span class="hljs-comment">// 如果有多个CPU核（如多核处理器），依此类推：cpu1: cpu@1 &#123; ... &#125;;</span><br>    &#125;;<br><br>    soc &#123;	        <span class="hljs-comment">// 通常代表SoC内部的总线或集成外设，作为其他外设的父节点</span><br>        compatible = <span class="hljs-string">&quot;your_vendor,your_soc_model&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span>; <span class="hljs-comment">// SoC总线节点兼容性，&quot;simple-bus&quot;是通用总线</span><br>        <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br>        ranges; <span class="hljs-comment">// 用于地址映射。空值表示子节点地址空间与父节点相同，无需映射。</span><br>                <span class="hljs-comment">// 如果需要地址转换，例如 `ranges = &lt;0x0 0x80000000 0x10000000&gt;;`</span><br>                <span class="hljs-comment">// 解释：子节点地址0x0映射到父节点地址0x80000000，长度0x10000000。</span><br><br>        <span class="hljs-comment">// **RISC-V特定中断控制器节点**</span><br>        plic: interrupt-controller@c000000 &#123; <span class="hljs-comment">// Platform-Level Interrupt Controller (PLIC)</span><br>            compatible = <span class="hljs-string">&quot;riscv,plic0&quot;</span>; <span class="hljs-comment">// 匹配PLIC驱动</span><br>            reg = &lt;<span class="hljs-number">0xc000000</span> <span class="hljs-number">0x4000000</span>&gt;; <span class="hljs-comment">// PLIC寄存器地址范围</span><br>            interrupt-controller; <span class="hljs-comment">// 标记这是一个中断控制器</span><br>            <span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;3&gt;</span>; <span class="hljs-comment">// PLIC需要3个单元：中断类型(1)、中断ID(2)、中断标志(3)</span></span><br>            riscv,max-harts = &lt;<span class="hljs-number">1</span>&gt;; <span class="hljs-comment">// 支持的最大hart数量</span><br>            riscv,ndev = &lt;<span class="hljs-number">64</span>&gt;; <span class="hljs-comment">// 支持的最大设备中断数量</span><br>            <span class="hljs-comment">// 中断类型通常为0表示IRQ，1表示软件中断。</span><br>            <span class="hljs-comment">// 中断标志通常表示中断的触发方式（电平触发/边缘触发、高/低电平）。</span><br>        &#125;;<br><br>        clint: timer@<span class="hljs-number">2000000</span> &#123; <span class="hljs-comment">// Core Local Interruptor (CLINT) - 提供定时器和处理器间中断</span><br>            compatible = <span class="hljs-string">&quot;riscv,clint0&quot;</span>;<br>            reg = &lt;<span class="hljs-number">0x2000000</span> <span class="hljs-number">0x10000</span>&gt;; <span class="hljs-comment">// CLINT寄存器地址范围</span><br>            <span class="hljs-comment">// CLINT通常作为CPU的中断源，不需要#interrupt-cells。</span><br>        &#125;;<br><br>        <span class="hljs-comment">// **UART控制器节点**</span><br>        uart0: serial@<span class="hljs-number">10000000</span> &#123; <span class="hljs-comment">// 节点名称和寄存器物理地址</span><br>            compatible = <span class="hljs-string">&quot;ns16550a&quot;</span>, <span class="hljs-string">&quot;riscv,uart0&quot;</span>; <span class="hljs-comment">// 通用UART驱动匹配字符串，或SoC特定UART兼容字符串</span><br>            reg = &lt;<span class="hljs-number">0x10000000</span> <span class="hljs-number">0x100</span>&gt;; <span class="hljs-comment">// 寄存器基地址和大小</span><br>            interrupts = &lt;<span class="hljs-number">0x4</span>&gt;; <span class="hljs-comment">// 中断号 (具体值取决于中断控制器，通常是中断请求线ID)</span><br>            interrupt-parent = &lt;&amp;plic&gt;; <span class="hljs-comment">// 明确指定中断来源（非必须，但推荐）</span><br>            clocks = &lt;&amp;clk_controller <span class="hljs-number">0</span>&gt;; <span class="hljs-comment">// 引用时钟源（假设clk_controller的第一个时钟）</span><br>            status = <span class="hljs-string">&quot;okay&quot;</span>; <span class="hljs-comment">// 启用设备</span><br>        &#125;;<br><br>        <span class="hljs-comment">// **SPI控制器节点**</span><br>        spi0_controller: spi@<span class="hljs-number">10001000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;spi-controller-compatible&quot;</span>; <span class="hljs-comment">// 匹配SPI主控驱动 (例如 &quot;vendor,spi-v1&quot;)</span><br>            reg = &lt;<span class="hljs-number">0x10001000</span> <span class="hljs-number">0x100</span>&gt;;<br>            interrupts = &lt;<span class="hljs-number">0x5</span>&gt;;<br>            interrupt-parent = &lt;&amp;plic&gt;;<br>            <span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>; <span class="hljs-comment">// 定义子设备（SPI从设备）的片选线号</span></span><br>            <span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;    <span class="hljs-comment">// SPI从设备没有大小信息</span></span><br>            status = <span class="hljs-string">&quot;okay&quot;</span>;<br><br>            <span class="hljs-comment">// SPI 从设备节点（例如一个SPI Nor Flash芯片）</span><br>            flash@<span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 节点名通常包含片选号</span><br>                compatible = <span class="hljs-string">&quot;jedec,spi-nor&quot;</span>; <span class="hljs-comment">// 匹配通用SPI Nor Flash驱动</span><br>                reg = &lt;<span class="hljs-number">0</span>&gt;; <span class="hljs-comment">// 片选线号</span><br>                spi-max-frequency = &lt;<span class="hljs-number">50000000</span>&gt;; <span class="hljs-comment">// 最大SPI频率</span><br>            &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">// **GPIO控制器节点**</span><br>        gpio0: gpio@<span class="hljs-number">10002000</span> &#123;<br>            compatible = <span class="hljs-string">&quot;gpio-controller-compatible&quot;</span>; <span class="hljs-comment">// 匹配GPIO控制器驱动 (例如 &quot;vendor,gpio-v1&quot;)</span><br>            reg = &lt;<span class="hljs-number">0x10002000</span> <span class="hljs-number">0x100</span>&gt;;<br>            gpio-cells = &lt;<span class="hljs-number">2</span>&gt;; <span class="hljs-comment">// 每个GPIO PIN在引用时需要2个单元：PIN号和标志（GPIO_ACTIVE_HIGH/LOW等）</span><br>            interrupt-controller; <span class="hljs-comment">// 如果GPIO控制器也能产生中断</span><br>            <span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;2&gt;</span>; <span class="hljs-comment">// 如果作为中断控制器，需要2个单元：GPIO中断号和标志</span></span><br>            status = <span class="hljs-string">&quot;okay&quot;</span>;<br>        &#125;;<br><br>        <span class="hljs-comment">// **外部连接的LEDs (通过GPIO控制)**</span><br>        leds &#123;<br>            compatible = <span class="hljs-string">&quot;gpio-leds&quot;</span>; <span class="hljs-comment">// 匹配GPIO LED驱动</span><br><br>            led0: led@<span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 节点名和LED索引</span><br>                label = <span class="hljs-string">&quot;system-led&quot;</span>; <span class="hljs-comment">// 用户友好的标签</span><br>                gpios = &lt;&amp;gpio0 <span class="hljs-number">0</span> GPIO_ACTIVE_HIGH&gt;; <span class="hljs-comment">// 引用gpio0控制器，使用GPIO 0，高电平有效</span><br>                <span class="hljs-keyword">default</span>-state = <span class="hljs-string">&quot;off&quot;</span>; <span class="hljs-comment">// 默认开机状态 (&quot;on&quot;, &quot;off&quot;, &quot;keep&quot;, &quot;blinking&quot;)</span><br>            &#125;;<br>            led1: led@<span class="hljs-number">1</span> &#123;<br>                label = <span class="hljs-string">&quot;user-led&quot;</span>;<br>                gpios = &lt;&amp;gpio0 <span class="hljs-number">1</span> GPIO_ACTIVE_LOW&gt;; <span class="hljs-comment">// 使用GPIO 1，低电平有效</span><br>            &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">// **其他外设...** (如I2C控制器、以太网MAC、MMC/SD控制器、USB控制器、PWM控制器、时钟控制器等)</span><br>        <span class="hljs-comment">// clocks: clock-controller@... &#123; // 时钟控制器节点</span><br>        <span class="hljs-comment">//     compatible = &quot;vendor,clock-controller&quot;;</span><br>        <span class="hljs-comment">//     reg = &lt;...&gt;;</span><br>        <span class="hljs-comment">//     #clock-cells = &lt;1&gt;; // 如果有时钟ID，需要一个单元</span><br>        <span class="hljs-comment">//     // ...</span><br>        <span class="hljs-comment">// &#125;;</span><br><br>        <span class="hljs-comment">// pinctrl@... &#123; // 引脚控制器节点，用于配置引脚复用和电气特性</span><br>        <span class="hljs-comment">//     compatible = &quot;vendor,pinctrl&quot;;</span><br>        <span class="hljs-comment">//     reg = &lt;...&gt;;</span><br>        <span class="hljs-comment">//     pinctrl-names = &quot;default&quot;; // 默认的引脚配置组名称</span><br>        <span class="hljs-comment">//     pinctrl-0 = &lt;&amp;pinmux_group_uart0&gt;; // 引用具体的引脚配置组</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//     pinmux_group_uart0: pinmux-group-uart0 &#123; // 定义引脚配置组</span><br>        <span class="hljs-comment">//         pins = &lt;0 1&gt;; // 具体的引脚编号</span><br>        <span class="hljs-comment">//         // 其他引脚配置，如驱动强度、上拉/下拉等</span><br>        <span class="hljs-comment">//     &#125;;</span><br>        <span class="hljs-comment">// &#125;;</span><br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>


<h3 id="2-常用节点-属性"><a href="#2-常用节点-属性" class="headerlink" title="2. 常用节点&#x2F;属性"></a>2. 常用节点&#x2F;属性</h3><table>
<thead>
<tr>
<th align="left">节点&#x2F;属性</th>
<th align="left">用途 (补充与修正)</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>compatible</code></td>
<td align="left"><strong>驱动匹配关键：</strong> 内核和驱动中通过这个字段进行匹配，实现驱动的硬件无关性。多个值时按顺序匹配，越具体越靠前。</td>
<td align="left"><code>&quot;vendor,device-v1&quot;, &quot;generic-device&quot;</code></td>
</tr>
<tr>
<td align="left"><code>reg</code></td>
<td align="left"><strong>硬件寄存器地址范围：</strong> 描述设备的物理地址和大小。格式通常为 <code>&lt;起始地址 长度&gt;</code>，单位数量由父节点的<code>#address-cells</code>和<code>#size-cells</code>决定。</td>
<td align="left"><code>&lt;0x10000000 0x100&gt;</code> (32位地址，长度256字节)</td>
</tr>
<tr>
<td align="left"><code>interrupts</code></td>
<td align="left"><strong>中断号、触发方式等：</strong> 驱动用来注册中断处理程序。具体含义和单元数量由父中断控制器节点的<code>#interrupt-cells</code>决定。</td>
<td align="left"><code>&lt;0x4&gt;</code> (单个中断ID)；<code>&lt;0 4 IRQ_TYPE_EDGE_RISING&gt;</code> (RISC-V PLIC中，指定中断类型、ID、标志)</td>
</tr>
<tr>
<td align="left"><code>interrupt-parent</code></td>
<td align="left"><strong>指定中断控制器：</strong> 明确该设备的中断连接到哪个中断控制器（节点引用）。如果未指定，默认继承父节点。</td>
<td align="left"><code>&lt;&amp;plic&gt;</code></td>
</tr>
<tr>
<td align="left"><code>#address-cells</code></td>
<td align="left"><strong>定义子节点地址单元长度：</strong> 决定其子节点<code>reg</code>属性中“地址”部分有多少个32位单元。</td>
<td align="left"><code>&lt;1&gt;</code> (32位地址)；<code>&lt;2&gt;</code> (64位地址)</td>
</tr>
<tr>
<td align="left"><code>#size-cells</code></td>
<td align="left"><strong>定义子节点长度单元长度：</strong> 决定其子节点<code>reg</code>属性中“大小”部分有多少个32位单元。</td>
<td align="left"><code>&lt;1&gt;</code> (32位长度)；<code>&lt;2&gt;</code> (64位长度)</td>
</tr>
<tr>
<td align="left"><code>#interrupt-cells</code></td>
<td align="left"><strong>定义中断单元长度：</strong> 标记该节点是一个中断控制器，并决定其子设备<code>interrupts</code>属性中中断描述符的单元数量。</td>
<td align="left"><code>&lt;1&gt;</code> (简单中断ID)；<code>&lt;3&gt;</code> (RISC-V PLIC)</td>
</tr>
<tr>
<td align="left"><code>#gpio-cells</code></td>
<td align="left"><strong>定义GPIO单元长度：</strong> 标记该节点是一个GPIO控制器，并决定其子设备<code>gpios</code>属性中GPIO描述符的单元数量。</td>
<td align="left"><code>&lt;2&gt;</code> (GPIO号和标志)</td>
</tr>
<tr>
<td align="left"><code>#clock-cells</code></td>
<td align="left"><strong>定义时钟单元长度：</strong> 标记该节点是一个时钟控制器，并决定其子设备<code>clocks</code>属性中时钟描述符的单元数量（通常是时钟ID）。</td>
<td align="left"><code>&lt;1&gt;</code></td>
</tr>
<tr>
<td align="left"><code>clocks</code></td>
<td align="left"><strong>时钟源引用：</strong> 引用设备所需的一个或多个时钟源（需要配合clk framework使用）。</td>
<td align="left"><code>&lt;&amp;clk_controller 0&gt;</code></td>
</tr>
<tr>
<td align="left"><code>clock-names</code></td>
<td align="left"><strong>时钟源名称：</strong> 为<code>clocks</code>属性中引用的时钟源提供名称，当设备需要多个不同功能的时钟时使用。</td>
<td align="left"><code>&quot;bus&quot;, &quot;peripheral&quot;</code></td>
</tr>
<tr>
<td align="left"><code>pinctrl-names</code></td>
<td align="left"><strong>引脚配置组名称：</strong> 定义引脚配置的状态名称，例如“default”, “sleep”, “idle”等。</td>
<td align="left"><code>&quot;default&quot;</code></td>
</tr>
<tr>
<td align="left"><code>pinctrl-0</code>, <code>pinctrl-1</code></td>
<td align="left"><strong>引脚配置组引用：</strong> 引用具体的引脚配置组（由pinctrl节点中的子节点定义）。<code>pinctrl-0</code>通常是默认配置。</td>
<td align="left"><code>&lt;&amp;pinmux_group_uart0&gt;</code></td>
</tr>
<tr>
<td align="left"><code>status</code></td>
<td align="left"><strong>设备启用状态：</strong> <code>&quot;okay&quot;</code>表示启用设备；<code>&quot;disabled&quot;</code>表示禁用设备；<code>&quot;reserved&quot;</code>表示预留。</td>
<td align="left"><code>&quot;okay&quot;</code></td>
</tr>
<tr>
<td align="left"><code>linux,phandle</code></td>
<td align="left"><strong>内核内部引用句柄：</strong> 由dtc编译器在编译时自动生成，用于内核内部节点之间的引用，不应手动设置。</td>
<td align="left">(自动生成)</td>
</tr>
<tr>
<td align="left"><code>ranges</code></td>
<td align="left"><strong>地址映射：</strong> 定义父子总线之间的地址转换规则。空值表示子节点地址空间与父节点相同，无需映射。</td>
<td align="left"><code>ranges;</code> 或 <code>&lt;0x0 0x80000000 0x10000000&gt;</code></td>
</tr>
<tr>
<td align="left"><code>device_type</code></td>
<td align="left"><strong>设备类型：</strong> 特定节点（如<code>memory</code>和<code>cpu</code>）的固定属性，用于标识其类型。</td>
<td align="left"><code>&quot;memory&quot;</code>, <code>&quot;cpu&quot;</code></td>
</tr>
<tr>
<td align="left"><code>model</code></td>
<td align="left"><strong>可读型号：</strong> 设备的可读型号描述，通常用于根节点和SoC节点。</td>
<td align="left"><code>&quot;My Awesome RISC-V Board&quot;</code></td>
</tr>
<tr>
<td align="left"><code>label</code></td>
<td align="left"><strong>用户友好标签：</strong> 为设备提供一个可读的字符串标签，方便在用户空间或调试时识别。</td>
<td align="left"><code>&quot;system-led&quot;</code></td>
</tr>
<tr>
<td align="left"><code>gpios</code></td>
<td align="left"><strong>GPIO引用：</strong> 引用一个或多个GPIO引脚。格式取决于<code>#gpio-cells</code>，通常为 <code>&lt;&amp;gpio_controller gpio_pin_number gpio_flags&gt;</code>。</td>
<td align="left"><code>&lt;&amp;gpio0 0 GPIO_ACTIVE_HIGH&gt;</code></td>
</tr>
<tr>
<td align="left"><code>default-state</code></td>
<td align="left"><strong>GPIO LED默认状态：</strong> 对于<code>gpio-leds</code>，定义LED的默认状态。</td>
<td align="left"><code>&quot;on&quot;</code>, <code>&quot;off&quot;</code>, <code>&quot;blinking&quot;</code>, <code>&quot;keep&quot;</code></td>
</tr>
<tr>
<td align="left"><code>riscv,isa</code></td>
<td align="left"><strong>RISC-V ISA扩展：</strong> 对于CPU节点，描述RISC-V指令集架构的扩展集合。</td>
<td align="left"><code>&quot;rv64imafdc&quot;</code></td>
</tr>
<tr>
<td align="left"><code>riscv,priv-modes</code></td>
<td align="left"><strong>RISC-V特权模式：</strong> 对于CPU节点，描述CPU支持的RISC-V特权模式（M-mode, S-mode, U-mode）。</td>
<td align="left"><code>&lt;0x3&gt;</code> (表示M-mode和S-mode)</td>
</tr>
<tr>
<td align="left"><code>clock-frequency</code></td>
<td align="left"><strong>设备工作频率：</strong> 通常用于CPU节点，描述其工作频率。</td>
<td align="left"><code>&lt;1000000000&gt;</code> (1GHz)</td>
</tr>
<tr>
<td align="left"><code>reserved-memory</code></td>
<td align="left"><strong>预留内存区域：</strong> 定义内核不应使用的内存段（例如，用于GPU、VPU、DSP或安全区域等）。</td>
<td align="left">(一个单独的节点，内部定义子节点描述各预留区域)</td>
</tr>
<tr>
<td align="left"><code>dma-names</code>, <code>dmas</code></td>
<td align="left"><strong>DMA通道引用：</strong> 引用DMA控制器及其通道。</td>
<td align="left"><code>&lt;&amp;dma_controller 0&gt;</code></td>
</tr>
</tbody></table>
<h3 id="3-拿到一个RISC-V开发板，如何写设备树？"><a href="#3-拿到一个RISC-V开发板，如何写设备树？" class="headerlink" title="3. 拿到一个RISC-V开发板，如何写设备树？"></a>3. 拿到一个RISC-V开发板，如何写设备树？</h3><h4 id="1-阶段一：信息收集与环境准备-地基"><a href="#1-阶段一：信息收集与环境准备-地基" class="headerlink" title="1. 阶段一：信息收集与环境准备 (地基)"></a>1. 阶段一：信息收集与环境准备 (地基)</h4><ul>
<li><strong>1.1 硬件文档是金：</strong><ul>
<li><strong>SoC 数据手册&#x2F;参考手册：</strong> 必读！获取所有内部外设（CPU、PLCI、CLINT、UART、SPI、I2C、GPIO等）的<strong>寄存器基地址、中断号、时钟源信息、引脚复用配置</strong>。</li>
<li><strong>开发板原理图 (Schematic)：</strong> 了解板载DRAM容量、外部Flash型号、以太网PHY、LEDs、Buttons、传感器等<strong>外部设备</strong>如何连接到SoC的特定引脚和接口。</li>
<li><strong>已有参考：</strong> 查找SoC厂商或开发板厂商提供的<strong>参考设备树文件 (<code>.dtsi</code>&#x2F;<code>.dts</code>)</strong>。这是最快的起点，可以避免从零开始。</li>
<li><strong>Bootloader 源码：</strong> 查阅U-Boot或其它Bootloader中对硬件的初始化代码，通常能反推出设备树的结构和属性。</li>
</ul>
</li>
<li><strong>1.2 Linux内核文档：</strong><ul>
<li><code>Linux内核源码/Documentation/devicetree/bindings/</code>：<strong>核心参考！</strong> 这个目录包含了各种标准设备（如GPIO控制器、UART、SPI控制器、PHY、LED等）的绑定规范。它会告诉你某个<code>compatible</code>字符串对应的节点应该有哪些属性，以及这些属性的含义、类型和格式。严格遵循这些绑定规范是确保驱动正常工作的关键。</li>
</ul>
</li>
<li><strong>1.3 工具：</strong> 确保<code>dtc</code>编译器已安装并可用。</li>
</ul>
<h4 id="2-阶段二：构建基础设备树框架-骨架"><a href="#2-阶段二：构建基础设备树框架-骨架" class="headerlink" title="2. 阶段二：构建基础设备树框架 (骨架)"></a>2. 阶段二：构建基础设备树框架 (骨架)</h4><ul>
<li><strong>2.1 创建顶层 <code>.dts</code> 文件：</strong> 通常以板子的名称命名，例如 <code>your_riscv_board.dts</code>。<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-keyword">/dts-v1/</span><span class="hljs-punctuation">;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv_vendor_soc.dtsi&quot;</span> // 引入SoC芯片级的通用定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv_vendor_board_common.dtsi&quot;</span> // 引入板级公共定义（如果有）</span><br><br><span class="hljs-title class_">/</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 根节点定义</span><br>    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your_vendor,your_board_model&quot;</span>, <span class="hljs-string">&quot;vendor,soc_model&quot;</span>, <span class="hljs-string">&quot;simple-bus&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-attr">model</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;My Custom RISC-V Development Board&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-meta">#address-cells = &lt;1&gt;; <span class="hljs-comment">// 假设地址是32位</span></span><br>    <span class="hljs-meta">#size-cells = &lt;1&gt;;    <span class="hljs-comment">// 假设大小是32位</span></span><br><br>    <span class="hljs-comment">// 内存节点：根据原理图填写DRAM的实际物理地址和大小</span><br>    <span class="hljs-title class_">memory@80000000</span> <span class="hljs-punctuation">&#123;</span><br>        device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;memory&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x80000000</span> <span class="hljs-number">0x40000000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 例如：从0x80000000开始，1GB</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-comment">// chosen 节点：最关键的调试信息，确保console可用</span><br>    <span class="hljs-title class_">chosen</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">stdout-path</span> <span class="hljs-operator">=</span> <span class="hljs-variable">&amp;uart0</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 假设uart0是控制台</span><br>        <span class="hljs-attr">bootargs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;console=ttyS0,115200 root=/dev/mmcblk0p2 rootwait earlycon&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-title class_">aliases</span> <span class="hljs-punctuation">&#123;</span><br>        serial0 = <span class="hljs-variable">&amp;uart0</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 方便chosen节点引用</span><br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-comment">// CPU节点：通常在SoC的dtsi中定义，此处可覆盖或添加属性</span><br>    <span class="hljs-variable">&amp;cpu0</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">clock-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">1000000000</span>&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 实际的CPU频率</span><br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-comment">// SoC内部外设节点：通过引用dtsi中已有的节点并添加/修改板级特定配置</span><br>    <span class="hljs-comment">// 例如，启用串口0</span><br>    <span class="hljs-variable">&amp;uart0</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;okay&quot;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">// 确保启用</span><br>        <span class="hljs-comment">// 如果与dtsi中定义不同，可覆盖reg, interrupts, clocks等</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-comment">// PLIC/CLINT等中断控制器节点也应在dtsi中被引用和确保启用</span><br>    <span class="hljs-variable">&amp;plic</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;okay&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;;</span><br>    <span class="hljs-variable">&amp;clint</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;okay&quot;</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-punctuation">&#125;;</span><br><br>    <span class="hljs-comment">// ...其他必要的SoC内部模块</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-阶段三：逐步添加外设与调试-填充血肉"><a href="#3-阶段三：逐步添加外设与调试-填充血肉" class="headerlink" title="3. 阶段三：逐步添加外设与调试 (填充血肉)"></a>3. 阶段三：逐步添加外设与调试 (填充血肉)</h4><ul>
<li><strong>3.1 编译DTB：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dtc -I dts -O dtb -o your_riscv_board.dtb your_riscv_board.dts<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>错误处理：</strong> <code>dtc</code>会报告语法错误。确保没有警告或错误。</li>
</ul>
</li>
<li><strong>3.2 集成与启动：</strong><ul>
<li>将编译好的 <code>your_riscv_board.dtb</code> 文件放置到Bootloader（如U-Boot）能够访问的位置（例如SD卡、TFTP服务器）。</li>
<li>在U-Boot命令行中，确保正确加载了DTB并将其地址传递给Linux内核：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">fatload mmc 0:1 0x80200000 Image // 加载内核镜像<br>fatload mmc 0:1 0x82000000 your_riscv_board.dtb // 加载设备树<br>setenv bootargs <span class="hljs-string">&quot;console=ttyS0,115000 root=/dev/mmcblk0p2 rootwait&quot;</span> // 设置启动参数<br>booti 0x80200000 - 0x82000000 // 启动内核 (RISC-V booti 命令)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>3.3 验证与调试（迭代过程）：</strong><ul>
<li><strong>串口输出：</strong> 内核启动时会打印大量日志，这是验证设备树最直接的方式。关注与你添加的设备相关的行。</li>
<li><strong><code>dmesg</code>：</strong> 内核启动后，使用 <code>dmesg</code> 命令查看完整的内核日志。搜索你设备的<code>compatible</code>字符串，或者设备名称，看它是否被识别和初始化。</li>
<li><strong><code>/sys/firmware/devicetree/base/</code>：</strong> 这是设备树在Linux运行时的表现。<ul>
<li><code>ls -R /sys/firmware/devicetree/base/</code>：查看整个设备树的目录结构。</li>
<li><code>cat /sys/firmware/devicetree/base/&lt;node_path&gt;/&lt;property_name&gt;</code>：查看特定节点的属性值，验证是否与你DTS中定义的一致。</li>
</ul>
</li>
<li><strong><code>/proc/interrupts</code>：</strong> 检查中断是否正确注册。</li>
<li><strong><code>/sys/kernel/debug/gpio</code> (需启用debugfs)：</strong> 检查GPIO引脚的状态。</li>
<li><strong><code>lsmod</code> &#x2F; <code>modprobe</code>：</strong> 尝试手动加载&#x2F;卸载相关驱动模块，观察内核日志。</li>
<li><strong>逐步排查：</strong><ul>
<li><strong>如果设备未被识别：</strong> 检查<code>compatible</code>字符串是否与驱动匹配、<code>status = &quot;okay&quot;</code>是否设置、节点路径是否正确。</li>
<li><strong>如果设备被识别但功能异常：</strong> 检查<code>reg</code>地址和大小是否正确、<code>interrupts</code>中断号和标志是否正确、<code>clocks</code>是否引用了正确的时钟源且已启用、<code>gpios</code>引用是否准确。</li>
<li><strong>最常见问题：</strong> 地址、中断、时钟和GPIO的配置错误。</li>
<li><strong>查阅绑定文档：</strong> 再次强调，遇到问题时，<code>Documentation/devicetree/bindings/</code>目录下的官方绑定文档是解决问题的关键。它详细说明了每个属性的语义和期望值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-阶段四：高级配置与完善-优化"><a href="#4-阶段四：高级配置与完善-优化" class="headerlink" title="4. 阶段四：高级配置与完善 (优化)"></a>4. 阶段四：高级配置与完善 (优化)</h4><ul>
<li><strong>引脚复用 (Pinmux)：</strong> 根据SoC的pinctrl驱动和原理图，添加pinctrl节点及其子节点，定义不同的引脚复用组，并在设备节点中通过<code>pinctrl-names</code>和<code>pinctrl-0</code>等属性引用。这是确保引脚功能正确的关键。</li>
<li><strong>电源管理与时钟门控：</strong> 添加<code>power-domains</code>、<code>clocks</code>、<code>clock-names</code>等属性，配合内核的电源管理和时钟框架，实现设备的低功耗和性能调优。</li>
<li><strong>DMA配置：</strong> 为需要DMA（Direct Memory Access）的设备（如USB、Ethernet）添加<code>dmas</code>和<code>dma-names</code>属性，引用DMA控制器和通道。</li>
<li><strong>复杂总线：</strong> 对于I2C、SPI等总线，如果连接了多个从设备，需要在其控制器节点下添加子节点。</li>
<li><strong>错误处理：</strong> 如果某个设备无法正常工作，应先排除设备树配置问题，再考虑驱动或硬件问题。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">/dts-v1/;<br>/ &#123;	                <span class="hljs-comment">// 定义板子整体的模型、兼容性</span><br>    compatible = <span class="hljs-string">&quot;xxx&quot;</span>;<br>    model = <span class="hljs-string">&quot;xxx board&quot;</span>;<br><br>    memory &#123; ... &#125;;	<span class="hljs-comment">// 定义物理内存区域</span><br>    cpus &#123; ... &#125;;	<span class="hljs-comment">// 定义所有 CPU 核的数量、拓扑、启动方式等</span><br>    chosen &#123; ... &#125;;     <span class="hljs-comment">// 内核启动参数、console、initrd 地址等</span><br><br>    soc &#123;	        <span class="hljs-comment">// 芯片内部挂载的所有外设（UART、SPI 等）</span><br>        serial@xxxx &#123; ... &#125;;<br>        i2c@xxxx &#123; ... &#125;;<br>        spi@xxxx &#123; ... &#125;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>节点&#x2F;属性</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>compatible</code></td>
<td>驱动匹配关键：驱动中会通过这个字段绑定</td>
</tr>
<tr>
<td><code>reg</code></td>
<td>硬件寄存器地址范围（告诉驱动怎么访问）</td>
</tr>
<tr>
<td><code>interrupts</code></td>
<td>中断号、触发方式等（驱动用来注册 handler）</td>
</tr>
<tr>
<td><code>clocks</code></td>
<td>时钟源、速率（需要配合 clk framework 使用）</td>
</tr>
<tr>
<td><code>pinctrl-0</code></td>
<td>使用哪组 pinmux 设置</td>
</tr>
<tr>
<td><code>status = &quot;okay&quot;</code></td>
<td>是否启用设备</td>
</tr>
<tr>
<td><code>linux,phandle</code></td>
<td>内核内部处理引用的句柄</td>
</tr>
<tr>
<td><code>&amp;aliases</code></td>
<td>给节点起别名（影响路径）</td>
</tr>
<tr>
<td><code>reserved-memory</code></td>
<td>定义内核不能用的内存段（比如给 VPU、TPU）</td>
</tr>
</tbody></table>
<h1 id="3-platform-device-platform-driver-platform-bus"><a href="#3-platform-device-platform-driver-platform-bus" class="headerlink" title="3. platform_device &#x2F; platform_driver &#x2F; platform_bus"></a>3. platform_device &#x2F; platform_driver &#x2F; platform_bus</h1><ul>
<li>设备（platform_device）和驱动（platform_driver）都注册到了 platform_bus 上。</li>
<li>当它们都出现时，调用总线的 match() 方法：<ul>
<li>比较设备名 vs 驱动名（pdev-&gt;name &#x3D;&#x3D; pdrv-&gt;name）<ul>
<li>匹配成功 → 调用 driver.probe()，开始驱动设备。</li>
</ul>
</li>
</ul>
</li>
<li>每个设备或驱动都会挂到一条总线上，platform_device&#x2F;driver是挂到了虚拟的platform_bus上，当有驱动模块插入或者设备创建的时候，就会去调用bus-&gt;match，如果匹配就会调用到probe</li>
</ul>
<p><strong>LED 驱动的简化写法</strong></p>
<pre><code>    设备树片段：
</code></pre>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">led@40000000</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;goko,led&quot;</span><span class="hljs-punctuation">;</span><br>        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0x40000000</span> <span class="hljs-number">0x1000</span>&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure>
<pre><code>    驱动代码：
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">resource</span> *<span class="hljs-title">res</span> =</span> platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">void</span> __iomem *base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);<br>        <span class="hljs-comment">// 注册中断/初始化硬件...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">led_of_match</span>[] =</span> &#123;<br>        &#123; .compatible = <span class="hljs-string">&quot;goko,led&quot;</span>, &#125;,<br>        &#123;&#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">led_driver</span> =</span> &#123;<br>        .probe = led_probe,<br>        .driver = &#123;<br>                .name = <span class="hljs-string">&quot;goko_led&quot;</span>,<br>                .of_match_table = led_of_match,<br>        &#125;,<br>&#125;;<br><br>module_platform_driver(led_driver);<br></code></pre></td></tr></table></figure>

<h1 id="4-中断处理流程-从硬件中断到ISR"><a href="#4-中断处理流程-从硬件中断到ISR" class="headerlink" title="4. 中断处理流程(从硬件中断到ISR)"></a>4. 中断处理流程(从硬件中断到ISR)</h1><ul>
<li>中断产生</li>
<li>响应中断<ul>
<li>保存当前上下文</li>
<li>调转到中断入口（中断向亮表）</li>
<li>进入trap流程，riscv是stvec</li>
</ul>
</li>
<li>GIC&#x2F;PLIC识别中断来源</li>
<li>linux调用handle_irq</li>
<li>最终调用驱动注册的irq</li>
</ul>
<p>结合RISC-V的架构特性（如<code>stvec</code>、<code>scause</code>、PLIC中断控制器）和Linux内核的通用中断子系统来描述。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>中断 (Interrupt):</strong> 外部设备或定时器发出的异步信号，请求CPU的注意和处理。</li>
<li><strong>异常 (Exception):</strong> CPU执行指令时遇到的同步事件（如缺页、非法指令、除以零）。</li>
<li><strong>Trap:</strong> RISC-V中用于统称中断和异常的术语。CPU遇到Trap时会暂停当前执行，跳转到特定的处理入口。</li>
<li><strong>PLIC (Platform-Level Interrupt Controller):</strong> RISC-V系统中常见的外部中断控制器，负责接收来自各个设备的物理中断信号，进行优先级排序、屏蔽，并将最高优先级的中断信号送往CPU。</li>
<li><strong>ISR (Interrupt Service Routine):</strong> 驱动程序中注册的函数，用于处理特定硬件设备产生的中断。通常分为”上半部”（中断处理函数本身，要求快、原子）和”下半部”（延迟处理，如Tasklet、Workqueue）。</li>
</ul>
<p><strong>中断处理详细流程：</strong></p>
<ol>
<li><p><strong>硬件中断产生 (Hardware Interrupt Generation)</strong></p>
<ul>
<li>某个外部硬件设备（如网卡收到数据、磁盘完成读写、定时器到期）需要CPU处理，它会断言（拉高或改变状态）其连接到中断控制器的<strong>物理中断线</strong>。例如：网卡收到数据后，其内部控制器发出一个中断请求信号到连接它的PLIC引脚。</li>
</ul>
</li>
<li><p><strong>中断控制器 (PLIC) 接收并仲裁 (PLIC Receives and Arbitrates)</strong></p>
<ul>
<li>PLIC接收到来自一个或多个设备的物理中断信号。它会根据预设的优先级和使能状态，选择当前最高优先级的、已使能的中断。</li>
<li><strong>PLIC 动作:</strong><ul>
<li>接收来自设备的物理中断。</li>
<li>查找该中断源的优先级和使能状态（通过读写PLIC的寄存器配置）。</li>
<li>如果该中断已使能且优先级高于当前CPU正在处理的或PLCT声明（Claim）的优先级，PLIC会向连接的CPU核心发送一个中断信号（通常是断言CPU的中断输入线，对于Supervisor模式，是Supervisor External Interrupt，通过<code>scause</code>体现为某个特定的值）。</li>
<li>该信号最终会反映在CPU的<code>sip</code> (Supervisor Interrupt Pending) 寄存器的对应位上。对于外部中断，是<code>sip.SEIP</code>位。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>CPU检测到中断并响应 (CPU Detects and Responds to Interrupt)</strong></p>
<ul>
<li>CPU在执行完当前指令后，会检查中断是否发生以及是否被当前CPU模式（这里是Supervisor模式，S-mode）所屏蔽。</li>
<li><strong>检查条件:</strong><ul>
<li>全局中断使能：<code>sstatus</code>寄存器的<code>SIE</code>位必须为1。</li>
<li>中断委托：该中断源必须被委托给S模式处理（<code>sedeleg</code>寄存器中对应位为1）。PLIC外部中断通常是委托给S模式的。</li>
<li>中断挂起：<code>sip</code>寄存器中对应中断的挂起位必须为1 (<code>sip.SEIP</code>)。</li>
<li>优先级：如果RISC-V实现了中断优先级，挂起中断的优先级必须高于当前CPU的优先级阈值。</li>
</ul>
</li>
<li>如果满足以上条件，CPU会暂停当前程序执行。这是一个硬件自动完成的过程。</li>
</ul>
</li>
<li><p><strong>硬件保存部分上下文 (Hardware Saves Partial Context)</strong></p>
<ul>
<li><strong>描述:</strong> 在跳转到Trap处理入口之前，RISC-V CPU硬件会自动保存当前执行状态的关键信息，并将CPU模式切换到Supervisor模式（如果之前不是）。</li>
<li><strong>保存内容:</strong><ul>
<li><strong><code>sepc</code> (Supervisor Exception Program Counter):</strong> 保存发生中断时下一条待执行指令的地址。</li>
<li><strong><code>scause</code> (Supervisor Cause):</strong> 保存Trap发生的原因。对于S模式外部中断，<code>scause</code>的高位为1，低位部分指示是外部中断（一个特定的值，如8或9，取决于是否使用中断向量）。</li>
<li><strong><code>sstatus</code> (Supervisor Status):</strong> <code>sstatus</code>的部分位被修改：<ul>
<li>当前的<code>SIE</code> (Supervisor Interrupt Enable) 状态被保存到<code>sstatus.SPIE</code> (Supervisor Previous Interrupt Enable)。</li>
<li>当前的CPU模式（如果之前是U模式）被保存到<code>sstatus.SPP</code> (Supervisor Previous Privilege)。</li>
<li><code>SIE</code>位被清零，禁用中断，防止嵌套中断（直到软件重新使能）。</li>
<li>当前模式设置为S模式。</li>
</ul>
</li>
</ul>
</li>
<li><strong>相关概念:</strong> <code>sepc</code>, <code>scause</code>, <code>sstatus</code>, <code>sstatus.SPIE</code>, <code>sstatus.SPP</code>。</li>
</ul>
</li>
<li><p><strong>CPU跳转到Trap入口 (<code>stvec</code>) (CPU Jumps to Trap Entry (<code>stvec</code>))</strong></p>
<ul>
<li><strong>描述:</strong> CPU根据<code>stvec</code> (Supervisor Trap Vector) 寄存器的值来确定Trap处理程序的入口地址。</li>
<li><strong><code>stvec</code> 模式:</strong><ul>
<li><strong>Direct Mode (Mode &#x3D; 0):</strong> 所有Trap（包括所有中断和异常）都跳转到<code>stvec</code>指定的同一个地址。Linux通常配置为这种模式。</li>
<li><strong>Vectored Mode (Mode &#x3D; 1):</strong> 中断会根据<code>scause</code>中的中断号偏移到<code>stvec</code>基地址 + (中断号 * 4) 的位置（假设每个向量是4字节指令）。异常仍然跳转到<code>stvec</code>基地址。</li>
</ul>
</li>
<li><strong>CPU 动作:</strong> CPU加载<code>stvec</code>的值到PC寄存器，开始执行Trap处理程序的代码。</li>
<li><strong>相关概念:</strong> <code>stvec</code>, Direct Mode, Vectored Mode。</li>
</ul>
</li>
<li><p><strong>进入内核Trap入口处理程序 (Enter Kernel Trap Entry Handler)</strong></p>
<ul>
<li><strong>描述:</strong> 这是内核中的第一个代码段（通常是汇编语言）被执行的地方。它负责保存剩余的CPU上下文，并调用更高层的C语言中断处理函数。</li>
<li><strong>汇编处理程序动作 (Conceptual Assembly - e.g., <code>kernel_trap</code>):</strong><ul>
<li>保存所有通用寄存器（a0-a7, t0-t6, s0-s11等）到当前任务的内核栈中，形成一个完整的上下文结构（在Linux中通常是<code>struct pt_regs</code>）。</li>
<li>将<code>scause</code>和<code>sepc</code>等CSR寄存器的值保存到<code>pt_regs</code>结构中。</li>
<li>根据需要调整栈指针。</li>
<li>调用更高层的C语言Trap处理函数，例如 <code>handle_exception</code> 或 <code>handle_interrupt_common</code>，将<code>pt_regs</code>结构体的地址作为参数传递。</li>
</ul>
</li>
<li><strong>为什么需要汇编?</strong> C语言函数调用会使用寄存器和栈，汇编程序负责在调用C函数之前保存所有可能被C函数修改的寄存器，并在C函数返回后恢复它们。</li>
<li><strong>相关代码 (Conceptual):</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl kernel_trap<br>kernel_trap:<br>    # Save all general purpose registers onto the stack<br>    SAVE_ALL # Macro that pushes registers x1-x31<br><br>    # Save CSRs like scause, sepc, sstatus into the pt_regs structure on stack<br>    # ... logic to read CSRs and store into pt_regs ...<br><br>    # Load stack pointer into a0 (first arg for C function)<br>    mv a0, sp<br><br>    # Call the generic C handler<br>    call handle_exception # Or handle_interrupt_common<br><br>    # Restore all registers from the stack<br>    RESTORE_ALL # Macro that pops registers x1-x31<br><br>    # Restore scause, sepc, sstatus from pt_regs if needed (e.g. for exception return)<br><br>    # Return from trap<br>    sret<br></code></pre></td></tr></table></figure></li>
<li><strong>相关概念:</strong> <code>struct pt_regs</code>, 保存&#x2F;恢复寄存器宏 (<code>SAVE_ALL</code>, <code>RESTORE_ALL</code>), 内核栈。</li>
</ul>
</li>
<li><p><strong>高层C语言Trap处理 (High-Level C Trap Handling)</strong></p>
<ul>
<li><strong>描述:</strong> <code>handle_exception</code> (或类似函数) 是第一个被调用的C函数。它检查<code>scause</code>来确定Trap的类型（中断还是异常），以及具体的原因。</li>
<li><strong>处理逻辑:</strong><ul>
<li>读取<code>scause</code>寄存器的值。</li>
<li>检查<code>scause</code>的最高位：如果为1，表示是中断；如果为0，表示是异常。</li>
<li><strong>如果是中断:</strong><ul>
<li>进一步检查<code>scause</code>的低位，判断是哪种类型的中断（例如，S模式软件中断、S模式定时器中断、S模式外部中断）。</li>
<li>如果是S模式外部中断（通常通过PLIC到达），则调用外部中断的处理逻辑，例如 <code>handle_interrupt_common</code> 或体系结构相关的中断分发函数。</li>
</ul>
</li>
<li><strong>如果是异常:</strong><ul>
<li>根据<code>scause</code>的低位判断异常类型（如缺页、非法指令、访问错误等）。</li>
<li>调用相应的异常处理函数（如<code>do_page_fault</code>, <code>do_illegal_instruction</code>等）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>相关函数 (Conceptual):</strong> <code>handle_exception</code>, <code>handle_interrupt_common</code>。</li>
</ul>
</li>
<li><p><strong>Linux通用中断分发 (Linux Generic Interrupt Dispatch)</strong></p>
<ul>
<li><strong>描述:</strong> 这是Linux中断子系统的核心部分。对于外部中断，这里需要与中断控制器(PLIC)交互，确定是哪个设备产生了中断，并将中断请求路由到正确的Linux IRQ描述符和处理函数。</li>
<li><strong>处理步骤:</strong><ul>
<li><strong>与PLIC交互 (Claim):</strong> 读取PLIC的Claim寄存器。PLIC返回当前CPU核心上最高优先级的、已使能的挂起外部中断源的ID。这是硬件设备的中断源ID。</li>
<li><strong>查找Linux IRQ号:</strong> 使用中断域 (<code>irq_domain</code>) 子系统，将PLIC返回的硬件中断源ID映射到Linux内核内部使用的虚拟IRQ号。这是Linux抽象设备中断的方式。</li>
<li><strong>查找 <code>irq_desc</code>:</strong> 使用Linux IRQ号作为索引，查找对应的 <code>struct irq_desc</code> 结构体。这个结构体包含中断的状态、统计信息、以及指向中断流处理函数(<code>handle_irq</code>)和注册的中断动作链表 (<code>irq_action</code>) 的指针。</li>
<li><strong>调用中断流处理函数:</strong> 调用 <code>irq_desc</code> 中指向的流处理函数（如 <code>handle_level_irq</code>, <code>handle_edge_irq</code>）。这些函数负责处理特定类型中断的低级细节，例如：<ul>
<li><strong>在此处与PLIC交互 (Completion):</strong> 在适当的时机（通常对于电平触发在调用ISR前，对于边缘触发在ISR后），向PLIC的Completion寄存器写入刚刚处理的PLIC源ID，告诉PLIC该中断已由当前CPU处理。这允许PLIC为同一源生成新的中断（如果是电平触发），或者清除挂起状态。</li>
<li>屏蔽&#x2F;解除屏蔽该IRQ线在PLIC中的中断。</li>
<li>更新中断统计信息。</li>
<li>调用下一层的动作处理函数。</li>
</ul>
</li>
<li><strong>调用动作处理函数:</strong> 流处理函数内部会调用 <code>handle_irq_event_percpu</code> 或类似函数。这个函数负责遍历挂在该IRQ描述符上的所有 <code>struct irq_action</code> 结构体。</li>
</ul>
</li>
<li><strong>相关概念&#x2F;函数:</strong> PLIC Claim&#x2F;Completion Registers, <code>irq_domain</code>, Linux IRQ Number, <code>struct irq_desc</code>, <code>handle_irq</code> (指针在 <code>irq_desc</code> 中), <code>handle_level_irq</code>, <code>handle_edge_irq</code>, <code>handle_irq_event_percpu</code>, <code>struct irq_action</code>.</li>
<li><strong>相关代码 (Conceptual):</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Inside a function called by handle_interrupt_common for external interrupts</span><br>u32 plic_id = plic_claim(cpu); <span class="hljs-comment">// Read PLIC claim register</span><br><br><span class="hljs-keyword">if</span> (plic_id) &#123;<br>    <span class="hljs-comment">// Map PLIC ID to Linux IRQ number</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq = irq_find_mapping(irq_domain, plic_id);<br><br>    <span class="hljs-keyword">if</span> (irq) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_desc</span> *<span class="hljs-title">desc</span> =</span> irq_to_desc(irq);<br>        <span class="hljs-keyword">if</span> (desc &amp;&amp; desc-&gt;handle_irq) &#123;<br>            <span class="hljs-comment">// Call the flow handler (e.g., handle_level_irq)</span><br>            desc-&gt;handle_irq(irq, desc); <span class="hljs-comment">// This will eventually call the action handler</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// plic_complete(cpu, plic_id); // This is usually done *inside* the flow handler (e.g. handle_level_irq)</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>执行驱动注册的ISR (Execute Driver’s Registered ISR)</strong></p>
<ul>
<li><strong>描述:</strong> <code>handle_irq_event_percpu</code> 遍历 <code>irq_desc</code> 中的 <code>action</code> 链表，逐一调用驱动程序通过 <code>request_irq</code> 函数注册的中断处理函数（ISR）。</li>
<li><strong><code>request_irq</code> 函数:</strong> 驱动程序使用此函数向内核注册其中断处理函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Driver code example</span><br><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">my_device_isr</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    <span class="hljs-comment">// data is often a pointer to the device structure</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_device</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> my_device *)data;<br><br>    <span class="hljs-comment">// --- Top Half (ISR) ---</span><br>    <span class="hljs-comment">// Must be FAST and ATOMIC (cannot sleep, acquire mutexes, etc.)</span><br>    <span class="hljs-comment">// Acknowledge the device hardware (clear interrupt status bits on the device)</span><br>    <span class="hljs-comment">// Read necessary status/data from device (quickly)</span><br>    <span class="hljs-comment">// Schedule bottom half work if needed (tasklet_schedule, schedule_work)</span><br>    <span class="hljs-comment">// --- End Top Half ---</span><br><br>    <span class="hljs-comment">// Return status:</span><br>    <span class="hljs-comment">// IRQ_HANDLED: This handler processed the interrupt.</span><br>    <span class="hljs-comment">// IRQ_NONE: This handler did not recognize/handle the interrupt (e.g., shared interrupt line).</span><br>    <span class="hljs-keyword">return</span> IRQ_HANDLED;<br>&#125;<br><br><span class="hljs-comment">// In driver initialization code:</span><br><span class="hljs-type">int</span> ret = request_irq(device_irq_number, <span class="hljs-comment">// The Linux IRQ number for this device</span><br>                      my_device_isr,     <span class="hljs-comment">// Pointer to the ISR function</span><br>                      IRQF_SHARED,       <span class="hljs-comment">// Flags, e.g., allow sharing</span><br>                      <span class="hljs-string">&quot;my_device&quot;</span>,       <span class="hljs-comment">// Name for /proc/interrupts</span><br>                      my_device_struct_ptr); <span class="hljs-comment">// Data passed to the ISR</span><br><span class="hljs-keyword">if</span> (ret) &#123;<br>    <span class="hljs-comment">// Error handling</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong><code>irq_handler_t</code> 类型:</strong> 这是ISR函数的类型定义：<code>typedef irqreturn_t (*irq_handler_t)(int, void *);</code></li>
<li><strong>执行流程:</strong> <code>handle_irq_event_percpu</code> 会像这样调用注册的函数（简化）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Inside handle_irq_event_percpu</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">irq_action</span> *<span class="hljs-title">action</span>;</span><br><span class="hljs-type">irqreturn_t</span> action_ret;<br><span class="hljs-type">irqreturn_t</span> overall_ret = IRQ_NONE;<br><br>list_for_each_entry(action, &amp;desc-&gt;action, <span class="hljs-built_in">list</span>) &#123;<br>    <span class="hljs-comment">// Call the driver&#x27;s ISR</span><br>    action_ret = action-&gt;handler(irq, action-&gt;dev_id);<br><br>    <span class="hljs-comment">// Update overall return status if handled</span><br>    <span class="hljs-keyword">if</span> (action_ret == IRQ_HANDLED)<br>        overall_ret = IRQ_HANDLED;<br><br>    <span class="hljs-comment">// Handle return values (e.g., logging if IRQ_NONE on non-shared IRQ)</span><br>&#125;<br><span class="hljs-comment">// The overall_ret is often returned up the call stack</span><br></code></pre></td></tr></table></figure></li>
<li><strong>相关概念&#x2F;函数:</strong> <code>request_irq</code>, <code>irq_handler_t</code>, <code>irqreturn_t</code> (<code>IRQ_HANDLED</code>, <code>IRQ_NONE</code>), <code>struct irq_action</code>, 中断共享 (<code>IRQF_SHARED</code>), 上半部 vs. 下半部。</li>
</ul>
</li>
<li><p><strong>中断返回 (Interrupt Return)</strong></p>
<ul>
<li><strong>描述:</strong> 驱动ISR执行完毕并返回后，控制权层层返回到最初的汇编Trap入口程序。</li>
<li><strong>汇编处理程序动作 (Conceptual Assembly - <code>kernel_trap</code> return path):</strong><ul>
<li><code>handle_exception</code> (或类似函数) 返回到汇编程序。</li>
<li>汇编程序从栈中恢复所有通用寄存器的值（之前 <code>SAVE_ALL</code> 保存的）。</li>
<li>根据需要恢复<code>sstatus</code>和<code>sepc</code>的值（例如，如果Trap是异常，可能需要调整<code>sepc</code>）。</li>
<li>执行 <code>sret</code> (Supervisor Return) 指令。</li>
</ul>
</li>
<li><strong>CPU 动作:</strong> <code>sret</code> 指令是RISC-V中从Trap返回的指令。它会自动：<ul>
<li>将 <code>sepc</code> 的值加载到PC寄存器。</li>
<li>将 <code>sstatus.SPIE</code> 的值复制到 <code>sstatus.SIE</code>（恢复中断使能状态）。</li>
<li>将 <code>sstatus.SPP</code> 的值复制到当前CPU模式（恢复到Trap发生前的模式，通常是U或S）。</li>
<li>清除 <code>sstatus.SPIE</code> 和 <code>sstatus.SPP</code>。</li>
</ul>
</li>
<li><strong>最终结果:</strong> CPU恢复到Trap发生之前的模式，并从<code>sepc</code>指向的指令处继续执行中断前的程序。</li>
<li><strong>相关概念&#x2F;指令:</strong> <code>sret</code>, 寄存器恢复 (<code>RESTORE_ALL</code>)。</li>
</ul>
</li>
</ol>
<p><strong>总结流程图示 (简化):</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">硬件设备 -&gt; PLIC -&gt; CPU (检查SIE, SEDELEG, SEIP)<br>     |                |<br>     v                v<br> (发出物理中断)   (响应中断)<br>                      |<br>                      v<br>               硬件保存上下文 (sepc, scause, sstatus)<br>                      |<br>                      v<br>               CPU读取 stvec<br>                      |<br>                      v<br>            跳转到内核 Trap 入口 (汇编)<br>                      |<br>                      v<br>         汇编保存完整上下文 (pt_regs)<br>                      |<br>                      v<br>          调用 C 语言 Trap 分发 (handle_exception)<br>                      |<br>                      v  (如果 scause 指示是外部中断)<br>          检查 scause, 调用外部中断处理 (handle_interrupt_common)<br>                      |<br>                      v<br>          读取 PLIC Claim -&gt; 获取 PLIC ID<br>                      |<br>                      v<br>          irq_domain 映射 PLIC ID -&gt; Linux IRQ 号<br>                      |<br>                      v<br>          查找 irq_desc -&gt; 获取 handle_irq (流处理函数)<br>                      |<br>                      v<br>          调用 流处理函数 (handle_level_irq/handle_edge_irq)<br>                      |    (流处理函数在适当时候写 PLIC Complete)<br>                      v<br>          调用 动作处理函数 (handle_irq_event_percpu)<br>                      |<br>                      v  (遍历 struct irq_action 链表)<br>         调用 驱动注册的 ISR (irq_handler_t function) &lt;------- request_irq 注册的函数<br>                      |<br>                      v<br>            ISR 返回 (IRQ_HANDLED/IRQ_NONE)<br>                      |<br>                      v<br>          动作处理函数返回<br>                      |<br>                      v<br>          流处理函数返回<br>                      |<br>                      v<br>          C 语言 Trap 分发返回<br>                      |<br>                      v<br>          汇编 Trap 入口程序恢复上下文 (RESTORE_ALL)<br>                      |<br>                      v<br>             执行 sret 指令<br>                      |<br>                      v<br>            CPU 返回到中断前的程序继续执行<br></code></pre></td></tr></table></figure>

<h1 id="5-内核空间和用户空间的通信方式"><a href="#5-内核空间和用户空间的通信方式" class="headerlink" title="5. 内核空间和用户空间的通信方式"></a>5. 内核空间和用户空间的通信方式</h1><h3 id="总结与对比："><a href="#总结与对比：" class="headerlink" title="总结与对比："></a>总结与对比：</h3><table>
<thead>
<tr>
<th align="left">特性&#x2F;通信方式</th>
<th align="left"><code>ioctl</code></th>
<th align="left"><code>procfs</code></th>
<th align="left"><code>sysfs</code></th>
<th align="left"><code>netlink</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>用途</strong></td>
<td align="left">复杂控制命令、设备特定操作</td>
<td align="left">文本形式的内核信息、调试</td>
<td align="left">属性管理、设备模型暴露、配置参数</td>
<td align="left">复杂、异步、双向通信、事件通知</td>
</tr>
<tr>
<td align="left"><strong>数据格式</strong></td>
<td align="left">任意结构体或原始数据</td>
<td align="left">文本字符串</td>
<td align="left">文本字符串 (单值属性)</td>
<td align="left">结构化二进制消息 (Netlink协议)</td>
</tr>
<tr>
<td align="left"><strong>通信方向</strong></td>
<td align="left">双向 (同步请求-响应)</td>
<td align="left">双向 (同步读写)</td>
<td align="left">双向 (同步读写)</td>
<td align="left">双向、异步、支持单播&#x2F;多播&#x2F;广播</td>
</tr>
<tr>
<td align="left"><strong>API</strong></td>
<td align="left">基于文件描述符和 <code>ioctl()</code></td>
<td align="left">基于文件 I&#x2F;O (<code>open</code>, <code>read</code>, <code>write</code>)</td>
<td align="left">基于文件 I&#x2F;O (<code>open</code>, <code>read</code>, <code>write</code>)</td>
<td align="left">基于套接字 (<code>socket</code>, <code>sendmsg</code>, <code>recvmsg</code>)</td>
</tr>
<tr>
<td align="left"><strong>复杂性</strong></td>
<td align="left">中等偏上 (需要手动拷贝)</td>
<td align="left">简单 (文本处理)</td>
<td align="left">中等 (Kobject&#x2F;Attribute 机制)</td>
<td align="left">较高 (套接字、消息解析)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">较高 (直接拷贝数据)</td>
<td align="left">较低 (文本解析开销)</td>
<td align="left">中等 (文本解析开销)</td>
<td align="left">较高 (原生套接字、二进制消息)</td>
</tr>
<tr>
<td align="left"><strong>典型示例</strong></td>
<td align="left">显卡驱动模式设置，网卡MAC地址</td>
<td align="left"><code>/proc/cpuinfo</code>, <code>/proc/meminfo</code></td>
<td align="left"><code>/sys/class/gpio/gpiochipX/direction</code></td>
<td align="left"><code>ip</code> 命令配置网络，<code>udev</code> 监视事件</td>
</tr>
<tr>
<td align="left"><strong>RISC-V 特性</strong></td>
<td align="left">作为系统调用，API通用，底层ABI遵循RISC-V约定</td>
<td align="left">完全通用</td>
<td align="left">完全通用，与Linux设备模型紧密结合</td>
<td align="left">完全通用，作为网络栈组件</td>
</tr>
</tbody></table>
<h1 id="6-Linux-的内存管理机制"><a href="#6-Linux-的内存管理机制" class="headerlink" title="6. Linux 的内存管理机制"></a>6. Linux 的内存管理机制</h1><h1 id="7-驱动中的-probe-函数-调用流程是"><a href="#7-驱动中的-probe-函数-调用流程是" class="headerlink" title="7. 驱动中的 probe 函数, 调用流程是"></a>7. 驱动中的 probe 函数, 调用流程是</h1><p>name<br>of_match_table<br>acpi</p>
</div><div class="index-category-tag">  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/interview/">interview</a></div><hr></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/logo.png" alt="GoKo Mell"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GoKo Mell</p><p class="is-size-6 is-block">尚未执佩剑，转眼即江湖</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GoKo-Son626" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/GoKo-Son626"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:goku.sonxin626@gmail.com"><i class="fa fa-envelope"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-25T02:02:38.000Z">2025-05-25</time></p><p class="title"><a href="/post/wds-IIC.html">IIC</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-24T13:26:58.000Z">2025-05-24</time></p><p class="title"><a href="/post/Troy-interview.html">Troy-interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-19T19:02:36.000Z">2025-05-20</time></p><p class="title"><a href="/post/start-kerneling.html">start-kerneling</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-18T08:30:56.000Z">2025-05-18</time></p><p class="title"><a href="/post/riscv-toolchains.html">riscv-toolchains</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-17T14:25:22.000Z">2025-05-17</time></p><p class="title"><a href="/post/Trace-use-3.html">Trace-use-3</a></p></div></article></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/xv6-riscv/"><span class="tag">xv6-riscv</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Trace/"><span class="tag">Trace</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interview/"><span class="tag">interview</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel-start/"><span class="tag">kernel-start</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-dirvers/"><span class="tag">linux-dirvers</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/riscv/"><span class="tag">riscv</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/riscv-toolchain/"><span class="tag">riscv-toolchain</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/GoKo-Mell.png" alt="GoKo&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2025 GoKo Mell</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="mailto:goku.sonxin626@gmail.com">联系我</a>，立即处理]<br /></span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('Ov23liQkUSIVMH77fBvF','7944864208d7577569d1f323e727967d4bdc5e79','GoKo-Son626','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>xv6-riscv_ch3 - GoKo&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="GoKo&#039;s blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GoKo&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="This chapter covers the fundamental concepts of paging hardware, memory allocation, and process address space management, including practical code implementations like creating address spaces, physic"><meta property="og:type" content="blog"><meta property="og:title" content="GoKo"><meta property="og:url" content="https://goko-son626.github.io/"><meta property="og:site_name" content="GoKo"><meta property="og:description" content="This chapter covers the fundamental concepts of paging hardware, memory allocation, and process address space management, including practical code implementations like creating address spaces, physic"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><meta property="article:published_time" content="2025-05-06T01:25:24.000Z"><meta property="article:modified_time" content="2025-05-12T04:33:42.088Z"><meta property="article:author" content="GoKo Mell"><meta property="article:tag" content="xv6-riscv"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://goko-son626.github.io/post/xv6-riscv-ch3.html"},"headline":"GoKo's blog","image":["https://goko-son626.github.io/post/xv6-riscv-ch3/image.png","https://goko-son626.github.io/post/xv6-riscv-ch3/image-1.png","https://goko-son626.github.io/post/xv6-riscv-ch3/image-2.png","https://goko-son626.github.io/post/xv6-riscv-ch3/image-3.png"],"datePublished":"2025-05-06T01:25:24.000Z","dateModified":"2025-05-12T04:33:42.088Z","author":{"@type":"Person","name":"GoKo Mell"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"This chapter covers the fundamental concepts of paging hardware, memory allocation, and process address space management, including practical code implementations like creating address spaces, physic"}</script><link rel="canonical" href="https://goko-son626.github.io/post/xv6-riscv-ch3.html"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/rss.xml" title="GoKo's blog" type="application/rss+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/GoKo-Mell.png" alt="GoKo&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/friend">Friend</a></div><div class="navbar-end"><a class="navbar-item search" title="æœç´¢" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus">Â </i>2025-05-06Â Â <a class="commentCountImg" href="/post/xv6-riscv-ch3.html#comment-container"><span class="display-none-class">36688d334cb3e1304bf54945350ea348</span><i class="far fa-comment-dots"></i>Â <span class="commentCount" id="36688d334cb3e1304bf54945350ea348">99+</span>Â Â </a><span class="level-item"><i class="far fa-clock">Â </i>1 å°æ—¶ Â <i class="fas fa-pencil-alt">Â </i>6.8Â k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>æ¬¡è®¿é—®</span></div></div><h1 class="title is-3 is-size-4-mobile">xv6-riscv_ch3</h1><div class="content"><ul>
<li><em><strong>This chapter covers the fundamental concepts of paging hardware, memory allocation, and process address space management, including practical code implementations like creating address spaces, physical memory allocation, and process management functions such as <code>sbrk</code> and <code>exec</code>.</strong></em></li>
</ul>
<span id="more"></span>

<h2 id="ch3-Page-tables"><a href="#ch3-Page-tables" class="headerlink" title="ch3: Page tables"></a><strong>ch3: Page tables</strong></h2><ul>
<li>Page tables are the most popular mechanism through which the operating system provides each process with its own private address space and memory.</li>
<li>Xv6 performs a few tricks: mapping the same memory (a trampoline page) in several address spaces, and guarding kernel and user stacks with an unmapped page. The rest of this chapter explains the page tables that the RISC-V hardware provides and how xv6 uses them.</li>
</ul>
<h3 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1 Paging hardware"></a>3.1 Paging hardware</h3><ul>
<li>As a reminder, RISC-V instructions (both user and kernel) manipulate virtual addresses. The machineâ€™s RAM, or physical memory, is indexed with physical addresses. The RISC-V page table hardware connects these two kinds of addresses, by mapping each virtual address to a physical address.</li>
<li>Xv6 runs on Sv39 RISC-V, which means that only the bottom 39 bits of a 64-bit virtual address are used; the top 25 bits are not used. In this Sv39 configuration, a RISC-V page table is logically an array of 227 (134,217,728) page table entries (PTEs). Each PTE contains a 44-bit physical page number (PPN) and some flags. The paging hardware translates a virtual address by using the top 27 bits of the 39 bits to index into the page table to find a PTE, and making a 56-bit physical address whose top 44 bits come from the PPN in the PTE and whose bottom 12 bits are copied from the original virtual address. Figure 3.1 shows this process with a logical view of the page table as a simple array of PTEs (see Figure 3.2 for a fuller story). A page table gives the operating system control over virtual-to-physical address translations at the granularity of aligned chunks of 4096 (212 ) bytes. Such a chunk is called a page.<br><img src="/post/xv6-riscv-ch3/image.png" alt="alt text"></li>
<li>In Sv39 RISC-V, the top 25 bits of a virtual address are not used for translation. The physical<br>address also has room for growth: there is room in the PTE format for the physical page number<br>to grow by another 10 bits. The designers of RISC-V chose these numbers based on technology<br>predictions. 239 bytes is 512 GB, which should be enough address space for applications running on RISC-V computers. 256 is enough physical memory space for the near future to fit many I&#x2F;O<br>devices and RAM chips. If more is needed, the RISC-V designers have defined Sv48 with 48-bit<br>virtual addresses [3].</li>
<li>As Figure 3.2 shows, a RISC-V CPU translates a virtual address into a physical in three steps.<br>A page table is stored in physical memory as a three-level tree. The root of the tree is a 4096-byte<br>page-table page that contains 512 PTEs, which contain the physical addresses for page-table pages<br>in the next level of the tree. Each of those pages contains 512 PTEs for the final level in the tree.<br>The paging hardware uses the top 9 bits of the 27 bits to select a PTE in the root page-table page,<br>the middle 9 bits to select a PTE in a page-table page in the next level of the tree, and the bottom<br>9 bits to select the final PTE. (In Sv48 RISC-V a page table has four levels, and bits 39 through 47<br>of a virtual address index into the top-level.)<br>If any of the three PTEs required to translate an address is not present, the paging hardware<br>raises a page-fault exception, leaving it up to the kernel to handle the exception (see Chapter 4).<br>The three-level structure of Figure 3.2 allows a memory-efficient way of recording PTEs, com-<br>pared to the single-level design of Figure 3.1. In the common case in which large ranges of virtual<br>addresses have no mappings, the three-level structure can omit entire page directories. For exam-<br>ple, if an application uses only a few pages starting at address zero, then the entries 1 through 511<br>of the top-level page directory are invalid, and the kernel doesnâ€™t have to allocate pages those for<br>511 intermediate page directories. Furthermore, the kernel also doesnâ€™t have to allocate pages for<br>the bottom-level page directories for those 511 intermediate page directories. So, in this example,<br>the three-level design saves 511 pages for intermediate page directories and 511 Ã— 512 pages for<br>bottom-level page directories.<br>Although a CPU walks the three-level structure in hardware as part of executing a load or store<br>instruction, a potential downside of three levels is that the CPU must load three PTEs from memory<br>to perform the translation of the virtual address in the load&#x2F;store instruction to a physical address.<br>To avoid the cost of loading PTEs from physical memory, a RISC-V CPU caches page table entries<br>in a Translation Look-aside Buffer (TLB).<br><img src="/post/xv6-riscv-ch3/image-1.png" alt="alt text"><br>allowed to be used. PTE_V indicates whether the PTE is present: if it is not set, a reference to the<br>page causes an exception (i.e., is not allowed). PTE_R controls whether instructions are allowed<br>to read to the page. PTE_W controls whether instructions are allowed to write to the page. PTE_X<br>controls whether the CPU may interpret the content of the page as instructions and execute them.<br>PTE_U controls whether instructions in user mode are allowed to access the page; if PTE_U is not<br>set, the PTE can be used only in supervisor mode. Figure 3.2 shows how it all works. The flags and<br>all other page hardware-related structures are defined in (kernel&#x2F;riscv.h)</li>
<li>To tell a CPU to use a page table, the kernel must write the physical address of the root page-<br>table page into the satp register. A CPU will translate all addresses generated by subsequent<br>instructions using the page table pointed to by its own satp. Each CPU has its own satp so that<br>different CPUs can run different processes, each with a private address space described by its own<br>page table.</li>
<li><strong>notice</strong>:A few notes about terms used in this book. Physical memory refers to storage cells in RAM.<br>A byte of physical memory has an address, called a physical address. Instructions that dereference<br>addresses (such as loads, stores, jumps, and function calls) use only virtual addresses, which the<br>paging hardware translates to physical addresses, and then sends to the RAM hardware to read or<br>write storage. An address space is the set of virtual addresses that are valid in a given page table; each xv6 process has a separate user address space, and the xv6 kernel has its own address space as<br>well. User memory refers to a processâ€™s user address space plus the physical memory that the page<br>table allows the process to access. Virtual memory refers to the ideas and techniques associated<br>with managing page tables and using them to achieve goals such as isolation.<br><img src="/post/xv6-riscv-ch3/image-2.png" alt="alt text"></li>
</ul>
<h3 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2 Kernel address space"></a>3.2 Kernel address space</h3><ul>
<li>Xv6 maintains one page table per process, describing each processâ€™s user address space, plus a sin-<br>gle page table that describes the kernelâ€™s address space. The kernel configures the layout of its ad-<br>dress space to give itself access to physical memory and various hardware resources at predictable virtual addresses. Figure 3.3 shows how this layout maps kernel virtual addresses to physical addresses. The file (kernel&#x2F;memlayout.h) declares the constants for xv6â€™s kernel memory layout.</li>
<li>The kernel gets at RAM and memory-mapped device registers using â€œdirect mapping;â€ that<br>is, mapping the resources at virtual addresses that are equal to the physical address. For example,<br>the kernel itself is located at KERNBASE&#x3D;0x80000000 in both the virtual address space and in<br>physical memory. Direct mapping simplifies kernel code that reads or writes physical memory.</li>
<li>There are a couple of kernel virtual addresses that arenâ€™t direct-mapped:<ul>
<li>The trampoline page. It is mapped at the top of the virtual address space; user page tables have this same mapping. Chapter 4 discusses the role of the trampoline page, but we see here an interesting use case of page tables; a physical page (holding the trampoline code) is mapped twice in the virtual address space of the kernel: once at top of the virtual address space and once with a direct mapping.</li>
<li>The kernel stack pages. Each process has its own kernel stack, which is mapped high so that below it xv6 can leave an unmapped guard page. The guard pageâ€™s PTE is invalid (i.e., PTE_V is not set), so that if the kernel overflows a kernel stack, it will likely cause an exception and the kernel will panic. Without a guard page an overflowing stack would overwrite other kernel memory, resulting in incorrect operation. A panic crash is preferable.</li>
</ul>
</li>
</ul>
<h3 id="3-3-Code-creating-an-address-space"><a href="#3-3-Code-creating-an-address-space" class="headerlink" title="3.3 Code: creating an address space"></a>3.3 Code: creating an address space</h3><ul>
<li>Most of the xv6 code for manipulating address spaces and page tables resides in vm.c (kernel&#x2F;vm.c:1). The central data structure is pagetable_t, which is really a pointer to a RISC-V root page-table page; a pagetable_t may be either the kernel page table, or one of the per-process page tables. The central functions are walk, which finds the PTE for a virtual address,and mappages, which installs PTEs for new mappings. Functions starting with kvm manipulate the kernel page table; functions starting with uvm manipulate a user page table; other functions are used for both. copyout and copyin copy data to and from user virtual addresses provided as system call arguments; they are in vm.c because they need to explicitly translate those addresses in order to find the corresponding physical memory.</li>
<li>Early in the boot sequence, main calls kvminit (kernel&#x2F;vm.c:54) to create the kernelâ€™s page ta-<br>ble using kvmmake (kernel&#x2F;vm.c:20). This call occurs before xv6 has enabled paging on the RISC-V,<br>so addresses refer directly to physical memory. kvmmake first allocates a page of physical mem-<br>ory to hold the root page-table page. Then it calls kvmmap to install the translations that the kernel<br>needs. The translations include the kernelâ€™s instructions and data, physical memory up to PHYSTOP,<br>and memory ranges which are actually devices. proc_mapstacks (kernel&#x2F;proc.c:33) allocates a<br>kernel stack for each process. It calls kvmmap to map each stack at the virtual address generated<br>by KSTACK, which leaves room for the invalid stack-guard pages.</li>
<li><code>kvmmap</code> (kernel&#x2F;vm.c:132) calls mappages (kernel&#x2F;vm.c:144), which installs mappings into a<br>page table for a range of virtual addresses to a corresponding range of physical addresses. It does<br>this separately for each virtual address in the range, at page intervals. For each virtual address to<br>be mapped, mappages calls walk to find the address of the PTE for that address. It then initializes<br>the PTE to hold the relevant physical page number, the desired permissions (PTE_W, PTE_X, and&#x2F;or<br>PTE_R), and PTE_V to mark the PTE as valid (kernel&#x2F;vm.c:165).</li>
<li><code>walk</code> (kernel&#x2F;vm.c:86) mimics the RISC-V paging hardware as it looks up the PTE for a virtual<br>address (see Figure 3.2). walk descends the page table one level at a time, using each levelâ€™s 9<br>bits of virtual address to index into the relevant page directory page. At each level it finds either<br>the PTE of the next levelâ€™s page directory page, or the PTE of final page (kernel&#x2F;vm.c:92). If a PTE<br>in a first or second level page directory page isnâ€™t valid, then the required directory page hasnâ€™t<br>yet been allocated; if the alloc argument is set, walk allocates a new page-table page and puts<br>its physical address in the PTE. It returns the address of the PTE in the lowest layer in the tree<br>(kernel&#x2F;vm.c:102).</li>
<li>main calls kvminithart (kernel&#x2F;vm.c:62) to install the kernel page table. It writes the physical<br>address of the root page-table page into the register satp. After this the CPU will translate ad-<br>dresses using the kernel page table. Since the kernel uses a direct mapping, the now virtual address<br>of the next instruction will map to the right physical memory address.</li>
<li>Each RISC-V CPU caches page table entries in a Translation Look-aside Buffer (TLB), and<br>when xv6 changes a page table, it must tell the CPU to invalidate corresponding cached TLB<br>entries. If it didnâ€™t, then at some point later the TLB might use an old cached mapping, point-<br>ing to a physical page that in the meantime has been allocated to another process, and as a re-<br>sult, a process might be able to scribble on some other processâ€™s memory. The RISC-V has an instruction sfence.vma that flushes the current CPUâ€™s TLB. Xv6 executes sfence.vma in<br>kvminithart after reloading the satp register, and in the trampoline code that switches to a<br>user page table before returning to user space (kernel&#x2F;trampoline.S:89).<br>It is also necessary to issue sfence.vma before changing satp, in order to wait for comple-<br>tion of all outstanding loads and stores. This wait ensures that preceding updates to the page table<br>have completed, and ensures that preceding loads and stores use the old page table, not the new<br>one.<br>To avoid flushing the complete TLB, RISC-V CPUs may support address space identifiers<br>(ASIDs) [3]. The kernel can then flush just the TLB entries for a particular address space. Xv6<br>does not use this feature.</li>
</ul>
<h3 id="3-4-Physical-memory-allocation"><a href="#3-4-Physical-memory-allocation" class="headerlink" title="3.4 Physical memory allocation"></a>3.4 Physical memory allocation</h3><ul>
<li>The kernel must allocate and free physical memory at run-time for page tables, user memory,<br>kernel stacks, and pipe buffers.</li>
<li>Xv6 uses the physical memory between the end of the kernel and PHYSTOP for run-time alloca-<br>tion. It allocates and frees whole 4096-byte pages at a time. It keeps track of which pages are free<br>by threading a linked list through the pages themselves. Allocation consists of removing a page<br>from the linked list; freeing consists of adding the freed page to the list.</li>
</ul>
<h3 id="3-5-Code-Physical-memory-allocator"><a href="#3-5-Code-Physical-memory-allocator" class="headerlink" title="3.5 Code: Physical memory allocator"></a>3.5 Code: Physical memory allocator</h3><ul>
<li>The allocator resides in kalloc.c (kernel&#x2F;kalloc.c:1). The allocatorâ€™s data structure is a free list<br>of physical memory pages that are available for allocation. Each free pageâ€™s list element is a<br>struct run (kernel&#x2F;kalloc.c:17). Where does the allocator get the memory to hold that data struc-<br>ture? It store each free pageâ€™s run structure in the free page itself, since thereâ€™s nothing else stored<br>there. The free list is protected by a spin lock (kernel&#x2F;kalloc.c:21-24). The list and the lock are<br>wrapped in a struct to make clear that the lock protects the fields in the struct. For now, ignore the<br>lock and the calls to acquire and release; Chapter 6 will examine locking in detail.<br>The function main calls kinit to initialize the allocator (kernel&#x2F;kalloc.c:27). kinit initializes<br>the free list to hold every page between the end of the kernel and PHYSTOP. Xv6 ought to de-<br>termine how much physical memory is available by parsing configuration information provided<br>by the hardware. Instead xv6 assumes that the machine has 128 megabytes of RAM. kinit calls<br>freerange to add memory to the free list via per-page calls to kfree. A PTE can only refer to<br>a physical address that is aligned on a 4096-byte boundary (is a multiple of 4096), so freerange<br>uses PGROUNDUP to ensure that it frees only aligned physical addresses. The allocator starts with<br>no memory; these calls to kfree give it some to manage.<br>The allocator sometimes treats addresses as integers in order to perform arithmetic on them<br>(e.g., traversing all pages in freerange), and sometimes uses addresses as pointers to read and<br>write memory (e.g., manipulating the run structure stored in each page); this dual use of addresses<br>is the main reason that the allocator code is full of C type casts.<br>The function kfree (kernel&#x2F;kalloc.c:47) begins by setting every byte in the memory being freed<br>to the value 1. This will cause code that uses memory after freeing it (uses â€œdangling referencesâ€)<br>to read garbage instead of the old valid contents; hopefully that will cause such code to break faster.<br>Then kfree prepends the page to the free list: it casts pa to a pointer to struct run, records the<br>old start of the free list in r-&gt;next, and sets the free list equal to r. kalloc removes and returns<br>the first element in the free list.</li>
</ul>
<h3 id="3-6-Process-address-space"><a href="#3-6-Process-address-space" class="headerlink" title="3.6 Process address space"></a>3.6 Process address space</h3><p><img src="/post/xv6-riscv-ch3/image-3.png" alt="alt text"></p>
<ul>
<li>Each process has its own page table, and when xv6 switches between processes, it also changes<br>page tables. Figure 3.4 shows a processâ€™s address space in more detail than Figure 2.3. A processâ€™s<br>user memory starts at virtual address zero and can grow up to MAXVA (kernel&#x2F;riscv.h:375), allowing<br>a process to address in principle 256 Gigabytes of memory.<br>A processâ€™s address space consists of pages that contain the text of the program (which xv6<br>maps with the permissions PTE_R, PTE_X, and PTE_U), pages that contain the pre-initialized data<br>of the program, a page for the stack, and pages for the heap. Xv6 maps the data, stack, and heap<br>with the permissions PTE_R, PTE_W, and PTE_U.<br>Using permissions within a user address space is a common technique to harden a user process.<br>If the text were mapped with PTE_W, then a process could accidentally modify its own program;<br>for example, a programming error may cause the program to write to a null pointer, modifying<br>instructions at address 0, and then continue running, perhaps creating more havoc. To detect such<br>errors immediately, xv6 maps the text without PTE_W; if a program accidentally attempts to store<br>to address 0, the hardware will refuse to execute the store and raises a page fault (see Section 4.6).<br>The kernel then kills the process and prints out an informative message so that the developer can<br>track down the problem.<br>Similarly, by mapping data without PTE_X, a user program cannot accidentally jump to an<br>address in the programâ€™s data and start executing at that address.<br>In the real world, hardening a process by setting permissions carefully also aids in defending<br>against security attacks. An adversary may feed carefully-constructed input to a program (e.g., a<br>Web server) that triggers a bug in the program in the hope of turning that bug into an exploit [14].<br>Setting permissions carefully and other techniques, such as randomizing of the layout of the user<br>address space, make such attacks harder.<br>The stack is a single page, and is shown with the initial contents as created by exec. Strings<br>containing the command-line arguments, as well as an array of pointers to them, are at the very<br>top of the stack. Just under that are values that allow a program to start at main as if the function<br>main(argc, argv) had just been called.<br>To detect a user stack overflowing the allocated stack memory, xv6 places an inaccessible guard<br>page right below the stack by clearing the PTE_U flag. If the user stack overflows and the process<br>tries to use an address below the stack, the hardware will generate a page-fault exception because<br>the guard page is inaccessible to a program running in user mode. A real-world operating system<br>might instead automatically allocate more memory for the user stack when it overflows.<br>When a process asks xv6 for more user memory, xv6 grows the processâ€™s heap. Xv6 first uses kalloc to allocate physical pages. It then adds PTEs to the processâ€™s page table that point to the<br>new physical pages. Xv6 sets the PTE_W, PTE_R, PTE_U, and PTE_V flags in these PTEs. Most<br>processes do not use the entire user address space; xv6 leaves PTE_V clear in unused PTEs.<br>We see here a few nice examples of use of page tables. First, different processesâ€™ page tables<br>translate user addresses to different pages of physical memory, so that each process has private user<br>memory. Second, each process sees its memory as having contiguous virtual addresses starting at<br>zero, while the processâ€™s physical memory can be non-contiguous. Third, the kernel maps a page<br>with trampoline code at the top of the user address space (without PTE_U), thus a single page of<br>physical memory shows up in all address spaces, but can be used only by the kernel.<br>3.4<br>ç‰©ç†å†…å­˜åˆ†é…<br>å†…æ ¸å¿…é¡»åœ¨è¿è¡Œæ—¶ä¸ºé¡µè¡¨ã€ç”¨æˆ·å†…å­˜ã€å†…æ ¸æ ˆå’Œç®¡é“ç¼“å†²åŒºåˆ†é…å’Œé‡Šæ”¾ç‰©ç†å†…å­˜ã€‚<br>Xv6 ä½¿ç”¨å†…æ ¸ç»“æŸä½ç½®åˆ° PHYSTOP ä¹‹é—´çš„ç‰©ç†å†…å­˜è¿›è¡Œè¿è¡Œæ—¶åˆ†é…ã€‚å®ƒä¸€æ¬¡åˆ†é…å’Œé‡Šæ”¾æ•´ä¸ª 4096 å­—èŠ‚å¤§å°çš„é¡µã€‚å®ƒé€šè¿‡åœ¨é¡µè‡ªèº«ä¸­ç©¿æ’ä¸€ä¸ªé“¾è¡¨æ¥è·Ÿè¸ªå“ªäº›é¡µæ˜¯ç©ºé—²çš„ã€‚åˆ†é…æ“ä½œåŒ…æ‹¬ä»é“¾è¡¨ä¸­ç§»é™¤ä¸€ä¸ªé¡µï¼›é‡Šæ”¾æ“ä½œåˆ™åŒ…æ‹¬å°†é‡Šæ”¾çš„é¡µæ·»åŠ åˆ°é“¾è¡¨ä¸­ã€‚</li>
</ul>
<p>3.5<br>ä»£ç ï¼šç‰©ç†å†…å­˜åˆ†é…å™¨<br>åˆ†é…å™¨ä½äº kalloc.cï¼ˆkernel&#x2F;kalloc.c:1ï¼‰æ–‡ä»¶ä¸­ã€‚åˆ†é…å™¨çš„æ•°æ®ç»“æ„æ˜¯ä¸€ä¸ªç©ºé—²é¡µé“¾è¡¨ï¼Œè¿™äº›é¡µå¯ç”¨äºåˆ†é…ã€‚æ¯ä¸ªç©ºé—²é¡µçš„é“¾è¡¨å…ƒç´ æ˜¯ä¸€ä¸ª struct run ç»“æ„ä½“ï¼ˆkernel&#x2F;kalloc.c:17ï¼‰ã€‚åˆ†é…å™¨ä»å“ªé‡Œè·å–å†…å­˜æ¥å­˜å‚¨è¿™ä¸ªæ•°æ®ç»“æ„å‘¢ï¼Ÿå®ƒä¼šåœ¨ç©ºé—²é¡µæœ¬èº«ä¸­å­˜å‚¨æ¯ä¸ªç©ºé—²é¡µçš„ run ç»“æ„ä½“ï¼Œå› ä¸ºé‚£é‡Œæ²¡æœ‰å­˜å‚¨å…¶ä»–å†…å®¹ã€‚ç©ºé—²é“¾è¡¨ç”±ä¸€ä¸ªè‡ªæ—‹é”ä¿æŠ¤ï¼ˆkernel&#x2F;kalloc.c:21-24ï¼‰ã€‚é“¾è¡¨å’Œé”è¢«å°è£…åœ¨ä¸€ä¸ª struct ç»“æ„ä½“ä¸­ï¼Œä»¥æ˜ç¡®è¡¨æ˜è¯¥é”ä¿æŠ¤çš„æ˜¯è¯¥ç»“æ„ä½“ä¸­çš„å­—æ®µã€‚ç›®å‰ï¼Œå…ˆå¿½ç•¥é”ä»¥åŠ acquire å’Œ release çš„è°ƒç”¨ï¼›ç¬¬ 6 ç« å°†è¯¦ç»†æ¢è®¨é”çš„ä½¿ç”¨ã€‚<br>main å‡½æ•°è°ƒç”¨ kinit æ¥åˆå§‹åŒ–åˆ†é…å™¨ï¼ˆkernel&#x2F;kalloc.c:27ï¼‰ã€‚kinit å°†ç©ºé—²é“¾è¡¨åˆå§‹åŒ–ä¸ºåŒ…å«å†…æ ¸ç»“æŸä½ç½®åˆ° PHYSTOP ä¹‹é—´çš„æ‰€æœ‰é¡µã€‚Xv6 æœ¬åº”é€šè¿‡è§£æç¡¬ä»¶æä¾›çš„é…ç½®ä¿¡æ¯æ¥ç¡®å®šæœ‰å¤šå°‘ç‰©ç†å†…å­˜å¯ç”¨ã€‚ä½†ç›¸åï¼ŒXv6 å‡è®¾æœºå™¨æœ‰ 128 å…†å­—èŠ‚çš„ RAMã€‚kinit è°ƒç”¨ freerangeï¼Œé€šè¿‡é€é¡µè°ƒç”¨ kfree å°†å†…å­˜æ·»åŠ åˆ°ç©ºé—²é“¾è¡¨ä¸­ã€‚é¡µè¡¨é¡¹ï¼ˆPTEï¼‰åªèƒ½å¼•ç”¨å¯¹é½åœ¨ 4096 å­—èŠ‚è¾¹ç•Œï¼ˆå³ 4096 çš„å€æ•°ï¼‰ä¸Šçš„ç‰©ç†åœ°å€ï¼Œå› æ­¤ freerange ä½¿ç”¨ PGROUNDUP æ¥ç¡®ä¿åªé‡Šæ”¾å¯¹é½çš„ç‰©ç†åœ°å€ã€‚åˆ†é…å™¨å¼€å§‹æ—¶æ²¡æœ‰å†…å­˜ï¼›è¿™äº›å¯¹ kfree çš„è°ƒç”¨ç»™äº†å®ƒä¸€äº›å†…å­˜æ¥ç®¡ç†ã€‚<br>åˆ†é…å™¨æœ‰æ—¶å°†åœ°å€è§†ä¸ºæ•´æ•°ä»¥ä¾¿å¯¹å®ƒä»¬è¿›è¡Œç®—æœ¯è¿ç®—ï¼ˆä¾‹å¦‚ï¼Œéå† freerange ä¸­çš„æ‰€æœ‰é¡µï¼‰ï¼Œæœ‰æ—¶åˆä½¿ç”¨åœ°å€ä½œä¸ºæŒ‡é’ˆæ¥è¯»å†™å†…å­˜ï¼ˆä¾‹å¦‚ï¼Œæ“ä½œå­˜å‚¨åœ¨æ¯ä¸ªé¡µä¸­çš„ run ç»“æ„ä½“ï¼‰ï¼›åœ°å€çš„è¿™ç§åŒé‡ç”¨é€”æ˜¯åˆ†é…å™¨ä»£ç ä¸­å……æ»¡ C ç±»å‹è½¬æ¢çš„ä¸»è¦åŸå› ã€‚kfree å‡½æ•°ï¼ˆkernel&#x2F;kalloc.c:47ï¼‰é¦–å…ˆå°†æ­£åœ¨é‡Šæ”¾çš„å†…å­˜ä¸­çš„æ¯ä¸ªå­—èŠ‚è®¾ç½®ä¸ºå€¼ 1ã€‚è¿™å°†å¯¼è‡´åœ¨é‡Šæ”¾å†…å­˜åä½¿ç”¨è¯¥å†…å­˜ï¼ˆä½¿ç”¨â€œæ‚¬ç©ºå¼•ç”¨â€ï¼‰çš„ä»£ç è¯»å–åˆ°åƒåœ¾æ•°æ®è€Œéæ—§çš„æœ‰æ•ˆå†…å®¹ï¼›å¸Œæœ›è¿™æ ·èƒ½è®©è¿™ç±»ä»£ç æ›´å¿«å´©æºƒã€‚ç„¶å kfree å°†é¡µæ·»åŠ åˆ°ç©ºé—²é“¾è¡¨çš„å¤´éƒ¨ï¼šå®ƒå°†ç‰©ç†åœ°å€ pa è½¬æ¢ä¸ºæŒ‡å‘ struct run çš„æŒ‡é’ˆï¼Œè®°å½•ç©ºé—²é“¾è¡¨æ—§çš„èµ·å§‹ä½ç½®åˆ° r-&gt;next ä¸­ï¼Œå¹¶å°†ç©ºé—²é“¾è¡¨è®¾ç½®ä¸º rã€‚kalloc ç§»é™¤å¹¶è¿”å›ç©ºé—²é“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚</p>
<p>3.6<br>è¿›ç¨‹åœ°å€ç©ºé—´<br>æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±çš„é¡µè¡¨ï¼Œå½“ Xv6 åœ¨è¿›ç¨‹ä¹‹é—´åˆ‡æ¢æ—¶ï¼Œå®ƒä¹Ÿä¼šåˆ‡æ¢é¡µè¡¨ã€‚å›¾ 3.4 æ¯”å›¾ 2.3 æ›´è¯¦ç»†åœ°å±•ç¤ºäº†ä¸€ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚è¿›ç¨‹çš„ç”¨æˆ·å†…å­˜ä»è™šæ‹Ÿåœ°å€é›¶å¼€å§‹ï¼Œå¯ä»¥å¢é•¿åˆ° MAXVAï¼ˆkernel&#x2F;riscv.h:375ï¼‰ï¼Œå…è®¸ä¸€ä¸ªè¿›ç¨‹åŸåˆ™ä¸Šè®¿é—® 256 å‰å­—èŠ‚çš„å†…å­˜ã€‚<br>è¿›ç¨‹çš„åœ°å€ç©ºé—´ç”±åŒ…å«ç¨‹åºæ–‡æœ¬çš„é¡µï¼ˆXv6 ä½¿ç”¨ PTE_Rã€PTE_X å’Œ PTE_U æƒé™æ˜ å°„ï¼‰ã€åŒ…å«ç¨‹åºé¢„åˆå§‹åŒ–æ•°æ®çš„é¡µã€ä¸€ä¸ªæ ˆé¡µå’Œå †é¡µç»„æˆã€‚Xv6 ä½¿ç”¨ PTE_Rã€PTE_W å’Œ PTE_U æƒé™æ˜ å°„æ•°æ®ã€æ ˆå’Œå †ã€‚<br>åœ¨ç”¨æˆ·åœ°å€ç©ºé—´ä¸­ä½¿ç”¨æƒé™æ˜¯ä¸€ç§å¼ºåŒ–ç”¨æˆ·è¿›ç¨‹çš„å¸¸ç”¨æŠ€æœ¯ã€‚å¦‚æœæ–‡æœ¬ä½¿ç”¨ PTE_W æƒé™æ˜ å°„ï¼Œé‚£ä¹ˆè¿›ç¨‹å¯èƒ½ä¼šæ„å¤–åœ°ä¿®æ”¹è‡ªå·±çš„ç¨‹åºï¼›ä¾‹å¦‚ï¼Œç¼–ç¨‹é”™è¯¯å¯èƒ½å¯¼è‡´ç¨‹åºå‘ç©ºæŒ‡é’ˆå†™å…¥ï¼Œä¿®æ”¹åœ°å€ 0 å¤„çš„æŒ‡ä»¤ï¼Œç„¶åç»§ç»­è¿è¡Œï¼Œå¯èƒ½é€ æˆæ›´å¤§çš„ç ´åã€‚ä¸ºäº†ç«‹å³æ£€æµ‹åˆ°è¿™ç±»é”™è¯¯ï¼ŒXv6 ä¸ä½¿ç”¨ PTE_W æƒé™æ˜ å°„æ–‡æœ¬ï¼›å¦‚æœç¨‹åºæ„å¤–åœ°å°è¯•å‘åœ°å€ 0 å­˜å‚¨æ•°æ®ï¼Œç¡¬ä»¶å°†æ‹’ç»æ‰§è¡Œå­˜å‚¨æ“ä½œå¹¶å¼•å‘é¡µé”™è¯¯ï¼ˆå‚è§ç¬¬ 4.6 èŠ‚ï¼‰ã€‚ç„¶åå†…æ ¸ä¼šç»ˆæ­¢è¯¥è¿›ç¨‹å¹¶æ‰“å°å‡ºæœ‰ç”¨çš„ä¿¡æ¯ï¼Œä»¥ä¾¿å¼€å‘è€…è¿½è¸ªé—®é¢˜ã€‚<br>ç±»ä¼¼åœ°ï¼Œé€šè¿‡ä¸ä½¿ç”¨ PTE_X æƒé™æ˜ å°„æ•°æ®ï¼Œç”¨æˆ·ç¨‹åºä¸èƒ½æ„å¤–åœ°è·³è½¬åˆ°ç¨‹åºæ•°æ®ä¸­çš„æŸä¸ªåœ°å€å¹¶ä»è¯¥åœ°å€å¼€å§‹æ‰§è¡Œã€‚<br>åœ¨ç°å®ä¸–ç•Œä¸­ï¼Œé€šè¿‡ä»”ç»†è®¾ç½®æƒé™æ¥å¼ºåŒ–è¿›ç¨‹ä¹Ÿæœ‰åŠ©äºæŠµå¾¡å®‰å…¨æ”»å‡»ã€‚æ”»å‡»è€…å¯èƒ½ä¼šå‘ç¨‹åºï¼ˆä¾‹å¦‚ï¼ŒWeb æœåŠ¡å™¨ï¼‰æä¾›ç²¾å¿ƒæ„é€ çš„è¾“å…¥ï¼Œä»¥è§¦å‘ç¨‹åºä¸­çš„æ¼æ´ï¼Œå¸Œæœ›å°†è¯¥æ¼æ´è½¬åŒ–ä¸ºåˆ©ç”¨æ‰‹æ®µ[14]ã€‚ä»”ç»†è®¾ç½®æƒé™ä»¥åŠå…¶ä»–æŠ€æœ¯ï¼Œä¾‹å¦‚éšæœºåŒ–ç”¨æˆ·åœ°å€ç©ºé—´çš„å¸ƒå±€ï¼Œä¼šä½¿è¿™ç±»æ”»å‡»æ›´åŠ å›°éš¾ã€‚<br>æ ˆæ˜¯ä¸€ä¸ªå•ç‹¬çš„é¡µï¼Œå¹¶æ˜¾ç¤ºä¸º exec åˆ›å»ºæ—¶çš„åˆå§‹å†…å®¹ã€‚åŒ…å«å‘½ä»¤è¡Œå‚æ•°çš„å­—ç¬¦ä¸²ä»¥åŠæŒ‡å‘å®ƒä»¬çš„æŒ‡é’ˆæ•°ç»„ä½äºæ ˆçš„æœ€é¡¶éƒ¨ã€‚ç´§æ¥ç€ä¸‹é¢æ˜¯å…è®¸ç¨‹åºä» main å‡½æ•°å¼€å§‹æ‰§è¡Œçš„å€¼ï¼Œå°±å¥½åƒ main(argc, argv) å‡½æ•°åˆšåˆšè¢«è°ƒç”¨ä¸€æ ·ã€‚<br>ä¸ºäº†æ£€æµ‹ç”¨æˆ·æ ˆæº¢å‡ºåˆ†é…çš„æ ˆå†…å­˜ï¼ŒXv6 åœ¨æ ˆçš„æ­£ä¸‹æ–¹æ”¾ç½®äº†ä¸€ä¸ªä¸å¯è®¿é—®çš„ä¿æŠ¤é¡µï¼Œæ–¹æ³•æ˜¯æ¸…é™¤ PTE_U æ ‡å¿—ã€‚å¦‚æœç”¨æˆ·æ ˆæº¢å‡ºä¸”è¿›ç¨‹å°è¯•ä½¿ç”¨æ ˆä¸‹æ–¹çš„åœ°å€ï¼Œç¡¬ä»¶å°†ç”Ÿæˆé¡µé”™è¯¯å¼‚å¸¸ï¼Œå› ä¸ºä¿æŠ¤é¡µå¯¹åœ¨ç”¨æˆ·æ¨¡å¼ä¸‹è¿è¡Œçš„ç¨‹åºæ˜¯ä¸å¯è®¿é—®çš„ã€‚ç°å®ä¸–ç•Œçš„æ“ä½œç³»ç»Ÿå¯èƒ½ä¼šåœ¨æ ˆæº¢å‡ºæ—¶è‡ªåŠ¨ä¸ºç”¨æˆ·æ ˆåˆ†é…æ›´å¤šå†…å­˜ã€‚<br>å½“è¿›ç¨‹å‘ Xv6 è¯·æ±‚æ›´å¤šç”¨æˆ·å†…å­˜æ—¶ï¼ŒXv6 ä¼šæ‰©å±•è¿›ç¨‹çš„å †ã€‚Xv6 é¦–å…ˆä½¿ç”¨ kalloc åˆ†é…ç‰©ç†é¡µã€‚ç„¶åï¼Œå®ƒå‘è¿›ç¨‹çš„é¡µè¡¨ä¸­æ·»åŠ æŒ‡å‘æ–°ç‰©ç†é¡µçš„é¡µè¡¨é¡¹ï¼ˆPTEï¼‰ã€‚Xv6 åœ¨è¿™äº› PTE ä¸­è®¾ç½® PTE_Wã€PTE_Rã€PTE_U å’Œ PTE_V æ ‡å¿—ã€‚å¤§å¤šæ•°è¿›ç¨‹ä¸ä¼šä½¿ç”¨æ•´ä¸ªç”¨æˆ·åœ°å€ç©ºé—´ï¼›Xv6 åœ¨æœªä½¿ç”¨çš„ PTE ä¸­ä¿æŒ PTE_V æ ‡å¿—ä¸ºæ¸…é™¤çŠ¶æ€ã€‚<br>æˆ‘ä»¬åœ¨è¿™é‡Œçœ‹åˆ°äº†å‡ ä¸ªä½¿ç”¨é¡µè¡¨çš„å¥½ä¾‹å­ã€‚é¦–å…ˆï¼Œä¸åŒè¿›ç¨‹çš„é¡µè¡¨å°†ç”¨æˆ·åœ°å€è½¬æ¢ä¸ºä¸åŒç‰©ç†å†…å­˜é¡µï¼Œå› æ­¤æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ç§æœ‰çš„ç”¨æˆ·å†…å­˜ã€‚å…¶æ¬¡ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½çœ‹åˆ°è‡ªå·±çš„å†…å­˜ä»é›¶å¼€å§‹å…·æœ‰è¿ç»­çš„è™šæ‹Ÿåœ°å€ï¼Œè€Œè¿›ç¨‹çš„ç‰©ç†å†…å­˜å¯ä»¥æ˜¯ä¸è¿ç»­çš„ã€‚ç¬¬ä¸‰ï¼Œå†…æ ¸åœ¨ç”¨æˆ·åœ°å€ç©ºé—´çš„é¡¶éƒ¨æ˜ å°„äº†ä¸€ä¸ªåŒ…å«è¹¦åºŠä»£ç çš„é¡µï¼ˆæ²¡æœ‰ PTE_U æƒé™ï¼‰ï¼Œå› æ­¤ä¸€é¡µç‰©ç†å†…å­˜å‡ºç°åœ¨æ‰€æœ‰åœ°å€ç©ºé—´ä¸­ï¼Œä½†åªèƒ½ç”±å†…æ ¸ä½¿ç”¨ã€‚</p>
<h3 id="3-7-Code-sbrk"><a href="#3-7-Code-sbrk" class="headerlink" title="3.7 Code: sbrk"></a>3.7 Code: sbrk</h3><ul>
<li>sbrk is the system call for a process to shrink or grow its memory. The system call is implemented<br>by the function growproc (kernel&#x2F;proc.c:260). growproc calls uvmalloc or uvmdealloc, de-<br>pending on whether n is positive or negative. uvmalloc (kernel&#x2F;vm.c:233) allocates physical mem-<br>ory with kalloc, zeros the allocated memory, and adds PTEs to the user page table with mappages.<br>uvmdealloc calls uvmunmap (kernel&#x2F;vm.c:178), which uses walk to find PTEs and kfree to<br>free the physical memory they refer to.<br>Xv6 uses a processâ€™s page table not just to tell the hardware how to map user virtual addresses, but also as the only record of which physical memory pages are allocated to that process. That is the reason why freeing user memory (in uvmunmap) requires examination of the user page table.</li>
</ul>
<h3 id="3-8-Code-exec"><a href="#3-8-Code-exec" class="headerlink" title="3.8 Code: exec"></a>3.8 Code: exec</h3><ul>
<li>A binary is typically the output of the compiler and linker, and holds<br>machine instructions and program data. <code>exec</code> (kernel&#x2F;exec.c:23) opens the named binary path using<br>namei (kernel&#x2F;exec.c:36), which is explained in Chapter 8. Then, it reads the ELF header. Xv6<br>binaries are formatted in the widely-used ELF format, defined in (kernel&#x2F;elf.h). An ELF binary<br>consists of an ELF header, struct elfhdr (kernel&#x2F;elf.h:6), followed by a sequence of program<br>section headers, struct proghdr (kernel&#x2F;elf.h:25). Each progvhdr describes a section of the<br>application that must be loaded into memory; xv6 programs have two program section headers:<br>one for instructions and one for data.<br>The first step is a quick check that the file probably contains an ELF binary. An ELF binary<br>starts with the four-byte â€œmagic numberâ€ 0x7F, â€˜Eâ€™, â€˜Lâ€™, â€˜Fâ€™, or ELF_MAGIC (kernel&#x2F;elf.h:3). If<br>the ELF header has the right magic number, exec assumes that the binary is well-formed.<br>exec allocates a new page table with no user mappings with proc_pagetable (kernel&#x2F;exec.c:49),<br>allocates memory for each ELF segment with uvmalloc (kernel&#x2F;exec.c:65), and loads each segment<br>into memory with loadseg (kernel&#x2F;exec.c:10). loadseg uses walkaddr to find the physical ad-<br>dress of the allocated memory at which to write each page of the ELF segment, and readi to read<br>from the file.</li>
<li>The program section header for &#x2F;init, the first user program created with exec, looks like this:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># objdump -p user/_init<br># å‘Šè¯‰æ“ä½œç³»ç»Ÿå¦‚ä½•å°†æ–‡ä»¶çš„å„ä¸ªæ®µï¼ˆsegmentï¼‰åŠ è½½åˆ°å†…å­˜ä¸­å»æ‰§è¡Œ<br>user/_init:     file format elf64-little<br>Program Header:<br>0x70000003 off  0x0000000000006bb0 vaddr 0x0000000000000000<br>                                        paddr 0x0000000000000000 align 2**0<br>        filesz 0x000000000000004a memsz 0x0000000000000000 flags r--<br>LOAD off        0x0000000000001000 vaddr 0x0000000000000000<br>                                        paddr 0x0000000000000000 align 2**12<br>        filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x<br>LOAD off        0x0000000000002000 vaddr 0x0000000000001000<br>                                        paddr 0x0000000000001000 align 2**12<br>        filesz 0x0000000000000010 memsz 0x0000000000000030 flags rw-<br>STACK off       0x0000000000000000 vaddr 0x0000000000000000<br>                                        paddr 0x0000000000000000 align 2**4<br>        filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-<br></code></pre></td></tr></table></figure>
<p><code>objdump -p</code> è¾“å‡ºçš„æ˜¯ ELFï¼ˆExecutable and Linkable Formatï¼‰æ–‡ä»¶çš„ <strong>ç¨‹åºå¤´è¡¨ï¼ˆProgram Header Tableï¼‰</strong>ã€‚è¿™æ˜¯ ELF æ–‡ä»¶ä¸­éå¸¸å…³é”®çš„ä¸€éƒ¨åˆ†ï¼Œå‘Šè¯‰æ“ä½œç³»ç»Ÿå¦‚ä½•å°†æ–‡ä»¶çš„å„ä¸ªæ®µï¼ˆsegmentï¼‰åŠ è½½åˆ°å†…å­˜ä¸­å»æ‰§è¡Œã€‚</p>
<p>ğŸŒŸ ELF ç¨‹åºæ®µå¤´ï¼ˆProgram Headerï¼‰å­—æ®µè¯´æ˜ï¼Œæ¯ä¸€ä¸ªæ®µï¼ˆSegmentï¼‰éƒ½å¯¹åº”ä¸‹é¢è¿™äº›å­—æ®µï¼š</p>
<table>
<thead>
<tr>
<th>å­—æ®µå</th>
<th>å«ä¹‰</th>
</tr>
</thead>
<tbody><tr>
<td><code>off</code></td>
<td>æ–‡ä»¶ä¸­è¯¥æ®µçš„åç§»ï¼ˆbyte offsetï¼‰ï¼Œä»æ–‡ä»¶å¼€å¤´ç®—ã€‚</td>
</tr>
<tr>
<td><code>vaddr</code></td>
<td>è¯¥æ®µåœ¨å†…å­˜ä¸­çš„è™šæ‹Ÿåœ°å€ï¼ˆVirtual Addressï¼‰ã€‚</td>
</tr>
<tr>
<td><code>paddr</code></td>
<td>ç‰©ç†åœ°å€ï¼ˆPhysical Addressï¼‰ï¼Œå¤§å¤šæ•°ç°ä»£ OS ä¼šå¿½ç•¥å®ƒã€‚</td>
</tr>
<tr>
<td><code>align</code></td>
<td>å¯¹é½è¦æ±‚ï¼Œå†…å­˜åŠ è½½æ—¶éœ€è¦å¯¹é½åˆ°è¿™ä¸ªå¤§å°ï¼ˆé€šå¸¸æ˜¯é¡µå¤§å°ï¼‰ã€‚</td>
</tr>
<tr>
<td><code>filesz</code></td>
<td>æ–‡ä»¶ä¸­è¯¥æ®µçš„å¤§å°ï¼ˆå­—èŠ‚æ•°ï¼‰ã€‚loadseg å°±æ˜¯è¯»å–è¿™ä¹ˆå¤šå­—èŠ‚ã€‚</td>
</tr>
<tr>
<td><code>memsz</code></td>
<td>åŠ è½½åˆ°å†…å­˜ä¸­åï¼Œè¯¥æ®µå ç”¨çš„æ€»ç©ºé—´ï¼ˆå¯èƒ½æ¯”æ–‡ä»¶å¤§ï¼Œbssæ®µå°±è¿™æ ·ï¼‰ã€‚</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>æƒé™æ ‡å¿—ï¼Œå¦‚ <code>r</code>(è¯»), <code>w</code>(å†™), <code>x</code>(æ‰§è¡Œ)</td>
</tr>
<tr>
<td><code>type</code></td>
<td>æ®µç±»å‹ï¼ˆæ¯”å¦‚ <code>LOAD</code>ã€<code>STACK</code>ã€<code>NOTE</code>ã€<code>DYNAMIC</code> ç­‰ï¼‰</td>
</tr>
<tr>
<td><code>align</code></td>
<td>å†…å­˜å¯¹é½è¦æ±‚</td>
</tr>
</tbody></table>
<h4 id="4-ä¸ª-Program-Headersï¼ˆæ®µï¼‰ï¼š"><a href="#4-ä¸ª-Program-Headersï¼ˆæ®µï¼‰ï¼š" class="headerlink" title="4 ä¸ª Program Headersï¼ˆæ®µï¼‰ï¼š"></a>4 ä¸ª Program Headersï¼ˆæ®µï¼‰ï¼š</h4><p><strong>1. ç¬¬ä¸€ä¸ªï¼šç±»å‹æ˜¯ <code>0x70000003</code>ï¼ˆéæ ‡å‡†ï¼‰</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">0x70000003 off 0x0000000000006bb0 vaddr 0x0000000000000000<br>                                        paddr 0x0000000000000000 align 2**0<br>        filesz 0x000000000000004a memsz 0x0000000000000000 flags r--<br></code></pre></td></tr></table></figure>
<ul>
<li><code>type=0x70000003</code> æ˜¯ç§æœ‰ç±»å‹ï¼ˆprocessor-specificï¼‰ï¼Œä¸æ˜¯æ ‡å‡†æ®µï¼Œä¸€èˆ¬å¼€å‘è€…ä¸å…³å¿ƒã€‚</li>
<li><code>off=0x6bb0</code> æ–‡ä»¶ä¸­åç§»åœ°å€ã€‚</li>
<li><code>filesz=0x4a</code> æœ‰ 74 å­—èŠ‚çš„æ•°æ®ã€‚</li>
<li><code>memsz=0x0</code> â€”â€”è™½ç„¶æ–‡ä»¶ä¸­æœ‰æ•°æ®ï¼Œä½†ä¸åŠ è½½åˆ°å†…å­˜é‡Œï¼ˆåƒè°ƒè¯•ä¿¡æ¯ã€noteï¼‰ã€‚</li>
<li>é€šå¸¸è¿™æ˜¯ metadataï¼Œä¸æ˜¯ä»£ç æˆ–æ•°æ®æ®µã€‚</li>
</ul>
<p><strong>2. ç¬¬äºŒä¸ªï¼šçœŸæ­£çš„ä»£ç æ®µï¼ˆtext segmentï¼‰</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">LOAD off 0x0000000000001000 vaddr 0x0000000000000000<br>                                paddr 0x0000000000000000 align 2**12<br>        filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x<br></code></pre></td></tr></table></figure>
<ul>
<li>ç±»å‹ï¼š<code>LOAD</code>ï¼Œè¡¨ç¤ºéœ€è¦åŠ è½½åˆ°å†…å­˜ä¸­ã€‚</li>
<li><code>off=0x1000</code>ï¼šä»æ–‡ä»¶åç§» 0x1000 å¼€å§‹åŠ è½½ã€‚</li>
<li><code>vaddr=0x0</code>ï¼šåŠ è½½åˆ°è™šæ‹Ÿåœ°å€ <code>0x0</code> å¤„ã€‚ï¼ˆå¾ˆé‡è¦ï¼‰</li>
<li><code>filesz=memsz=0x1000</code>ï¼šæ–‡ä»¶é‡Œå’Œå†…å­˜ä¸­éƒ½æ˜¯ 4KBã€‚</li>
<li><code>flags=r-x</code>ï¼šè¯» + æ‰§è¡Œæƒé™ã€‚è¯´æ˜è¿™æ˜¯ç¨‹åºä»£ç æ®µã€‚</li>
</ul>
<p>ğŸ”‘ <strong>è¿™ä¸ªæ®µå°±æ˜¯ç¨‹åºçš„æŒ‡ä»¤ï¼ˆtext segmentï¼‰ï¼Œexec&#x2F;loadseg ä¼šæŠŠå®ƒä»æ–‡ä»¶ä¸­è¯»åˆ°å†…å­˜çš„ 0x0 å¤„</strong></p>
<p><strong>3. ç¬¬ä¸‰ä¸ªï¼šæ•°æ®æ®µï¼ˆdata segmentï¼‰</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">LOAD off 0x0000000000002000 vaddr 0x0000000000001000<br>                                paddr 0x0000000000001000 align 2**12<br>        filesz 0x0000000000000010 memsz 0x0000000000000030 flags rw-<br></code></pre></td></tr></table></figure>

<ul>
<li>ç±»å‹ï¼š<code>LOAD</code>ï¼Œä¹Ÿè¦åŠ è½½ã€‚</li>
<li>æ–‡ä»¶åç§»ï¼š0x2000</li>
<li>è™šæ‹Ÿåœ°å€ï¼š0x1000</li>
<li><code>filesz=0x10</code>ï¼Œ<code>memsz=0x30</code>ï¼šåªæœ‰ 16 å­—èŠ‚æ¥è‡ªæ–‡ä»¶ï¼Œå‰©ä¸‹çš„æ˜¯ BSSï¼ˆéœ€è¦åˆå§‹åŒ–ä¸º 0ï¼‰ã€‚</li>
<li>æƒé™æ˜¯ <code>rw-</code>ï¼Œè¯´æ˜è¿™æ˜¯å˜é‡æ®µã€‚</li>
</ul>
<p>ğŸ”‘ è¿™ä¸ªæ®µä¿å­˜å…¨å±€å˜é‡ï¼Œéƒ¨åˆ†ä»æ–‡ä»¶åŠ è½½ï¼Œå‰©ä¸‹çš„ç”± <code>memset</code> æˆ–é¡µåˆå§‹åŒ–ä¸º 0ã€‚</p>
<p><strong>4. ç¬¬å››ä¸ªï¼šæ ˆæ®µï¼ˆSTACKï¼‰</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">STACK off 0x0000000000000000 vaddr 0x0000000000000000<br>                                paddr 0x0000000000000000 align 2**4<br>        filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-<br></code></pre></td></tr></table></figure>

<ul>
<li>ç±»å‹ï¼š<code>STACK</code>ï¼Œç”¨ä½œæ ˆæ®µã€‚</li>
<li>é€šå¸¸æ²¡å•¥å®è´¨æ€§å†…å®¹ï¼Œæ ˆæ˜¯å†…æ ¸æ‰‹åŠ¨åˆ†é…çš„ï¼ˆä¸æ˜¯ä» ELF ä¸­åŠ è½½ï¼‰ã€‚</li>
<li>è¿™åªæ˜¯ä¸€ä¸ªæ ‡è®°ï¼Œè¡¨ç¤ºè¿™ä¸ª ELF æƒ³è¦æœ‰ä¸ªæ ˆã€‚</li>
</ul>
<h2 id="â“é‚£-paddr-æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å•¥ç”¨ï¼Ÿ"><a href="#â“é‚£-paddr-æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å•¥ç”¨ï¼Ÿ" class="headerlink" title="â“é‚£ paddr æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å•¥ç”¨ï¼Ÿ"></a>â“é‚£ <code>paddr</code> æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å•¥ç”¨ï¼Ÿ</h2><p><code>paddr</code> æ˜¯<strong>ç‰©ç†åœ°å€</strong>ï¼Œ<strong>ä¼ ç»ŸåµŒå…¥å¼ç³»ç»Ÿ</strong>æˆ–<strong>è£¸æœºç¯å¢ƒ</strong>ä¸­å¯èƒ½ä¼šç”¨ï¼Œä½†ï¼š</p>
<ul>
<li><strong>ç°ä»£æ“ä½œç³»ç»Ÿï¼ˆåŒ…æ‹¬ xv6ï¼‰é€šå¸¸å¿½ç•¥å®ƒ</strong>ã€‚</li>
<li>å› ä¸º OS ä½¿ç”¨è™šæ‹Ÿåœ°å€æ˜ å°„ï¼Œå®é™…çš„ç‰©ç†åœ°å€ç”±é¡µè¡¨å†³å®šã€‚</li>
</ul>
<p>æ‰€ä»¥ä½ çœ‹åˆ° <code>paddr</code> ä¸€ç›´æ˜¯ 0ï¼Œæ„æ€æ˜¯â€œä¸å…³å¿ƒã€ä¸ä½¿ç”¨â€ã€‚</p>
<h2 id="ğŸ§©-ELF-åŠ è½½æµç¨‹ï¼ˆåœ¨-exec-ä¸­ï¼‰"><a href="#ğŸ§©-ELF-åŠ è½½æµç¨‹ï¼ˆåœ¨-exec-ä¸­ï¼‰" class="headerlink" title="ğŸ§© ELF åŠ è½½æµç¨‹ï¼ˆåœ¨ exec ä¸­ï¼‰"></a>ğŸ§© ELF åŠ è½½æµç¨‹ï¼ˆåœ¨ <code>exec</code> ä¸­ï¼‰</h2><p>ç»“åˆä½ åŸæ–‡æ‰€è¯´ï¼š</p>
<ol>
<li><p>å†…æ ¸è¯» ELF æ–‡ä»¶å¤´ï¼Œæ‰¾åˆ° Program Headersã€‚</p>
</li>
<li><p>éå†æ¯ä¸ª <code>LOAD</code> ç±»å‹æ®µï¼š</p>
<ul>
<li>ç”¨ <code>uvmalloc</code> ç»™ <code>vaddr</code>~<code>vaddr+memsz</code> åˆ†é…å†…å­˜ã€‚</li>
<li>ç”¨ <code>loadseg</code> æŠŠ <code>filesz</code> å¤§å°çš„æ•°æ®ä»æ–‡ä»¶ offset è¯»åˆ°è¯¥åœ°å€ã€‚</li>
<li>å¦‚æœ <code>memsz &gt; filesz</code>ï¼Œå‰©ä½™éƒ¨åˆ†æ¸…é›¶ã€‚</li>
</ul>
</li>
<li><p>æœ€ååˆ›å»ºç”¨æˆ·æ ˆï¼Œè®¾ç½®é™·å…¥å¸§å’Œå‚æ•°ï¼Œç„¶åè·³å…¥ç”¨æˆ·æ€æ‰§è¡Œã€‚</p>
</li>
</ol>
<h3 id="3-9-Real-world"><a href="#3-9-Real-world" class="headerlink" title="3.9 Real world"></a>3.9 Real world</h3></div><div class="article-licensing box"><div class="licensing-title"><p>xv6-riscv_ch3</p><p><a href="https://goko-son626.github.io/post/xv6-riscv-ch3.html">https://goko-son626.github.io/post/xv6-riscv-ch3.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>ä½œè€…</h6><a href="https://GoKo-Son626.github.io"><p>GoKo Mell</p></a></div></div><div class="level-item is-narrow"><div><h6>å‘å¸ƒäº</h6><p>2025-05-06</p></div></div><div class="level-item is-narrow"><div><h6>æ›´æ–°äº</h6><p>2025-05-12</p></div></div><div class="level-item is-narrow"><div><h6>è®¸å¯åè®®</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7">#Â ç›¸å…³æ–‡ç« </span><br><span>Â Â 1.<a class="is-size-6" href="/post/xv6-riscv-ch2.html" target="_blank">xv6-riscv-ch2</a><br></span><span>Â Â 2.<a class="is-size-6" href="/post/xv6-riscv-ch1.html" target="_blank">xv6-riscv-ch1</a><br></span><span>Â Â 3.<a class="is-size-6" href="/post/xv6-riscv-struct.html" target="_blank">xv6-riscv_struct</a><br></span><span>Â Â 4.<a class="is-size-6" href="/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html" target="_blank">hexoåšå®¢æ­å»º</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼Ÿæ‰“èµä¸€ä¸‹ä½œè€…å§</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>æ”¯ä»˜å®</span><span class="qrcode"><img src="/img/zfb.png" alt="æ”¯ä»˜å®"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>å¾®ä¿¡</span><span class="qrcode"><img src="/img/vx.png" alt="å¾®ä¿¡"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/xv6-riscv-ch2.html"><span class="level-item">xv6-riscv-ch2</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">è¯„è®º</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '36688d334cb3e1304bf54945350ea348',
            repo: 'blog_comment',
            owner: 'GoKo-Son626',
            clientID: 'Ov23liQkUSIVMH77fBvF',
            clientSecret: '7944864208d7577569d1f323e727967d4bdc5e79',
            admin: ["Goko-Son626"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/logo.png" alt="GoKo Mell"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GoKo Mell</p><p class="is-size-6 is-block">å°šæœªæ‰§ä½©å‰‘ï¼Œè½¬çœ¼å³æ±Ÿæ¹–</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ä¸­å›½</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">æ–‡ç« </p><a href="/archives/"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">åˆ†ç±»</p><a href="/categories/"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">æ ‡ç­¾</p><a href="/tags/"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GoKo-Son626" target="_blank" rel="noopener">å…³æ³¨æˆ‘</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/GoKo-Son626"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:goku.sonxin626@gmail.com"><i class="fa fa-envelope"></i></a></div><div><hr><p id="hitokoto">:D ä¸€è¨€å¥å­è·å–ä¸­...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"æ¥æºã€Š"+data.from+"ã€‹</p><p>æä¾›è€…-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">é“¾æ¥</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">æœ€æ–°æ–‡ç« </h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-06T01:25:24.000Z">2025-05-06</time></p><p class="title"><a href="/post/xv6-riscv-ch3.html">xv6-riscv_ch3</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-05T04:27:56.000Z">2025-05-05</time></p><p class="title"><a href="/post/xv6-riscv-ch2.html">xv6-riscv-ch2</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-05T02:00:04.000Z">2025-05-05</time></p><p class="title"><a href="/post/xv6-riscv-ch1.html">xv6-riscv-ch1</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-04T16:17:48.000Z">2025-05-05</time></p><p class="title"><a href="/post/xv6-riscv-struct.html">xv6-riscv_struct</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-01T05:25:09.000Z">2025-05-01</time></p><p class="title"><a href="/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html">hexoåšå®¢æ­å»º</a></p></div></article></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">å½’æ¡£</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/05/"><span class="level-start"><span class="level-item">äº”æœˆ 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">æ ‡ç­¾</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/xv6-riscv/"><span class="tag">xv6-riscv</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/GoKo-Mell.png" alt="GoKo&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2025 GoKo Mell</span>Â Â Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a>Â <br><span>Â© ç‰ˆæƒè¯´æ˜ï¼š[æœ¬ç½‘ç«™æ‰€æœ‰å†…å®¹å‡æ”¶é›†äºäº’è”ç½‘æˆ–è‡ªå·±åˆ›ä½œ,<br />&nbsp;&nbsp;&nbsp;&nbsp;æ–¹ä¾¿äºç½‘å‹ä¸è‡ªå·±å­¦ä¹ äº¤æµï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·<a href="mailto:goku.sonxin626@gmail.com">è”ç³»æˆ‘</a>ï¼Œç«‹å³å¤„ç†]<br /></span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="å›åˆ°é¡¶ç«¯" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('Ov23liQkUSIVMH77fBvF','7944864208d7577569d1f323e727967d4bdc5e79','GoKo-Son626','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="æƒ³è¦æŸ¥æ‰¾ä»€ä¹ˆ..."></div><a class="searchbox-close" href="javascript:;">Ã—</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"æƒ³è¦æŸ¥æ‰¾ä»€ä¹ˆ...","untitled":"(æ— æ ‡é¢˜)","posts":"æ–‡ç« ","pages":"é¡µé¢","categories":"åˆ†ç±»","tags":"æ ‡ç­¾"});
        });</script></body></html>
<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>xv6-riscv_ch3 - GoKo&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="GoKo&#039;s blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GoKo&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="This chapter covers the fundamental concepts of paging hardware, memory allocation, and process address space management, including practical code implementations like creating address spaces, physic"><meta property="og:type" content="blog"><meta property="og:title" content="GoKo"><meta property="og:url" content="https://goko-son626.github.io/"><meta property="og:site_name" content="GoKo"><meta property="og:description" content="This chapter covers the fundamental concepts of paging hardware, memory allocation, and process address space management, including practical code implementations like creating address spaces, physic"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><meta property="article:published_time" content="2025-05-06T01:25:24.000Z"><meta property="article:modified_time" content="2025-05-12T04:33:42.088Z"><meta property="article:author" content="GoKo Mell"><meta property="article:tag" content="xv6-riscv"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://goko-son626.github.io/post/xv6-riscv-ch3.html"},"headline":"GoKo's blog","image":["https://goko-son626.github.io/post/xv6-riscv-ch3/image.png","https://goko-son626.github.io/post/xv6-riscv-ch3/image-1.png","https://goko-son626.github.io/post/xv6-riscv-ch3/image-2.png","https://goko-son626.github.io/post/xv6-riscv-ch3/image-3.png"],"datePublished":"2025-05-06T01:25:24.000Z","dateModified":"2025-05-12T04:33:42.088Z","author":{"@type":"Person","name":"GoKo Mell"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"This chapter covers the fundamental concepts of paging hardware, memory allocation, and process address space management, including practical code implementations like creating address spaces, physic"}</script><link rel="canonical" href="https://goko-son626.github.io/post/xv6-riscv-ch3.html"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/rss.xml" title="GoKo's blog" type="application/rss+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/GoKo-Mell.png" alt="GoKo&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/friend">Friend</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-05-06  <a class="commentCountImg" href="/post/xv6-riscv-ch3.html#comment-container"><span class="display-none-class">36688d334cb3e1304bf54945350ea348</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="36688d334cb3e1304bf54945350ea348">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>6.8 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">xv6-riscv_ch3</h1><div class="content"><ul>
<li><em><strong>This chapter covers the fundamental concepts of paging hardware, memory allocation, and process address space management, including practical code implementations like creating address spaces, physical memory allocation, and process management functions such as <code>sbrk</code> and <code>exec</code>.</strong></em></li>
</ul>
<span id="more"></span>

<h2 id="ch3-Page-tables"><a href="#ch3-Page-tables" class="headerlink" title="ch3: Page tables"></a><strong>ch3: Page tables</strong></h2><ul>
<li>Page tables are the most popular mechanism through which the operating system provides each process with its own private address space and memory.</li>
<li>Xv6 performs a few tricks: mapping the same memory (a trampoline page) in several address spaces, and guarding kernel and user stacks with an unmapped page. The rest of this chapter explains the page tables that the RISC-V hardware provides and how xv6 uses them.</li>
</ul>
<h3 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1 Paging hardware"></a>3.1 Paging hardware</h3><ul>
<li>As a reminder, RISC-V instructions (both user and kernel) manipulate virtual addresses. The machine’s RAM, or physical memory, is indexed with physical addresses. The RISC-V page table hardware connects these two kinds of addresses, by mapping each virtual address to a physical address.</li>
<li>Xv6 runs on Sv39 RISC-V, which means that only the bottom 39 bits of a 64-bit virtual address are used; the top 25 bits are not used. In this Sv39 configuration, a RISC-V page table is logically an array of 227 (134,217,728) page table entries (PTEs). Each PTE contains a 44-bit physical page number (PPN) and some flags. The paging hardware translates a virtual address by using the top 27 bits of the 39 bits to index into the page table to find a PTE, and making a 56-bit physical address whose top 44 bits come from the PPN in the PTE and whose bottom 12 bits are copied from the original virtual address. Figure 3.1 shows this process with a logical view of the page table as a simple array of PTEs (see Figure 3.2 for a fuller story). A page table gives the operating system control over virtual-to-physical address translations at the granularity of aligned chunks of 4096 (212 ) bytes. Such a chunk is called a page.<br><img src="/post/xv6-riscv-ch3/image.png" alt="alt text"></li>
<li>In Sv39 RISC-V, the top 25 bits of a virtual address are not used for translation. The physical<br>address also has room for growth: there is room in the PTE format for the physical page number<br>to grow by another 10 bits. The designers of RISC-V chose these numbers based on technology<br>predictions. 239 bytes is 512 GB, which should be enough address space for applications running on RISC-V computers. 256 is enough physical memory space for the near future to fit many I&#x2F;O<br>devices and RAM chips. If more is needed, the RISC-V designers have defined Sv48 with 48-bit<br>virtual addresses [3].</li>
<li>As Figure 3.2 shows, a RISC-V CPU translates a virtual address into a physical in three steps.<br>A page table is stored in physical memory as a three-level tree. The root of the tree is a 4096-byte<br>page-table page that contains 512 PTEs, which contain the physical addresses for page-table pages<br>in the next level of the tree. Each of those pages contains 512 PTEs for the final level in the tree.<br>The paging hardware uses the top 9 bits of the 27 bits to select a PTE in the root page-table page,<br>the middle 9 bits to select a PTE in a page-table page in the next level of the tree, and the bottom<br>9 bits to select the final PTE. (In Sv48 RISC-V a page table has four levels, and bits 39 through 47<br>of a virtual address index into the top-level.)<br>If any of the three PTEs required to translate an address is not present, the paging hardware<br>raises a page-fault exception, leaving it up to the kernel to handle the exception (see Chapter 4).<br>The three-level structure of Figure 3.2 allows a memory-efficient way of recording PTEs, com-<br>pared to the single-level design of Figure 3.1. In the common case in which large ranges of virtual<br>addresses have no mappings, the three-level structure can omit entire page directories. For exam-<br>ple, if an application uses only a few pages starting at address zero, then the entries 1 through 511<br>of the top-level page directory are invalid, and the kernel doesn’t have to allocate pages those for<br>511 intermediate page directories. Furthermore, the kernel also doesn’t have to allocate pages for<br>the bottom-level page directories for those 511 intermediate page directories. So, in this example,<br>the three-level design saves 511 pages for intermediate page directories and 511 × 512 pages for<br>bottom-level page directories.<br>Although a CPU walks the three-level structure in hardware as part of executing a load or store<br>instruction, a potential downside of three levels is that the CPU must load three PTEs from memory<br>to perform the translation of the virtual address in the load&#x2F;store instruction to a physical address.<br>To avoid the cost of loading PTEs from physical memory, a RISC-V CPU caches page table entries<br>in a Translation Look-aside Buffer (TLB).<br><img src="/post/xv6-riscv-ch3/image-1.png" alt="alt text"><br>allowed to be used. PTE_V indicates whether the PTE is present: if it is not set, a reference to the<br>page causes an exception (i.e., is not allowed). PTE_R controls whether instructions are allowed<br>to read to the page. PTE_W controls whether instructions are allowed to write to the page. PTE_X<br>controls whether the CPU may interpret the content of the page as instructions and execute them.<br>PTE_U controls whether instructions in user mode are allowed to access the page; if PTE_U is not<br>set, the PTE can be used only in supervisor mode. Figure 3.2 shows how it all works. The flags and<br>all other page hardware-related structures are defined in (kernel&#x2F;riscv.h)</li>
<li>To tell a CPU to use a page table, the kernel must write the physical address of the root page-<br>table page into the satp register. A CPU will translate all addresses generated by subsequent<br>instructions using the page table pointed to by its own satp. Each CPU has its own satp so that<br>different CPUs can run different processes, each with a private address space described by its own<br>page table.</li>
<li><strong>notice</strong>:A few notes about terms used in this book. Physical memory refers to storage cells in RAM.<br>A byte of physical memory has an address, called a physical address. Instructions that dereference<br>addresses (such as loads, stores, jumps, and function calls) use only virtual addresses, which the<br>paging hardware translates to physical addresses, and then sends to the RAM hardware to read or<br>write storage. An address space is the set of virtual addresses that are valid in a given page table; each xv6 process has a separate user address space, and the xv6 kernel has its own address space as<br>well. User memory refers to a process’s user address space plus the physical memory that the page<br>table allows the process to access. Virtual memory refers to the ideas and techniques associated<br>with managing page tables and using them to achieve goals such as isolation.<br><img src="/post/xv6-riscv-ch3/image-2.png" alt="alt text"></li>
</ul>
<h3 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2 Kernel address space"></a>3.2 Kernel address space</h3><ul>
<li>Xv6 maintains one page table per process, describing each process’s user address space, plus a sin-<br>gle page table that describes the kernel’s address space. The kernel configures the layout of its ad-<br>dress space to give itself access to physical memory and various hardware resources at predictable virtual addresses. Figure 3.3 shows how this layout maps kernel virtual addresses to physical addresses. The file (kernel&#x2F;memlayout.h) declares the constants for xv6’s kernel memory layout.</li>
<li>The kernel gets at RAM and memory-mapped device registers using “direct mapping;” that<br>is, mapping the resources at virtual addresses that are equal to the physical address. For example,<br>the kernel itself is located at KERNBASE&#x3D;0x80000000 in both the virtual address space and in<br>physical memory. Direct mapping simplifies kernel code that reads or writes physical memory.</li>
<li>There are a couple of kernel virtual addresses that aren’t direct-mapped:<ul>
<li>The trampoline page. It is mapped at the top of the virtual address space; user page tables have this same mapping. Chapter 4 discusses the role of the trampoline page, but we see here an interesting use case of page tables; a physical page (holding the trampoline code) is mapped twice in the virtual address space of the kernel: once at top of the virtual address space and once with a direct mapping.</li>
<li>The kernel stack pages. Each process has its own kernel stack, which is mapped high so that below it xv6 can leave an unmapped guard page. The guard page’s PTE is invalid (i.e., PTE_V is not set), so that if the kernel overflows a kernel stack, it will likely cause an exception and the kernel will panic. Without a guard page an overflowing stack would overwrite other kernel memory, resulting in incorrect operation. A panic crash is preferable.</li>
</ul>
</li>
</ul>
<h3 id="3-3-Code-creating-an-address-space"><a href="#3-3-Code-creating-an-address-space" class="headerlink" title="3.3 Code: creating an address space"></a>3.3 Code: creating an address space</h3><ul>
<li>Most of the xv6 code for manipulating address spaces and page tables resides in vm.c (kernel&#x2F;vm.c:1). The central data structure is pagetable_t, which is really a pointer to a RISC-V root page-table page; a pagetable_t may be either the kernel page table, or one of the per-process page tables. The central functions are walk, which finds the PTE for a virtual address,and mappages, which installs PTEs for new mappings. Functions starting with kvm manipulate the kernel page table; functions starting with uvm manipulate a user page table; other functions are used for both. copyout and copyin copy data to and from user virtual addresses provided as system call arguments; they are in vm.c because they need to explicitly translate those addresses in order to find the corresponding physical memory.</li>
<li>Early in the boot sequence, main calls kvminit (kernel&#x2F;vm.c:54) to create the kernel’s page ta-<br>ble using kvmmake (kernel&#x2F;vm.c:20). This call occurs before xv6 has enabled paging on the RISC-V,<br>so addresses refer directly to physical memory. kvmmake first allocates a page of physical mem-<br>ory to hold the root page-table page. Then it calls kvmmap to install the translations that the kernel<br>needs. The translations include the kernel’s instructions and data, physical memory up to PHYSTOP,<br>and memory ranges which are actually devices. proc_mapstacks (kernel&#x2F;proc.c:33) allocates a<br>kernel stack for each process. It calls kvmmap to map each stack at the virtual address generated<br>by KSTACK, which leaves room for the invalid stack-guard pages.</li>
<li><code>kvmmap</code> (kernel&#x2F;vm.c:132) calls mappages (kernel&#x2F;vm.c:144), which installs mappings into a<br>page table for a range of virtual addresses to a corresponding range of physical addresses. It does<br>this separately for each virtual address in the range, at page intervals. For each virtual address to<br>be mapped, mappages calls walk to find the address of the PTE for that address. It then initializes<br>the PTE to hold the relevant physical page number, the desired permissions (PTE_W, PTE_X, and&#x2F;or<br>PTE_R), and PTE_V to mark the PTE as valid (kernel&#x2F;vm.c:165).</li>
<li><code>walk</code> (kernel&#x2F;vm.c:86) mimics the RISC-V paging hardware as it looks up the PTE for a virtual<br>address (see Figure 3.2). walk descends the page table one level at a time, using each level’s 9<br>bits of virtual address to index into the relevant page directory page. At each level it finds either<br>the PTE of the next level’s page directory page, or the PTE of final page (kernel&#x2F;vm.c:92). If a PTE<br>in a first or second level page directory page isn’t valid, then the required directory page hasn’t<br>yet been allocated; if the alloc argument is set, walk allocates a new page-table page and puts<br>its physical address in the PTE. It returns the address of the PTE in the lowest layer in the tree<br>(kernel&#x2F;vm.c:102).</li>
<li>main calls kvminithart (kernel&#x2F;vm.c:62) to install the kernel page table. It writes the physical<br>address of the root page-table page into the register satp. After this the CPU will translate ad-<br>dresses using the kernel page table. Since the kernel uses a direct mapping, the now virtual address<br>of the next instruction will map to the right physical memory address.</li>
<li>Each RISC-V CPU caches page table entries in a Translation Look-aside Buffer (TLB), and<br>when xv6 changes a page table, it must tell the CPU to invalidate corresponding cached TLB<br>entries. If it didn’t, then at some point later the TLB might use an old cached mapping, point-<br>ing to a physical page that in the meantime has been allocated to another process, and as a re-<br>sult, a process might be able to scribble on some other process’s memory. The RISC-V has an instruction sfence.vma that flushes the current CPU’s TLB. Xv6 executes sfence.vma in<br>kvminithart after reloading the satp register, and in the trampoline code that switches to a<br>user page table before returning to user space (kernel&#x2F;trampoline.S:89).<br>It is also necessary to issue sfence.vma before changing satp, in order to wait for comple-<br>tion of all outstanding loads and stores. This wait ensures that preceding updates to the page table<br>have completed, and ensures that preceding loads and stores use the old page table, not the new<br>one.<br>To avoid flushing the complete TLB, RISC-V CPUs may support address space identifiers<br>(ASIDs) [3]. The kernel can then flush just the TLB entries for a particular address space. Xv6<br>does not use this feature.</li>
</ul>
<h3 id="3-4-Physical-memory-allocation"><a href="#3-4-Physical-memory-allocation" class="headerlink" title="3.4 Physical memory allocation"></a>3.4 Physical memory allocation</h3><ul>
<li>The kernel must allocate and free physical memory at run-time for page tables, user memory,<br>kernel stacks, and pipe buffers.</li>
<li>Xv6 uses the physical memory between the end of the kernel and PHYSTOP for run-time alloca-<br>tion. It allocates and frees whole 4096-byte pages at a time. It keeps track of which pages are free<br>by threading a linked list through the pages themselves. Allocation consists of removing a page<br>from the linked list; freeing consists of adding the freed page to the list.</li>
</ul>
<h3 id="3-5-Code-Physical-memory-allocator"><a href="#3-5-Code-Physical-memory-allocator" class="headerlink" title="3.5 Code: Physical memory allocator"></a>3.5 Code: Physical memory allocator</h3><ul>
<li>The allocator resides in kalloc.c (kernel&#x2F;kalloc.c:1). The allocator’s data structure is a free list<br>of physical memory pages that are available for allocation. Each free page’s list element is a<br>struct run (kernel&#x2F;kalloc.c:17). Where does the allocator get the memory to hold that data struc-<br>ture? It store each free page’s run structure in the free page itself, since there’s nothing else stored<br>there. The free list is protected by a spin lock (kernel&#x2F;kalloc.c:21-24). The list and the lock are<br>wrapped in a struct to make clear that the lock protects the fields in the struct. For now, ignore the<br>lock and the calls to acquire and release; Chapter 6 will examine locking in detail.<br>The function main calls kinit to initialize the allocator (kernel&#x2F;kalloc.c:27). kinit initializes<br>the free list to hold every page between the end of the kernel and PHYSTOP. Xv6 ought to de-<br>termine how much physical memory is available by parsing configuration information provided<br>by the hardware. Instead xv6 assumes that the machine has 128 megabytes of RAM. kinit calls<br>freerange to add memory to the free list via per-page calls to kfree. A PTE can only refer to<br>a physical address that is aligned on a 4096-byte boundary (is a multiple of 4096), so freerange<br>uses PGROUNDUP to ensure that it frees only aligned physical addresses. The allocator starts with<br>no memory; these calls to kfree give it some to manage.<br>The allocator sometimes treats addresses as integers in order to perform arithmetic on them<br>(e.g., traversing all pages in freerange), and sometimes uses addresses as pointers to read and<br>write memory (e.g., manipulating the run structure stored in each page); this dual use of addresses<br>is the main reason that the allocator code is full of C type casts.<br>The function kfree (kernel&#x2F;kalloc.c:47) begins by setting every byte in the memory being freed<br>to the value 1. This will cause code that uses memory after freeing it (uses “dangling references”)<br>to read garbage instead of the old valid contents; hopefully that will cause such code to break faster.<br>Then kfree prepends the page to the free list: it casts pa to a pointer to struct run, records the<br>old start of the free list in r-&gt;next, and sets the free list equal to r. kalloc removes and returns<br>the first element in the free list.</li>
</ul>
<h3 id="3-6-Process-address-space"><a href="#3-6-Process-address-space" class="headerlink" title="3.6 Process address space"></a>3.6 Process address space</h3><p><img src="/post/xv6-riscv-ch3/image-3.png" alt="alt text"></p>
<ul>
<li>Each process has its own page table, and when xv6 switches between processes, it also changes<br>page tables. Figure 3.4 shows a process’s address space in more detail than Figure 2.3. A process’s<br>user memory starts at virtual address zero and can grow up to MAXVA (kernel&#x2F;riscv.h:375), allowing<br>a process to address in principle 256 Gigabytes of memory.<br>A process’s address space consists of pages that contain the text of the program (which xv6<br>maps with the permissions PTE_R, PTE_X, and PTE_U), pages that contain the pre-initialized data<br>of the program, a page for the stack, and pages for the heap. Xv6 maps the data, stack, and heap<br>with the permissions PTE_R, PTE_W, and PTE_U.<br>Using permissions within a user address space is a common technique to harden a user process.<br>If the text were mapped with PTE_W, then a process could accidentally modify its own program;<br>for example, a programming error may cause the program to write to a null pointer, modifying<br>instructions at address 0, and then continue running, perhaps creating more havoc. To detect such<br>errors immediately, xv6 maps the text without PTE_W; if a program accidentally attempts to store<br>to address 0, the hardware will refuse to execute the store and raises a page fault (see Section 4.6).<br>The kernel then kills the process and prints out an informative message so that the developer can<br>track down the problem.<br>Similarly, by mapping data without PTE_X, a user program cannot accidentally jump to an<br>address in the program’s data and start executing at that address.<br>In the real world, hardening a process by setting permissions carefully also aids in defending<br>against security attacks. An adversary may feed carefully-constructed input to a program (e.g., a<br>Web server) that triggers a bug in the program in the hope of turning that bug into an exploit [14].<br>Setting permissions carefully and other techniques, such as randomizing of the layout of the user<br>address space, make such attacks harder.<br>The stack is a single page, and is shown with the initial contents as created by exec. Strings<br>containing the command-line arguments, as well as an array of pointers to them, are at the very<br>top of the stack. Just under that are values that allow a program to start at main as if the function<br>main(argc, argv) had just been called.<br>To detect a user stack overflowing the allocated stack memory, xv6 places an inaccessible guard<br>page right below the stack by clearing the PTE_U flag. If the user stack overflows and the process<br>tries to use an address below the stack, the hardware will generate a page-fault exception because<br>the guard page is inaccessible to a program running in user mode. A real-world operating system<br>might instead automatically allocate more memory for the user stack when it overflows.<br>When a process asks xv6 for more user memory, xv6 grows the process’s heap. Xv6 first uses kalloc to allocate physical pages. It then adds PTEs to the process’s page table that point to the<br>new physical pages. Xv6 sets the PTE_W, PTE_R, PTE_U, and PTE_V flags in these PTEs. Most<br>processes do not use the entire user address space; xv6 leaves PTE_V clear in unused PTEs.<br>We see here a few nice examples of use of page tables. First, different processes’ page tables<br>translate user addresses to different pages of physical memory, so that each process has private user<br>memory. Second, each process sees its memory as having contiguous virtual addresses starting at<br>zero, while the process’s physical memory can be non-contiguous. Third, the kernel maps a page<br>with trampoline code at the top of the user address space (without PTE_U), thus a single page of<br>physical memory shows up in all address spaces, but can be used only by the kernel.<br>3.4<br>物理内存分配<br>内核必须在运行时为页表、用户内存、内核栈和管道缓冲区分配和释放物理内存。<br>Xv6 使用内核结束位置到 PHYSTOP 之间的物理内存进行运行时分配。它一次分配和释放整个 4096 字节大小的页。它通过在页自身中穿插一个链表来跟踪哪些页是空闲的。分配操作包括从链表中移除一个页；释放操作则包括将释放的页添加到链表中。</li>
</ul>
<p>3.5<br>代码：物理内存分配器<br>分配器位于 kalloc.c（kernel&#x2F;kalloc.c:1）文件中。分配器的数据结构是一个空闲页链表，这些页可用于分配。每个空闲页的链表元素是一个 struct run 结构体（kernel&#x2F;kalloc.c:17）。分配器从哪里获取内存来存储这个数据结构呢？它会在空闲页本身中存储每个空闲页的 run 结构体，因为那里没有存储其他内容。空闲链表由一个自旋锁保护（kernel&#x2F;kalloc.c:21-24）。链表和锁被封装在一个 struct 结构体中，以明确表明该锁保护的是该结构体中的字段。目前，先忽略锁以及 acquire 和 release 的调用；第 6 章将详细探讨锁的使用。<br>main 函数调用 kinit 来初始化分配器（kernel&#x2F;kalloc.c:27）。kinit 将空闲链表初始化为包含内核结束位置到 PHYSTOP 之间的所有页。Xv6 本应通过解析硬件提供的配置信息来确定有多少物理内存可用。但相反，Xv6 假设机器有 128 兆字节的 RAM。kinit 调用 freerange，通过逐页调用 kfree 将内存添加到空闲链表中。页表项（PTE）只能引用对齐在 4096 字节边界（即 4096 的倍数）上的物理地址，因此 freerange 使用 PGROUNDUP 来确保只释放对齐的物理地址。分配器开始时没有内存；这些对 kfree 的调用给了它一些内存来管理。<br>分配器有时将地址视为整数以便对它们进行算术运算（例如，遍历 freerange 中的所有页），有时又使用地址作为指针来读写内存（例如，操作存储在每个页中的 run 结构体）；地址的这种双重用途是分配器代码中充满 C 类型转换的主要原因。kfree 函数（kernel&#x2F;kalloc.c:47）首先将正在释放的内存中的每个字节设置为值 1。这将导致在释放内存后使用该内存（使用“悬空引用”）的代码读取到垃圾数据而非旧的有效内容；希望这样能让这类代码更快崩溃。然后 kfree 将页添加到空闲链表的头部：它将物理地址 pa 转换为指向 struct run 的指针，记录空闲链表旧的起始位置到 r-&gt;next 中，并将空闲链表设置为 r。kalloc 移除并返回空闲链表中的第一个元素。</p>
<p>3.6<br>进程地址空间<br>每个进程都有自己的页表，当 Xv6 在进程之间切换时，它也会切换页表。图 3.4 比图 2.3 更详细地展示了一个进程的地址空间。进程的用户内存从虚拟地址零开始，可以增长到 MAXVA（kernel&#x2F;riscv.h:375），允许一个进程原则上访问 256 吉字节的内存。<br>进程的地址空间由包含程序文本的页（Xv6 使用 PTE_R、PTE_X 和 PTE_U 权限映射）、包含程序预初始化数据的页、一个栈页和堆页组成。Xv6 使用 PTE_R、PTE_W 和 PTE_U 权限映射数据、栈和堆。<br>在用户地址空间中使用权限是一种强化用户进程的常用技术。如果文本使用 PTE_W 权限映射，那么进程可能会意外地修改自己的程序；例如，编程错误可能导致程序向空指针写入，修改地址 0 处的指令，然后继续运行，可能造成更大的破坏。为了立即检测到这类错误，Xv6 不使用 PTE_W 权限映射文本；如果程序意外地尝试向地址 0 存储数据，硬件将拒绝执行存储操作并引发页错误（参见第 4.6 节）。然后内核会终止该进程并打印出有用的信息，以便开发者追踪问题。<br>类似地，通过不使用 PTE_X 权限映射数据，用户程序不能意外地跳转到程序数据中的某个地址并从该地址开始执行。<br>在现实世界中，通过仔细设置权限来强化进程也有助于抵御安全攻击。攻击者可能会向程序（例如，Web 服务器）提供精心构造的输入，以触发程序中的漏洞，希望将该漏洞转化为利用手段[14]。仔细设置权限以及其他技术，例如随机化用户地址空间的布局，会使这类攻击更加困难。<br>栈是一个单独的页，并显示为 exec 创建时的初始内容。包含命令行参数的字符串以及指向它们的指针数组位于栈的最顶部。紧接着下面是允许程序从 main 函数开始执行的值，就好像 main(argc, argv) 函数刚刚被调用一样。<br>为了检测用户栈溢出分配的栈内存，Xv6 在栈的正下方放置了一个不可访问的保护页，方法是清除 PTE_U 标志。如果用户栈溢出且进程尝试使用栈下方的地址，硬件将生成页错误异常，因为保护页对在用户模式下运行的程序是不可访问的。现实世界的操作系统可能会在栈溢出时自动为用户栈分配更多内存。<br>当进程向 Xv6 请求更多用户内存时，Xv6 会扩展进程的堆。Xv6 首先使用 kalloc 分配物理页。然后，它向进程的页表中添加指向新物理页的页表项（PTE）。Xv6 在这些 PTE 中设置 PTE_W、PTE_R、PTE_U 和 PTE_V 标志。大多数进程不会使用整个用户地址空间；Xv6 在未使用的 PTE 中保持 PTE_V 标志为清除状态。<br>我们在这里看到了几个使用页表的好例子。首先，不同进程的页表将用户地址转换为不同物理内存页，因此每个进程都有私有的用户内存。其次，每个进程都看到自己的内存从零开始具有连续的虚拟地址，而进程的物理内存可以是不连续的。第三，内核在用户地址空间的顶部映射了一个包含蹦床代码的页（没有 PTE_U 权限），因此一页物理内存出现在所有地址空间中，但只能由内核使用。</p>
<h3 id="3-7-Code-sbrk"><a href="#3-7-Code-sbrk" class="headerlink" title="3.7 Code: sbrk"></a>3.7 Code: sbrk</h3><ul>
<li>sbrk is the system call for a process to shrink or grow its memory. The system call is implemented<br>by the function growproc (kernel&#x2F;proc.c:260). growproc calls uvmalloc or uvmdealloc, de-<br>pending on whether n is positive or negative. uvmalloc (kernel&#x2F;vm.c:233) allocates physical mem-<br>ory with kalloc, zeros the allocated memory, and adds PTEs to the user page table with mappages.<br>uvmdealloc calls uvmunmap (kernel&#x2F;vm.c:178), which uses walk to find PTEs and kfree to<br>free the physical memory they refer to.<br>Xv6 uses a process’s page table not just to tell the hardware how to map user virtual addresses, but also as the only record of which physical memory pages are allocated to that process. That is the reason why freeing user memory (in uvmunmap) requires examination of the user page table.</li>
</ul>
<h3 id="3-8-Code-exec"><a href="#3-8-Code-exec" class="headerlink" title="3.8 Code: exec"></a>3.8 Code: exec</h3><ul>
<li>A binary is typically the output of the compiler and linker, and holds<br>machine instructions and program data. <code>exec</code> (kernel&#x2F;exec.c:23) opens the named binary path using<br>namei (kernel&#x2F;exec.c:36), which is explained in Chapter 8. Then, it reads the ELF header. Xv6<br>binaries are formatted in the widely-used ELF format, defined in (kernel&#x2F;elf.h). An ELF binary<br>consists of an ELF header, struct elfhdr (kernel&#x2F;elf.h:6), followed by a sequence of program<br>section headers, struct proghdr (kernel&#x2F;elf.h:25). Each progvhdr describes a section of the<br>application that must be loaded into memory; xv6 programs have two program section headers:<br>one for instructions and one for data.<br>The first step is a quick check that the file probably contains an ELF binary. An ELF binary<br>starts with the four-byte “magic number” 0x7F, ‘E’, ‘L’, ‘F’, or ELF_MAGIC (kernel&#x2F;elf.h:3). If<br>the ELF header has the right magic number, exec assumes that the binary is well-formed.<br>exec allocates a new page table with no user mappings with proc_pagetable (kernel&#x2F;exec.c:49),<br>allocates memory for each ELF segment with uvmalloc (kernel&#x2F;exec.c:65), and loads each segment<br>into memory with loadseg (kernel&#x2F;exec.c:10). loadseg uses walkaddr to find the physical ad-<br>dress of the allocated memory at which to write each page of the ELF segment, and readi to read<br>from the file.</li>
<li>The program section header for &#x2F;init, the first user program created with exec, looks like this:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># objdump -p user/_init<br># 告诉操作系统如何将文件的各个段（segment）加载到内存中去执行<br>user/_init:     file format elf64-little<br>Program Header:<br>0x70000003 off  0x0000000000006bb0 vaddr 0x0000000000000000<br>                                        paddr 0x0000000000000000 align 2**0<br>        filesz 0x000000000000004a memsz 0x0000000000000000 flags r--<br>LOAD off        0x0000000000001000 vaddr 0x0000000000000000<br>                                        paddr 0x0000000000000000 align 2**12<br>        filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x<br>LOAD off        0x0000000000002000 vaddr 0x0000000000001000<br>                                        paddr 0x0000000000001000 align 2**12<br>        filesz 0x0000000000000010 memsz 0x0000000000000030 flags rw-<br>STACK off       0x0000000000000000 vaddr 0x0000000000000000<br>                                        paddr 0x0000000000000000 align 2**4<br>        filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-<br></code></pre></td></tr></table></figure>
<p><code>objdump -p</code> 输出的是 ELF（Executable and Linkable Format）文件的 <strong>程序头表（Program Header Table）</strong>。这是 ELF 文件中非常关键的一部分，告诉操作系统如何将文件的各个段（segment）加载到内存中去执行。</p>
<p>🌟 ELF 程序段头（Program Header）字段说明，每一个段（Segment）都对应下面这些字段：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>off</code></td>
<td>文件中该段的偏移（byte offset），从文件开头算。</td>
</tr>
<tr>
<td><code>vaddr</code></td>
<td>该段在内存中的虚拟地址（Virtual Address）。</td>
</tr>
<tr>
<td><code>paddr</code></td>
<td>物理地址（Physical Address），大多数现代 OS 会忽略它。</td>
</tr>
<tr>
<td><code>align</code></td>
<td>对齐要求，内存加载时需要对齐到这个大小（通常是页大小）。</td>
</tr>
<tr>
<td><code>filesz</code></td>
<td>文件中该段的大小（字节数）。loadseg 就是读取这么多字节。</td>
</tr>
<tr>
<td><code>memsz</code></td>
<td>加载到内存中后，该段占用的总空间（可能比文件大，bss段就这样）。</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>权限标志，如 <code>r</code>(读), <code>w</code>(写), <code>x</code>(执行)</td>
</tr>
<tr>
<td><code>type</code></td>
<td>段类型（比如 <code>LOAD</code>、<code>STACK</code>、<code>NOTE</code>、<code>DYNAMIC</code> 等）</td>
</tr>
<tr>
<td><code>align</code></td>
<td>内存对齐要求</td>
</tr>
</tbody></table>
<h4 id="4-个-Program-Headers（段）："><a href="#4-个-Program-Headers（段）：" class="headerlink" title="4 个 Program Headers（段）："></a>4 个 Program Headers（段）：</h4><p><strong>1. 第一个：类型是 <code>0x70000003</code>（非标准）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">0x70000003 off 0x0000000000006bb0 vaddr 0x0000000000000000<br>                                        paddr 0x0000000000000000 align 2**0<br>        filesz 0x000000000000004a memsz 0x0000000000000000 flags r--<br></code></pre></td></tr></table></figure>
<ul>
<li><code>type=0x70000003</code> 是私有类型（processor-specific），不是标准段，一般开发者不关心。</li>
<li><code>off=0x6bb0</code> 文件中偏移地址。</li>
<li><code>filesz=0x4a</code> 有 74 字节的数据。</li>
<li><code>memsz=0x0</code> ——虽然文件中有数据，但不加载到内存里（像调试信息、note）。</li>
<li>通常这是 metadata，不是代码或数据段。</li>
</ul>
<p><strong>2. 第二个：真正的代码段（text segment）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">LOAD off 0x0000000000001000 vaddr 0x0000000000000000<br>                                paddr 0x0000000000000000 align 2**12<br>        filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x<br></code></pre></td></tr></table></figure>
<ul>
<li>类型：<code>LOAD</code>，表示需要加载到内存中。</li>
<li><code>off=0x1000</code>：从文件偏移 0x1000 开始加载。</li>
<li><code>vaddr=0x0</code>：加载到虚拟地址 <code>0x0</code> 处。（很重要）</li>
<li><code>filesz=memsz=0x1000</code>：文件里和内存中都是 4KB。</li>
<li><code>flags=r-x</code>：读 + 执行权限。说明这是程序代码段。</li>
</ul>
<p>🔑 <strong>这个段就是程序的指令（text segment），exec&#x2F;loadseg 会把它从文件中读到内存的 0x0 处</strong></p>
<p><strong>3. 第三个：数据段（data segment）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">LOAD off 0x0000000000002000 vaddr 0x0000000000001000<br>                                paddr 0x0000000000001000 align 2**12<br>        filesz 0x0000000000000010 memsz 0x0000000000000030 flags rw-<br></code></pre></td></tr></table></figure>

<ul>
<li>类型：<code>LOAD</code>，也要加载。</li>
<li>文件偏移：0x2000</li>
<li>虚拟地址：0x1000</li>
<li><code>filesz=0x10</code>，<code>memsz=0x30</code>：只有 16 字节来自文件，剩下的是 BSS（需要初始化为 0）。</li>
<li>权限是 <code>rw-</code>，说明这是变量段。</li>
</ul>
<p>🔑 这个段保存全局变量，部分从文件加载，剩下的由 <code>memset</code> 或页初始化为 0。</p>
<p><strong>4. 第四个：栈段（STACK）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">STACK off 0x0000000000000000 vaddr 0x0000000000000000<br>                                paddr 0x0000000000000000 align 2**4<br>        filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-<br></code></pre></td></tr></table></figure>

<ul>
<li>类型：<code>STACK</code>，用作栈段。</li>
<li>通常没啥实质性内容，栈是内核手动分配的（不是从 ELF 中加载）。</li>
<li>这只是一个标记，表示这个 ELF 想要有个栈。</li>
</ul>
<h2 id="❓那-paddr-是什么？有啥用？"><a href="#❓那-paddr-是什么？有啥用？" class="headerlink" title="❓那 paddr 是什么？有啥用？"></a>❓那 <code>paddr</code> 是什么？有啥用？</h2><p><code>paddr</code> 是<strong>物理地址</strong>，<strong>传统嵌入式系统</strong>或<strong>裸机环境</strong>中可能会用，但：</p>
<ul>
<li><strong>现代操作系统（包括 xv6）通常忽略它</strong>。</li>
<li>因为 OS 使用虚拟地址映射，实际的物理地址由页表决定。</li>
</ul>
<p>所以你看到 <code>paddr</code> 一直是 0，意思是“不关心、不使用”。</p>
<h2 id="🧩-ELF-加载流程（在-exec-中）"><a href="#🧩-ELF-加载流程（在-exec-中）" class="headerlink" title="🧩 ELF 加载流程（在 exec 中）"></a>🧩 ELF 加载流程（在 <code>exec</code> 中）</h2><p>结合你原文所说：</p>
<ol>
<li><p>内核读 ELF 文件头，找到 Program Headers。</p>
</li>
<li><p>遍历每个 <code>LOAD</code> 类型段：</p>
<ul>
<li>用 <code>uvmalloc</code> 给 <code>vaddr</code>~<code>vaddr+memsz</code> 分配内存。</li>
<li>用 <code>loadseg</code> 把 <code>filesz</code> 大小的数据从文件 offset 读到该地址。</li>
<li>如果 <code>memsz &gt; filesz</code>，剩余部分清零。</li>
</ul>
</li>
<li><p>最后创建用户栈，设置陷入帧和参数，然后跳入用户态执行。</p>
</li>
</ol>
<h3 id="3-9-Real-world"><a href="#3-9-Real-world" class="headerlink" title="3.9 Real world"></a>3.9 Real world</h3></div><div class="article-licensing box"><div class="licensing-title"><p>xv6-riscv_ch3</p><p><a href="https://goko-son626.github.io/post/xv6-riscv-ch3.html">https://goko-son626.github.io/post/xv6-riscv-ch3.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://GoKo-Son626.github.io"><p>GoKo Mell</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-05-06</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-05-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/post/xv6-riscv-ch2.html" target="_blank">xv6-riscv-ch2</a><br></span><span>  2.<a class="is-size-6" href="/post/xv6-riscv-ch1.html" target="_blank">xv6-riscv-ch1</a><br></span><span>  3.<a class="is-size-6" href="/post/xv6-riscv-struct.html" target="_blank">xv6-riscv_struct</a><br></span><span>  4.<a class="is-size-6" href="/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html" target="_blank">hexo博客搭建</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/zfb.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/vx.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/xv6-riscv-ch2.html"><span class="level-item">xv6-riscv-ch2</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '36688d334cb3e1304bf54945350ea348',
            repo: 'blog_comment',
            owner: 'GoKo-Son626',
            clientID: 'Ov23liQkUSIVMH77fBvF',
            clientSecret: '7944864208d7577569d1f323e727967d4bdc5e79',
            admin: ["Goko-Son626"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/logo.png" alt="GoKo Mell"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GoKo Mell</p><p class="is-size-6 is-block">尚未执佩剑，转眼即江湖</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GoKo-Son626" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/GoKo-Son626"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:goku.sonxin626@gmail.com"><i class="fa fa-envelope"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-06T01:25:24.000Z">2025-05-06</time></p><p class="title"><a href="/post/xv6-riscv-ch3.html">xv6-riscv_ch3</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-05T04:27:56.000Z">2025-05-05</time></p><p class="title"><a href="/post/xv6-riscv-ch2.html">xv6-riscv-ch2</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-05T02:00:04.000Z">2025-05-05</time></p><p class="title"><a href="/post/xv6-riscv-ch1.html">xv6-riscv-ch1</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-04T16:17:48.000Z">2025-05-05</time></p><p class="title"><a href="/post/xv6-riscv-struct.html">xv6-riscv_struct</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-01T05:25:09.000Z">2025-05-01</time></p><p class="title"><a href="/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html">hexo博客搭建</a></p></div></article></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/xv6-riscv/"><span class="tag">xv6-riscv</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/GoKo-Mell.png" alt="GoKo&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2025 GoKo Mell</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="mailto:goku.sonxin626@gmail.com">联系我</a>，立即处理]<br /></span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('Ov23liQkUSIVMH77fBvF','7944864208d7577569d1f323e727967d4bdc5e79','GoKo-Son626','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>